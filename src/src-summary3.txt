// filepath: .env
# Environment variables for MyHives App
PORT=3000

NODE_ENV=development
API_BASE_URL=http://localhost:3000/api

# Database Configuration
DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=Cada_2068_new # <--- IMPORTANT: Replace with your actual password!
DB_NAME=myhives_db                     # <--- IMPORTANT: Replace with the database name you created!

DATABASE_URL=postgresql://postgres:Cada_2068_new@localhost:5432/myhives_db
JWT_SECRET=my_jwt_super_dupper_secret_key


# Google OAuth Credentials
GOOGLE_CLIENT_ID="your_google_client_id"
GOOGLE_CLIENT_SECRET="your_google_client_secret"

# LinkedIn OAuth Credentials
LINKEDIN_CLIENT_ID="your_linkedin_client_id"
LINKEDIN_CLIENT_SECRET="your_linkedin_client_secret"

# Frontend URL for CORS and OAuth redirects
FRONTEND_URL="http://localhost:5173" # Or your deployed frontend URL


// filepath: appExpressInstance.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import 'reflect-metadata';
import config from './config/index.js';
import errorHandler, { CustomError } from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
import authRoutes from './routes/authRoutes.js';
import locationRoutes from './routes/locationRoutes.js';
//import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
//  import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
// import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();
const apiRouter = express.Router(); // Create a new router instance

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(
  cors({
    origin: config.frontendUrl, // Allow requests from your frontend URL
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true, // Allow cookies to be sent
  })
);

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// Mount your API router on the main app
app.use('/api/v1', apiRouter);

// --- Routes ---
// Basic health check route
apiRouter.get('/health', (req: Request, res: Response) => {
  console.log('ðŸš‘ Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');

// Mount your API routes here
apiRouter.use('/auth', authRoutes);
apiRouter.use('/locations', locationRoutes);

console.log('API routes mounted');
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 404; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;


// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url);

// Get the current directory's path
const __dirname = path.dirname(__filename);

// Load environment variables from .env file
const dotEnvConfigObject = dotenv.config({ path: path.resolve(__dirname, '../../src/.env') });
console.log('dotenv config object:', dotEnvConfigObject);

// Define the IConfig interface
interface IConfig {
  port: number;
  nodeEnv: string;
  databaseUrl: string;
  jwtSecret: string;
  googleClientId: string;
  googleClientSecret: string;
  linkedinClientId: string;
  linkedinClientSecret: string;
  frontendUrl: string; // For CORS and OAuth redirects
}

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port
};

console.log('Config loaded:', config);
console.log('config.jwtSecret:', config.jwtSecret);

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
  console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
}
if (!config.databaseUrl || config.databaseUrl === 'unknown') {
  console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
}
if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
  console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
}

export default config;


// filepath: controllers\auth-controller.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/user-service.js'; // New service

import config from '../config/index.js';
import httpStatus from 'http-status'; // Good practice for error codes

import { LoginUserOutgoingDTO, UserOutgoingDTO, UpdateUserIncomingDTO } from './dto/auth-controller.dto.js';
import { UserCreationDTO, UserUpdateDTO, UserRetrievedDTO } from '../services/dto/user-service.dto.js';

export class AuthController {
  private readonly _userService: UserService;

  constructor(userService: UserService) {
    this._userService = userService;
  }

  public register = async (req: Request, res: Response, next: NextFunction) => {
    console.log('Registering user:', req.body);
    try {
      const { username, email, password } = req.body;

      // Check if user already exists
      const existingUser: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (existingUser) {
        const error = new Error('User with this email already exists.') as CustomError;
        error.statusCode = httpStatus.CONFLICT; // 409
        throw error;
      }

      // Hash password
      const hashedPassword: string = await bcrypt.hash(password, 10); // Salt rounds = 10

      const userDataLoad: UserCreationDTO = { username, email, password_hash: hashedPassword };

      // Create user
      const newUser: UserRetrievedDTO = await this._userService.createUser(userDataLoad);

      // // Generate token (optional, could just return success message)
      // const token = generateToken({ userId: newUser.user_id! });
      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User registered successfully! Please log in.',
        user: {
          id: newUser.user_id!,
          username: newUser.username,
          email: newUser.email,
        },
      };

      res.status(201).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body;

      const user: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (!user || !user.password_hash) {
        // Check for user existence and if they have a password (for traditional login)
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      // Compare password
      const isMatch: boolean = await bcrypt.compare(password, user.password_hash);
      if (!isMatch) {
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      // Generate token
      const token: string = generateToken({ userId: user.user_id! });

      res.cookie('jwtcookie', token, {
        httpOnly: true,
        secure: config.nodeEnv === 'production',
        maxAge: 1000 * 3600 * 24 * 7, // 7 days in milliseconds
      });

      const responseObj: LoginUserOutgoingDTO = {
        success: true,
        message: 'Logged in successfully!',
        token,
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public logout = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // In a stateless JWT system, the server doesn't need to do much for logout.
      // The client simply discards the token.
      // However, it's good practice to send a success message.

      // If using HTTP-only cookies for tokens, you'd clear the cookie here.
      // For example:
      res.clearCookie('jwtcookie'); // Assuming your JWT is in a cookie named 'jwtcookie'

      // You might also want to do some logging for audit purposes
      console.log(`User ${req.currentUser?.id || 'unknown'} logged out.`);

      res.status(200).json({
        success: true,
        message: 'Logged out successfully.',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('getMe called');
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      console.log('Current user ID:', req.currentUser.id);

      const user: UserRetrievedDTO | null = await this._userService.findUserById(req.currentUser.id);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      // Return user data (excluding password)
      const { password_hash: password, ...userData } = user;
      res.status(200).json({ success: true, user: userData });
    } catch (error) {
      next(error);
    }
  };

  public updateMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      const userId = req.currentUser!.id;
      const updateData: UpdateUserIncomingDTO = req.body;
      console.log('Update data received:', updateData);

      const readyToUpdate: UserUpdateDTO = { ...updateData, password_hash: updateData.password ? await bcrypt.hash(updateData.password, 10) : undefined };

      const user: UserRetrievedDTO = await this._userService.updateUser(userId, readyToUpdate);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User updated successfully!',
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\dto\auth-controller.dto.ts
// incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

export interface RegisterUserIncomingDTO {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}
// outgoing DTO for authentication response

export interface UserOutgoingDTO {
  success: boolean;
  message: string;
  user: {
    id: string;
    username: string;
    email: string;
  };
}
// DTO for user update (all fields optional)

export interface UpdateUserIncomingDTO {
  username?: string;
  email?: string;
  password?: string;
}

export type GetMeUserOutgoingDTO = Omit<UserOutgoingDTO, 'pass'>;

// DTO for user login
export type LoginUserOutgoingDTO = UserOutgoingDTO & {
  token: string;
};

export interface LoginUserIncomingDTO {
  email: string;
  password: string;
}


// filepath: controllers\dto\hive-controller.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// these DTO types are used in the HiveRouter files to define the shape of request body data it expects to receive and send out
export type HiveControllerCreateDTO = Omit<hivesAttributes, 'hive_id' | 'location_id' | 'created_at' | 'updated_at'>;
export type HiveControllerUpdateDTO = Partial<HiveControllerCreateDTO>;
export type HiveControllerCreateStrongDTO = Omit<HiveControllerCreateDTO, 'description'> & Required<Pick<HiveControllerCreateDTO, 'description'>>;

// const some: HiveControllerCreateStrongDTO = {
//   hive_name: 'Test Hive',
//   description: 'A test hive description',
//   is_active: true,
// };


// filepath: controllers\dto\location-controller.dto.ts
// DTOs for the Controller Layer (API input/output)

// Incoming DTO for creating a new location (user_id is implicit from the authenticated user)
export interface LocationControllerCreateInputDTO {
  name: string;
  address?: string;
  country?: string;
  latitude?: number;
  longitude?: number;
  notes?: string;
}

// Incoming DTO for updating an existing location (all fields optional)
export type LocationControllerUpdateInputDTO = Partial<LocationControllerCreateInputDTO>;

// Outgoing DTO for a single location response
export interface LocationControllerOutputDTO {
  success: boolean;
  message: string;
  location: {
    id: string;
    userId: string;
    name: string;
    address?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
    description?: string;
    createdAt: string;
    updatedAt: string;
  };
}

// Outgoing DTO for a list of locations
export interface LocationControllerListOutputDTO {
  success: boolean;
  message: string;
  locations: Array<LocationControllerOutputDTO['location']>;
}


// filepath: controllers\hive-controller.ts
import { Request, Response, NextFunction } from 'express';
import { HiveService } from '../services/hive-service.js';
import { CustomError } from '../middleware/errorHandler.js';
import { HiveServiceCreateDTO, HiveServiceRetrievedDTO, HiveServiceUpdateDTO } from 'services/dto/hive-service.dto.js';

export class HiveController {
  private _hiveService: HiveService;

  constructor(hiveService: HiveService) {
    this._hiveService = hiveService;
  }

  // Get all hives
  public getAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hives...', req.params);

      const location_id = req.params.locationId;

      const hives = await this._hiveService.getHivesByLocationId(location_id);

      res.status(200).json({
        success: true,
        message: 'Hives fetched successfully',
        data: hives,
      });
    } catch (error) {
      //res.status(500).json({ error: 'Failed to fetch hives' });
      next(error);
    }
  };

  // Get hive by ID
  public getHiveById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hive...', req.params);

      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      const hive: HiveServiceRetrievedDTO | null = await this._hiveService.getHiveById(location_id, hive_id);

      if (!hive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({
        success: true,
        message: 'Hive fetched successfully',
        data: hive,
      });
    } catch (error) {
      next(error);
    }
  };

  public createHive = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      console.log('Creating hive...', req.params.locationId, req.body);
      const location_id = req.params.locationId;
      const hiveBodyData = req.body;

      const hiveData: HiveServiceCreateDTO = { ...hiveBodyData, locationId: location_id };

      console.log('Hive data:', hiveData);

      const newHiveCreated = await this._hiveService.createHive(hiveData);

      res.status(201).json(newHiveCreated);
    } catch (error) {
      next(error);
    }
  };

  // Update a hive
  public updateHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;
      const updatedHiveData = req.body;
      const updateHivePayload: HiveServiceUpdateDTO = { ...updatedHiveData, location_id: location_id };

      const updatedHive = await this._hiveService.updateHive(hive_id, updateHivePayload);
      if (!updatedHive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive updated successfully',
        data: updatedHive,
      });
    } catch (error) {
      next(error);
    }
  };

  // Delete a hive
  public deleteHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      console.log('Controller : Deleting hive...', req.params);

      const deleted = await this._hiveService.deleteHive(location_id, hive_id);
      if (!deleted) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.location_id;

      const deleted = await this._hiveService.deleteAllHives(location_id);
      if (!deleted) {
        const error = new Error('Hives not deleted.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.json({ message: 'Hives deleted successfully', success: true });
    } catch (error) {
      next(error);
    }
  };
} // end of class HiveController

// export default {
//   getAllHives,
//   getHiveById,
//   createHive,
//   updateHive,
//   deleteHive,
//   deleteAllHives,
// };


// filepath: controllers\hive-inspection-controller.ts
// src/controllers/hiveInspectionController.ts

import { Response, NextFunction } from 'express';
import { CustomRequest } from '../types/DTO/per-controller/custom-request.js';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { MajorInspectionService } from '../services/major-inspection-service.js'; // Needed for ownership check
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

//import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import { UniqueConstraintError } from 'sequelize';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    console.log('Controller: Creating hive inspection');
    try {
      const { majorInspectionId } = req.params;
      //const userId = req.currentUser!.id; // Authenticated user ID

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }
      console.log('Controller: Major inspection ownership verified:', majorInspection);

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: hive_inspectionsAttributes = { ...req.body, major_inspection_id: majorInspectionId }; // Ensure majorInspectionId from param is used
      console.log('Hive inspection data to be created:', hiveData);

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(hiveData);
      console.log('Controller: New hive inspection created on database:', newHiveInspection);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      if (error instanceof UniqueConstraintError) {
        // <-- Check for the specific error
        // A specific hive should only be inspected once per major inspection event
        const _err = new Error('A hive inspection for this hive already exists in this major inspection.') as CustomError;
        _err.statusCode = httpStatus.CONFLICT; // Return 409 Conflict
        next(_err);
      } else {
        next(error);
      }
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const updateData: hive_inspectionsAttributes = req.body; // Joi validation should ensure valid partial data

      console.log('------------------ Controller: Updating hive inspection with data:', updateData);

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      console.log('------------------ Controller: Updated hive inspection:', updatedHiveInspection);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed
      console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspection);
      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('hicMajor inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\location-controller.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/location-service.js'; // Import the service
import { LocationControllerOutputDTO, LocationControllerListOutputDTO, LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from './dto/location-controller.dto.js';
import { LocationServiceCreateDTO, LocationServiceRetrievedDTO, LocationServiceUpdateDTO } from '../services/dto/location-service.dto.js';
import { LocationServiceToControllerMapper } from '../utils/converters/location/service-to-controller.mapper.js';
import { LocationControllerToServiceMapper } from '../utils/converters/location/controller-to-service.mapper.js';
import httpStatus from 'http-status';

export class LocationController {
  private readonly _locationService: LocationService;

  constructor(locationService: LocationService) {
    this._locationService = locationService;
  }

  public createLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const incomingData: LocationControllerCreateInputDTO = req.body; // from controller dto interface definition

      const serviceDataParam: LocationServiceCreateDTO = LocationControllerToServiceMapper.toServiceCreateDTO(incomingData, userId);

      const location: LocationServiceRetrievedDTO = await this._locationService.createLocation(serviceDataParam);

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(location, 'Location created successfully!', true);

      return res.status(httpStatus.CREATED).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getAllLocations = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      // we serve the GET method .... for "/" all locations for that user
      const locations: LocationServiceRetrievedDTO[] = await this._locationService.getAllLocationsByUserId(req.currentUser.id);

      const responseData: LocationControllerListOutputDTO = LocationServiceToControllerMapper.toControllerListOutputDTO(locations, 'Locations retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getLocationById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const specificLocation: LocationServiceRetrievedDTO | null = await this._locationService.getLocationById(locationId);

      if (!specificLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(specificLocation, 'Location retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public updateLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const updateDataRaw: LocationControllerUpdateInputDTO = req.body;

      const updateDataForService: LocationServiceUpdateDTO = LocationControllerToServiceMapper.toServiceUpdateDTO(updateDataRaw, userId);

      const updatedLocation: LocationServiceRetrievedDTO = await this._locationService.updateLocation(locationId, updateDataForService);

      if (!updatedLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location updated successfully',
        data: updatedLocation,
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      const { locationId } = req.params;
      const deleted: number = await this._locationService.deleteLocation(locationId);

      if (deleted === 0) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMapData = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // This endpoint retrieves data for the map view.
      // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
      // If it's only for logged-in users, keep authenticate middleware.
      // For showing "all registered beehive locations within a country" with owner email/username,
      // it might require a join query to get hive counts and owner info across all users.
      // For simplicity, let's just return a placeholder or mock data for now.
      // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
      // to aggregate hive counts per location.
      const mockMapData = [
        {
          id: 'loc1',
          latitude: 46.0569, // Ljubljana, Slovenia
          longitude: 14.5058,
          hiveCount: 12,
          ownerUsername: 'SlovenianBeekeeper',
        },
        {
          id: 'loc2',
          latitude: 46.5547, // Maribor, Slovenia
          longitude: 15.6459,
          hiveCount: 8,
          ownerUsername: 'ApiaryExplorer',
        },
      ];

      res.status(200).json({
        success: true,
        data: mockMapData,
      });
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\major-inspection-contoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/major-inspection-service.js';
import { LocationService } from '../services/location-service.js'; // To check locat
import { MajorInspectionServiceRetrievedDTO, MajorInspectionServiceCreateDTO, MajorInspectionServiceUpdateDTO } from 'services/dto/major-inspection-service.dto.js';

export class MajorInspectionController {
  private readonly _majorInspectionService: MajorInspectionService;

  constructor(majorInspectionService: MajorInspectionService) {
    this._majorInspectionService = majorInspectionService;
  }

  public async createMajorInspection(req: Request, res: Response, next: NextFunction) {
    try {
      console.log('Creating major inspection...ABCD', req.params, req.body);
      const { locationId } = req.params;

      const myData: MajorInspectionServiceCreateDTO = {
        location_id: locationId,
        ...req.body,
      };

      const newMajorInspection = await this._majorInspectionService.createMajorInspection(myData);
      res.status(201).json({
        success: true,
        message: 'Major inspection created successfully',
        data: newMajorInspection,
      });
    } catch (error) {
      next(error);
    }
  }

  public async getMajorInspections(req: Request, res: Response, next: NextFunction) {
    try {
      console.log('Fetching major inspections...');
      const { locationId } = req.params;
      const majorInspections = await this._majorInspectionService.getMajorInspectionsByLocationId(locationId);
      res.status(200).json({
        success: true,
        data: majorInspections,
      });
    } catch (error) {
      next(error);
    }
  }

  public async getSpecificMajorInspectionById(req: Request, res: Response, next: NextFunction) {
    try {
      const { majorInspectionId, locationId } = req.params;

      const majorInspection = await this._majorInspectionService.getMajorInspectionById(majorInspectionId, locationId);

      if (!majorInspection) {
        const error = new Error('cMajor inspection not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        data: majorInspection,
      });
    } catch (error) {
      next(error);
    }
  }

  public async updateMajorInspection(req: Request, res: Response, next: NextFunction) {
    try {
      const { majorInspectionId, locationId } = req.params;
      const updateData: MajorInspectionServiceUpdateDTO = { ...req.body, location_id: locationId };
      console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);
      const updatedMajorInspection = await this._majorInspectionService.updateMajorInspection(majorInspectionId, updateData);

      if (!updatedMajorInspection) {
        const error = new Error('cMajor inspection not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Major inspection updated successfully',
        data: updatedMajorInspection,
      });
    } catch (error) {
      next(error);
    }
  }
  public async deleteMajorInspection(req: Request, res: Response, next: NextFunction) {
    try {
      const { majorInspectionId, locationId } = req.params;
      const userId = req.currentUser!.id;
      const deleted = await this._majorInspectionService.deleteMajorInspection(locationId, majorInspectionId);

      if (!deleted) {
        const error = new Error('cMajor inspection not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({
        success: true,
        message: 'Major inspection deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  }

  // end of class
}

// export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Creating major inspection...ABCD', req.params, req.body);
//     const { locationId } = req.params;
//     //const inspectionData: Partial<MajorInspectionInterface> = req.body;
//     const inspectionData: Omit<MajorInspectionServiceCreateDTO, 'locationId'> = req.body;

//     const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

//     res.status(201).json({
//       success: true,
//       message: 'Major inspection created successfully',
//       data: newMajorInspection,
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Fetching major inspections...');
//     const { locationId } = req.params;

//     const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

//     res.status(200).json({
//       success: true,
//       data: majorInspections,
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     const { majorInspectionId, locationId } = req.params;
//     const userId = req.currentUser!.id;

//     const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

//     if (!majorInspection) {
//       const error = new Error('cMajor inspection not found.') as CustomError;
//       error.statusCode = 404;
//       throw error;
//     }

//     res.status(200).json({
//       success: true,
//       data: majorInspection,
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     const { majorInspectionId, locationId } = req.params;
//     const updateData: major_inspectionsAttributes = req.body;
//     console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);

//     const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(locationId, majorInspectionId, updateData);

//     if (!updatedMajorInspection) {
//       const error = new Error('cMajor inspection not found.') as CustomError;
//       error.statusCode = 404;
//       throw error;
//     }

//     res.status(200).json({
//       success: true,
//       message: 'Major inspection updated successfully',
//       data: updatedMajorInspection,
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     const { majorInspectionId, locationId } = req.params;
//     const userId = req.currentUser!.id;

//     const deleted = await MajorInspectionService.deleteMajorInspection(userId, locationId, majorInspectionId);

//     if (!deleted) {
//       const error = new Error('cMajor inspection not found.') as CustomError;
//       error.statusCode = 404;
//       throw error;
//     }

//     res.status(200).json({
//       success: true,
//       message: 'Major inspection deleted successfully',
//     });
//   } catch (error) {
//     next(error);
//   }
// };

// //export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
â”œâ”€â”€ app.ts // Express app setup, middleware, routes
â”œâ”€â”€ server.ts // Entry point, starts the server
â”œâ”€â”€ config/ // Environment variables, database config
â”‚ â””â”€â”€ index.ts
â”œâ”€â”€ database/ // ORM setup (Sequelize/TypeORM), models, migrations
â”‚ â”œâ”€â”€ index.ts
â”‚ â”œâ”€â”€ models/
â”‚ â”‚ â”œâ”€â”€ User.ts
â”‚ â”‚ â”œâ”€â”€ Location.ts
â”‚ â”‚ â”œâ”€â”€ MajorInspection.ts
â”‚ â”‚ â””â”€â”€ HiveInspection.ts
â”‚ â””â”€â”€ migrations/
â”œâ”€â”€ middleware/ // Custom middleware (auth, validation, error handling)
â”‚ â”œâ”€â”€ auth.ts // JWT verification, authorization checks
â”‚ â”œâ”€â”€ validation.ts // Joi/Zod for input validation
â”‚ â””â”€â”€ errorHandler.ts // Centralized error handling
â”œâ”€â”€ controllers/ // Business logic for each resource
â”‚ â”œâ”€â”€ authController.ts
â”‚ â”œâ”€â”€ locationController.ts
â”‚ â”œâ”€â”€ majorInspectionController.ts
â”‚ â””â”€â”€ hiveInspectionController.ts
â”œâ”€â”€ routes/ // API routes for each resource
â”‚ â”œâ”€â”€ authRoutes.ts
â”‚ â”œâ”€â”€ locationRoutes.ts
â”‚ â”œâ”€â”€ majorInspectionRoutes.ts
â”‚ â””â”€â”€ hiveInspectionRoutes.ts
â”œâ”€â”€ services/ // Database interaction logic (optional, for separation of concerns)
â”‚ â”œâ”€â”€ locationService.ts
â”‚ â””â”€â”€ ...
â”œâ”€â”€ types/ // TypeScript interfaces/types
â”‚ â”œâ”€â”€ express.d.ts // Extend Request for user property
â”‚ â”œâ”€â”€ models.ts
â”‚ â””â”€â”€ auth.ts
â””â”€â”€ utils/ // Utility functions (e.g., password hashing)
â””â”€â”€ jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts
import { Sequelize } from 'sequelize-typescript';
import config from '../config/index.js';
import { users } from './models-ts/users.js'; // To be created
import { locations } from './models-ts/locations.js'; // To be created
import { hive_inspections } from './models-ts/hive_inspections.js';
import { major_inspections } from './models-ts/major-inspections.js';
import { hives } from './models-ts/hives.js'; // To be created
import { associateModels } from './models-ts/associations.js'; // Adjust path if you placed it elsewhere, e.g., './models-obsolete/associations.js'

console.log('Connecting to PostgreSQL database... ', process.env.DATABASE_URL);

const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;
console.log('Database connection string:', databaseUrl);

// Initialize Sequelize with your database connection string<br>
const sequelize = new Sequelize({
  database: DB_NAME,
  username: DB_USER,
  password: DB_PASSWORD,
  host: DB_HOST,
  port: DB_PORT,
  dialect: DB_DIALECT,
  logging: false, // Enable logging to see SQL queries
  models: [users, locations, hive_inspections, major_inspections, hives], // Add all models here
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  },
  // Required for proper PostgreSQL UUID handling
  dialectOptions: {
    useUTC: false,
  },
  timezone: '+00:00', // Set timezone to UTC for consistency
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Set up associations between models
    associateModels();
    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
      console.log('Syncing database models (development mode)...');
      //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
      await sequelize.sync({ alter: false });
      console.log('Database models synchronized.');
    } else {
      // In production, rely on migrations. If you haven't run migrations,
      // you might still want a simple sync without alter.
      // Or remove this line entirely if you strictly use migrations.
      // await sequelize.sync();
      console.log('In production, use database migrations to manage schema changes.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};

export { sequelize as sequelizeInstance };
//export const db = sequelize;


// filepath: database\models-ts\associations.ts
import { users } from './users.js';
import { locations } from './locations.js';
import { major_inspections } from './major-inspections.js';
import { hives } from './hives.js';
import { hive_inspections } from './hive_inspections.js';

export function associateModels() {
  // User to Location (one-to-many)
  users.hasMany(locations, {
    foreignKey: 'user_id',
    as: 'locations',
  });
  locations.belongsTo(users, {
    foreignKey: 'user_id',
    as: 'user',
  });

  // Location to MajorInspection (one-to-many)
  locations.hasMany(major_inspections, {
    foreignKey: 'location_id',
    as: 'locations_majorInspections',
  });
  major_inspections.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'majorInspection_location',
  });

  // Location to Hives (one-to-many)
  locations.hasMany(hives, {
    foreignKey: 'location_id',
    as: 'locations_hives',
  });
  hives.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'hives_location',
  });

  // MajorInspection to HiveInspection (one-to-many)
  major_inspections.hasMany(hive_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'majors_hiveInspections',
  });
  hive_inspections.belongsTo(major_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'hiveInspections_majorInspection',
  });

  // Hive to HiveInspection (one-to-many)
  hives.hasMany(hive_inspections, {
    foreignKey: 'hive_id',
    as: 'hives_hiveInspections',
  });

  hive_inspections.belongsTo(hives, {
    foreignKey: 'hive_id',
    as: 'hiveInspections_hive',
  });
}


// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface hivesAttributes {
  hive_id?: string;
  location_id: string;
  hive_name: string;
  description?: string;
  is_active?: boolean;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hives',
  schema: 'public',
  timestamps: false,
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING(255),
  })
  hive_name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  description?: string;

  @Column({
    allowNull: true,
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('true'),
  })
  is_active?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  //   // --- Associations for Hive Inspections ---
  //   @HasMany(() => hive_inspections, {
  //     foreignKey: 'hive_id', // The foreign key in the 'hive_inspections' table that links back to 'hives'
  //     as: 'hiveInspections', // Alias for when you include hive inspections with a hive
  //   })
  //   hiveInspections?: hive_inspections[]; // Property to hold an array of associated hive inspections
}


// filepath: database\models-ts\hive_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

import { hives } from './hives.js'; // Import hives model
import { major_inspections } from './major-inspections.js'; // Import major_inspections model

export interface hive_inspectionsAttributes {
  hive_inspection_id?: string;
  major_inspection_id: string;
  hive_id: string;
  inspection_time: string;
  colony_health_status_id: number;
  num_chambers: number;
  brood_frames_count?: number;
  brood_percentage?: number; // no longer string
  queen_status_id: number;
  approx_honey_weight_kg?: number;
  drone_comb_frames_count?: number;
  drone_comb_percentage?: number; // no longer string
  sugar_feed_added?: boolean;
  sugar_feed_quantity_kg?: number;
  brood_chambers_count: number;
  supers_count: number;
  queen_excluder_present?: boolean;
  num_varroa_mites_found?: number;
  varroa_treatment_id?: number;
  varroa_treatment_dosage?: string;
  raising_new_queen?: boolean;
  queen_cell_age_days?: number;
  queen_cell_status_id?: number;
  other_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hive_inspections',
  schema: 'public',
  timestamps: false,
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_inspection_id?: string;

  @ForeignKey(() => major_inspections) // Indicates that major_inspection_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  major_inspection_id!: string;

  @ForeignKey(() => hives) // Indicates that hive_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  hive_id!: string;

  //   @BelongsTo(() => hives, {
  //     foreignKey: 'hive_id',
  //     as: 'hive', // Alias for when you include the hive with a hive inspection
  //   })
  //   hive?: hives; // Property to hold the associated hive

  @Column({
    type: DataType.STRING,
  })
  inspection_time!: string;

  @Column({
    type: DataType.INTEGER,
  })
  colony_health_status_id!: number;

  @Column({
    type: DataType.INTEGER,
  })
  num_chambers!: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_percentage?: number;

  @Column({
    type: DataType.INTEGER,
  })
  queen_status_id!: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  approx_honey_weight_kg?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  drone_comb_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(3, 0),
  })
  drone_comb_percentage?: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  sugar_feed_added?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  sugar_feed_quantity_kg?: number;

  @Column({
    type: DataType.INTEGER,
  })
  brood_chambers_count!: number;

  @Column({
    type: DataType.INTEGER,
  })
  supers_count!: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  queen_excluder_present?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  num_varroa_mites_found?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  varroa_treatment_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  varroa_treatment_dosage?: string;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  raising_new_queen?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_age_days?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_status_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  other_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // @BelongsTo(() => major_inspections, {
  //   foreignKey: 'major_inspection_id',
  //   as: 'majorInspection', // This alias is consistent with what you used in HiveInspectionService
  // })
  // majorInspection?: major_inspections; // Property to hold the associated major inspection
}


// filepath: database\models-ts\index.ts
export * from './hives.js';
export * from './users.js';
export * from './locations.js';
export * from './major-inspections.js';
export * from './hive_inspections.js';
export * from './colony_health_statuses.js';
export * from './queen-statuses.js';
export * from './varroa_treatments.js';
export * from './queen-cell-statuses.js';


// filepath: database\models-ts\locations.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { users } from './users.js';
// import { hives } from './hives.js'; // Import hives model
// import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface locationsAttributes {
  location_id?: string;
  user_id: string;
  name: string;
  address?: string;
  latitude?: string;
  longitude?: string;
  country?: string;
  notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'locations',
  schema: 'public',
  timestamps: false,
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  location_id?: string;

  @ForeignKey(() => users)
  @Column({
    type: DataType.UUID,
  })
  user_id!: string;

  @Column({
    type: DataType.STRING(255),
  })
  name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(500),
  })
  address?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  latitude?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  longitude?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(100),
  })
  country?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // Association with users model
  //   @BelongsTo(() => users)
  //   user?: users; // This property would hold the associated user object

  // --- Associations for Hives ---
  //   @HasMany(() => hives, {
  //     foreignKey: 'location_id', // The foreign key in the 'hives' table that links back to 'locations'
  //     as: 'hives', // Alias for when you include hives with a location
  //   })
  //   hives?: hives[]; // Property to hold an array of associated hives

  // --- Associations for Major Inspections ---
  //   @HasMany(() => major_inspections, {
  //     foreignKey: 'location_id', // The foreign key in the 'major_inspections' table that links back to 'locations'
  //     as: 'majorInspections', // Alias for when you include major inspections with a location
  //   })
  //   majorInspections?: major_inspections[]; // Property to hold an array of associated major inspections
}


// filepath: database\models-ts\major-inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';

import { locations } from './locations.js'; // Import locations model
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface major_inspectionsAttributes {
  major_inspection_id?: string;
  location_id: string;
  inspection_date: string;
  general_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'major_inspections',
  schema: 'public',
  timestamps: false,
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  major_inspection_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  // @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  // location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING,
  })
  inspection_date!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  general_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
  // --- Associations for Hive Inspections ---
  @HasMany(() => hive_inspections, {
    foreignKey: 'major_inspection_id', // The foreign key in the 'hive_inspections' table that links back to 'major_inspections'
    as: 'hiveInspections', // Alias for when you include hive inspections with a major inspection
  })
  hiveInspections?: hive_inspections;
  */
}


// filepath: database\models-ts\queen-cell-statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen-statuses.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

export interface queen_statusesAttributes {
  status_id?: number;
  status_name: string;
}

@Table({
  tableName: 'queen_statuses',
  schema: 'public',
  timestamps: false,
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {
  @Column({
    primaryKey: true,
    autoIncrement: true,
    type: DataType.INTEGER,
    defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)"),
  })
  status_id?: number;

  @Column({
    type: DataType.STRING(50),
  })
  status_name!: string;
}


// filepath: database\models-ts\users.ts
import { Model, Table, Column, DataType, Index, Sequelize, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';

export interface usersAttributes {
  user_id?: string;
  username: string;
  password_hash?: string;
  email: string;
  google_id?: string;
  linkedin_id?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'users',
  schema: 'public',
  timestamps: false,
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  user_id?: string;

  @Column({
    type: DataType.STRING(255),
  })
  username!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  password_hash?: string;

  @Column({
    type: DataType.STRING(255),
  })
  email!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  google_id?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  linkedin_id?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
	// Association with locations model
	@HasMany(() => locations, { foreignKey: 'user_id' })
    locations?: locations[]; // This property would hold an array of associated locations
	*/
}


// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: database\myhives_db_script.sql
-- Enable the pgcrypto extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Table for Users
-- Stores user authentication details, supporting traditional, Google, and LinkedIn logins.
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- Storing hashed password for traditional login
    email VARCHAR(255) UNIQUE NOT NULL,
    google_id VARCHAR(255) UNIQUE, -- Google OAuth ID
    linkedin_id VARCHAR(255) UNIQUE, -- LinkedIn OAuth ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index on commonly searched authentication fields
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_google_id ON users(google_id);
CREATE INDEX idx_users_linkedin_id ON users(linkedin_id);


-- Table for Beehive Locations/Stands
-- Stores information about where beekeepers manage their hives.
CREATE TABLE locations (
    location_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE, -- Link to the owner
    name VARCHAR(255) NOT NULL, -- Name of the location (e.g., "Backyard Apiary", "Field A")
    address VARCHAR(500), -- Optional: physical address
    latitude NUMERIC(9,6), -- Latitude for map display
    longitude NUMERIC(9,6), -- Longitude for map display
    country VARCHAR(100), -- Country for potential regional filtering/map views
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_LocationName_User UNIQUE (user_id, name) -- Location names must be unique per user
);

-- Indexes for location data
CREATE INDEX idx_locations_user_id ON locations(user_id);
CREATE INDEX idx_locations_lat_lon ON locations(latitude, longitude);


-- Table for Individual Beehives
-- Represents a specific beehive within a location, allowing tracking of its history.
CREATE TABLE hives (
    hive_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE, -- Link to its physical location
    hive_name VARCHAR(255) NOT NULL, -- Unique name/identifier for the hive within its location (e.g., "Hive 1", "Blue Box")
    description TEXT, -- General description of the hive
    is_active BOOLEAN DEFAULT TRUE, -- Flag if the hive is currently active at this location
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_HiveName_Location UNIQUE (location_id, hive_name) -- Hive names must be unique within a location
);

-- Index for hive data
CREATE INDEX idx_hives_location_id ON hives(location_id);


-- Lookup Table: Colony Health Statuses
-- Predefined options for colony health (e.g., thriving, weak, failing)
CREATE TABLE colony_health_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO colony_health_statuses (status_name) VALUES
('Thriving'),
('Weak'),
('Failing'),
('Unknown');


-- Lookup Table: Queen Statuses
-- Predefined options for queen status (e.g., seen, not seen, laying well)
CREATE TABLE queen_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_statuses (status_name) VALUES
('Seen'),
('Not Seen'),
('Laying Well'),
('Queen Cells Present'),
('Superseded'),
('Absent'),
('Virgin'),
('Unknown');


-- Lookup Table: Varroa Treatments
-- Predefined options for varroa treatments (e.g., Formic acid, Oxalic acid, None)
CREATE TABLE varroa_treatments (
    treatment_id SERIAL PRIMARY KEY,
    treatment_name VARCHAR(100) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO varroa_treatments (treatment_name) VALUES
('Formic Acid'),
('Oxalic Acid'),
('Apivar'),
('Api Life Var'),
('Mite Away Quick Strips'),
('None'),
('Other');


-- Lookup Table: Queen Cell Statuses
-- Predefined options for queen cell status (e.g., open, closed)
CREATE TABLE queen_cell_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_cell_statuses (status_name) VALUES
('Open'),
('Closed'),
('Hatched'),
('Destroyed'),
('Emerging'),
('Unknown');


-- Table for Major Inspections
-- Represents a single visit to a location where one or more hives were inspected.
CREATE TABLE major_inspections (
    major_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE,
    inspection_date DATE NOT NULL,
    general_notes TEXT, -- General notes for the entire location visit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_MajorInspection_LocationDate UNIQUE (location_id, inspection_date)
);

-- Index for major inspections
CREATE INDEX idx_major_inspections_location_date ON major_inspections(location_id, inspection_date);


-- Table for Individual Hive Inspections
-- Detailed records for each specific hive inspection within a major inspection.
CREATE TABLE hive_inspections (
    hive_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    major_inspection_id UUID NOT NULL REFERENCES major_inspections(major_inspection_id) ON DELETE CASCADE,
    hive_id UUID NOT NULL REFERENCES hives(hive_id) ON DELETE CASCADE,
    inspection_time TIME WITHOUT TIME ZONE NOT NULL, -- Hour of inspection specific to this hive
    
    -- Colony Health
    colony_health_status_id INTEGER NOT NULL REFERENCES colony_health_statuses(status_id),
    num_chambers INTEGER NOT NULL, -- Number of hive boxes/chambers
    
    -- Brood details (allowing for either count or percentage, or both)
    brood_frames_count INTEGER, -- Number of frames with brood
    brood_percentage NUMERIC(5,2), -- Percentage of brood (e.g., 75.00 for 75%)
    
    -- Queen Status
    queen_status_id INTEGER NOT NULL REFERENCES queen_statuses(status_id),
    
    -- Honey and Drone Comb
    approx_honey_weight_kg NUMERIC(8,2), -- Approximate amount of honey in kg
    drone_comb_frames_count INTEGER, -- Number of frames with drone comb
    drone_comb_percentage NUMERIC(5,2), -- Percentage of drone comb
    
    -- Feeding and Configuration
    sugar_feed_added BOOLEAN NOT NULL DEFAULT FALSE,
    sugar_feed_quantity_kg NUMERIC(8,2), -- Quantity of sugar feed added in kg
    brood_chambers_count INTEGER NOT NULL,
    supers_count INTEGER NOT NULL,
    queen_excluder_present BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Varroa Mites
    num_varroa_mites_found INTEGER,
    varroa_treatment_id INTEGER REFERENCES varroa_treatments(treatment_id),
    varroa_treatment_dosage VARCHAR(255), -- Dosage/amount (e.g., "5ml", "2 strips")
    
    -- Queen Rearing
    raising_new_queen BOOLEAN NOT NULL DEFAULT FALSE,
    queen_cell_age_days INTEGER, -- Age in days, if known
    queen_cell_status_id INTEGER REFERENCES queen_cell_statuses(status_id),
    
    other_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- A specific hive should only be inspected once per major inspection event
    CONSTRAINT UQ_HiveInspection_MajorHive UNIQUE (major_inspection_id, hive_id)
);

-- Indexes for hive inspections
CREATE INDEX idx_hive_inspections_major_id ON hive_inspections(major_inspection_id);
CREATE INDEX idx_hive_inspections_hive_id ON hive_inspections(hive_id);


-- Function to update the `updated_at` column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to automatically update `updated_at` on row modification
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_locations_updated_at
BEFORE UPDATE ON locations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hives_updated_at
BEFORE UPDATE ON hives
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_major_inspections_updated_at
BEFORE UPDATE ON major_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hive_inspections_updated_at
BEFORE UPDATE ON hive_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Authentication middleware called');
    const authHeader = req.headers.authorization;
    console.log('Token received:', req.headers.authorization);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);
    console.log('Decoded token:', decoded);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.currentUser = { id: decoded.userId }; // Ensure 'user_id' is set for compatibility};

    next();
  } catch (error: any) {
    console.error('Authentication error:', error);
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    console.error(`Error status code: ${err.statusCode}, message: ${err.message}`);
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };


// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error Handler  occurred:', {
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
  });
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;


// filepath: middleware\ownership.ts
import { Request, Response, NextFunction } from 'express';
import { LocationService } from '../services/location-service.js'; // To check location ownership
import { MajorInspectionService } from '../services/major-inspection-service.js';
import httpStatus from 'http-status';
import { CustomError } from '../middleware/errorHandler.js';
import { ParamsDictionary } from 'express-serve-static-core';

// interface LocationParams extends ParamsDictionary {
//   locationId: string;
// }

/**
 * Middleware factory that accepts an instance of LocationService via Dependency Injection.
 * It returns the actual Express middleware function which checks if the authenticated user
 * owns the resource specified by :locationId.
 *
 * @param locationService An instance of the LocationService used to perform the check.
 * @returns The Express middleware function to be used in routes.
 */
const checkLocationOwnership = (locationService: LocationService) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const locationId = req.params.locationId as string;
      // req.currentUser is set by a preceding authentication middleware (like isAuthenticated)
      const userId = req.currentUser?.id;

      if (!userId) {
        // This should be caught by isAuthenticated, but is a necessary safety check
        const error = new Error('Authentication required for ownership check.') as CustomError;
        error.statusCode = httpStatus.UNAUTHORIZED; // 401
        throw error;
      }

      // Call the non-static instance method on the injected service
      const isOwner = await locationService.checkLocationOwnership(locationId, userId);

      if (!isOwner) {
        const error = new Error('Forbidden. You do not own this location.') as CustomError;
        error.statusCode = httpStatus.FORBIDDEN; // 403
        throw error;
      }

      // Ownership confirmed, proceed
      next();
    } catch (error) {
      next(error);
    }
  };
};

/**
 * Middleware factory that checks if the authenticated user owns a Major Inspection
 * via its associated Location.
 * * @param majorInspectionService An instance of the MajorInspectionService.
 * @returns The Express middleware function.
 */
export const checkMajorInspectionOwnership = (majorInspectionService: MajorInspectionService) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const locationId = req.params.locationId as string;
      const majorInspectionId = req.params.majorInspectionId as string;
      const userId = req.currentUser?.id;

      if (!userId || !locationId || !majorInspectionId) {
        // If any ID is missing, something is wrong with the preceding middleware or routing.
        const error = new Error('Missing authentication or resource IDs.') as CustomError;
        error.statusCode = httpStatus.BAD_REQUEST; // 400
        throw error;
      }

      // --- ðŸ”‘ The Core Check (Service/Repository Delegation) ---
      // The MajorInspectionService should have a dedicated method for this.
      const isOwner = await majorInspectionService.checkMajorInspectionOwnership(majorInspectionId, locationId, userId);

      if (!isOwner) {
        const error = new Error('Forbidden. You do not own this Major Inspection or it does not exist.') as CustomError;
        error.statusCode = httpStatus.FORBIDDEN; // 403
        throw error;
      }

      // Ownership confirmed. Proceed to the Controller.
      next();
    } catch (error) {
      // Forward error to Express error handler middleware
      next(error);
    }
  };
};

export { checkLocationOwnership };


// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { CustomError } from './errorHandler.js';
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/foobar.js';

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  // console.log('Validation middleware initialized with schemas:', schemas);
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: repositories\implementations\hive-repository.ts
import { Sequelize } from 'sequelize';
import { IHiveRepository } from '../interfaces/i-hive-repository.js';
import { hives } from '../../database/models-ts/hives.js'; //'../ database/models-ts/hives.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Concrete Hive repository.
 *
 * Note: This file provides a pragmatic implementation using Prisma.
 * The exported instance is asserted to IHiveRepository to match your interface
 * even if the exact method signatures differ from this example.
 */
export class HiveRepository implements IHiveRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    const newHive = await hives.create(hiveData);
    return newHive as HiveServiceRetrievedDTO;
  }

  async update(id: string, hiveData: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]> {
    return this.db.transaction(async (t) => {
      const [updatedCount, [updatedHive]] = await hives.update(hiveData, {
        where: { hive_id: id },
        returning: true,
      });
      return [updatedCount, updatedCount > 0 ? [updatedHive as HiveServiceRetrievedDTO] : []];
    });
  }

  async findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null> {
    if (locationId) {
      const hiveWithLocation = await hives.findOne({
        where: {
          hive_id: hiveId,
          location_id: locationId,
        },
      });
      return hiveWithLocation ? (hiveWithLocation as HiveServiceRetrievedDTO) : null;
    } else {
      const hive = await hives.findByPk(hiveId);
      return hive ? (hive as HiveServiceRetrievedDTO) : null;
    }
  }

  async findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const allHives = await hives.findAll({ where: { location_id: locationId } });
    return allHives as HiveServiceRetrievedDTO[];
  }

  async delete(id: string, locationId?: string): Promise<number> {
    const whereCondition = locationId ? { hive_id: id, location_id: locationId } : { hive_id: id };

    const deletedCount: number = await hives.destroy({ where: whereCondition });
    return deletedCount;
  }

  async deleteAll(locationId: string): Promise<number> {
    const deletedCount: number = await hives.destroy({ where: { location_id: locationId } });
    return deletedCount;
  }
}


// filepath: repositories\implementations\location-repository.ts
import { Sequelize } from 'sequelize';
import { ILocationRepository } from '../interfaces/i-location-repository.js';
import { locations } from '../../database/models-ts/locations.js'; // Assuming model is imported like this
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

export class LocationRepository implements ILocationRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    const newLocation = await locations.create(location);
    return newLocation.toJSON() as LocationServiceRetrievedDTO;
  }

  async findById(id: string): Promise<LocationServiceRetrievedDTO | null> {
    const location = await locations.findByPk(id);
    return location ? (location.toJSON() as LocationServiceRetrievedDTO) : null;
  }

  async findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    const allLocations = await locations.findAll({ where: { user_id: userId } });
    return allLocations.map((location) => location.toJSON() as LocationServiceRetrievedDTO);
  }

  async update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedLocations] = await locations.update(location, {
        where: { location_id: id },
        returning: true,
        transaction: t, // Pass the transaction object
      });

      if (updatedCount > 1) {
        // Safety mechanism: If more than one row was somehow affected, trigger rollback.
        throw new Error('Concurrency failure: More than one location record updated.');
      }

      // If successful, commit automatically.
      return [updatedCount, updatedLocations.map((loc) => loc.toJSON() as LocationServiceRetrievedDTO)];
    });
  }

  async delete(id: string): Promise<number> {
    return locations.destroy({ where: { location_id: id } });
  }
}


// filepath: repositories\implementations\major-inspection-repository.ts
import { Sequelize } from 'sequelize';
import { IMajorInspectionRepository } from '../interfaces/i-major-inspection-repository.js';
import { major_inspections } from '../../database/models-ts/major-inspections.js';
import { locations } from 'database/models-ts/locations.js';
import { MajorInspectionServiceCreateDTO, MajorInspectionServiceRetrievedDTO, MajorInspectionServiceUpdateDTO } from '../../services/dto/major-inspection-service.dto.js';

export class MajorInspectionRepository implements IMajorInspectionRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(inspection: MajorInspectionServiceCreateDTO): Promise<MajorInspectionServiceRetrievedDTO> {
    const newInspection = await major_inspections.create(inspection);

    return newInspection.toJSON() as MajorInspectionServiceRetrievedDTO;
  }

  async update(inspectionId: string, locationId: string, inspection: MajorInspectionServiceUpdateDTO): Promise<[number, MajorInspectionServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedInspections] = await major_inspections.update(inspection, {
        where: { major_inspection_id: inspectionId, location_id: locationId },
        returning: true,
        transaction: t, // Pass the transaction object
      });
      return [updatedCount, updatedInspections];
    });
  }

  async findById(inspectionId: string, location_id?: string): Promise<MajorInspectionServiceRetrievedDTO | null> {
    const inspection = await major_inspections.findOne({
      where: location_id ? { major_inspection_id: inspectionId, location_id: location_id } : { major_inspection_id: inspectionId },
    });
    return inspection ? (inspection.toJSON() as MajorInspectionServiceRetrievedDTO) : null;
  }

  async findAllByLocationId(locationId: string): Promise<MajorInspectionServiceRetrievedDTO[]> {
    const allInspections = await major_inspections.findAll({ where: { location_id: locationId } });
    return allInspections.map((insp) => insp.toJSON() as MajorInspectionServiceRetrievedDTO);
  }

  async delete(inspectionId: string, locationId?: string): Promise<number> {
    const deleteCount = await major_inspections.destroy({
      where: locationId ? { major_inspection_id: inspectionId, location_id: locationId } : { major_inspection_id: inspectionId },
    });
    return deleteCount;
  }

  async findInspectionByLocationAndUser(inspectionId: string, locationId: string, userId: string): Promise<MajorInspectionServiceRetrievedDTO | null> {
    const inspection = await major_inspections.findOne({
      where: { major_inspection_id: inspectionId },
      include: [
        {
          model: locations,
          as: 'majorInspection_location', // Use your correct association alias
          attributes: [],
          where: {
            location_id: locationId,
            user_id: userId, // ðŸ”‘ The critical ownership check
          },
          required: true, // Ensures it's an INNER JOIN (must exist)
        },
      ],
    });

    return inspection ? (inspection.toJSON() as MajorInspectionServiceRetrievedDTO) : null;
  }

  // end of class
}


// filepath: repositories\implementations\user-repository.ts
import { IUserRepository } from '../interfaces/i-user-repository.js';
import { users } from '../../database/models-ts/users.js';
import { sequelizeInstance as database } from '../../database/connect.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export class UserRepository implements IUserRepository {
  private readonly db = database;

  async create(user: UserCreationDTO): Promise<UserRetrievedDTO> {
    const newUser = await users.create(user);
    return newUser.toJSON() as UserRetrievedDTO;
  }

  async readById(id: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findByPk(id);
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readByEmail(email: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findOne({ where: { email } });
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readAll(): Promise<UserRetrievedDTO[]> {
    const allUsers = await users.findAll();
    return allUsers.map((user) => user.toJSON() as UserRetrievedDTO);
  }

  async update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]> {
    const transaction = await this.db.transaction();
    try {
      const [updatedCount, updatedUsers] = await users.update(user, {
        where: { user_id: id },
        returning: true,
        transaction: transaction,
      });

      if (updatedCount > 1) {
        // Rollback if the count is unexpected (the actual fix would be to prevent this query from updating >1 in the first place,
        // but the rollback is the safety net).
        await transaction.rollback();
        throw new Error('Concurrency failure: More than one record updated.');
      }

      // COMMIT if successful
      await transaction.commit();

      return [updatedCount, updatedUsers.map((user) => user.toJSON() as UserRetrievedDTO)];
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  async delete(id: string): Promise<number> {
    const deletedCount = await users.destroy({ where: { user_id: id } });
    return deletedCount;
  }
}


// filepath: repositories\interfaces\i-hive-inspection-repository.ts


// filepath: repositories\interfaces\i-hive-repository.ts
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Interface for the Hive data access layer.
 * Manages CRUD operations for the 'hives' table.
 */
export interface IHiveRepository {
  /**
   * Creates a new hive record.
   * @param hive The data for the new hive, including the location_id.
   * @returns The created hive DTO.
   */
  create(hive: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO>;

  /**
   * Updates an existing hive record.
   * @param id The unique ID of the hive to update.
   * @param hive The partial update data.
   * @returns A tuple: [number of updated rows (should be 1), array of updated hive DTOs].
   */
  update(id: string, hive: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]>;

  /**
   * Retrieves a single hive by its ID.
   * @param hiveId The unique ID of the hive.
   * @param locationId The optional unique ID of the location.
   * @returns The hive DTO or null if not found.
   */
  findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null>;

  /**
   * Retrieves all hives associated with a specific location.
   * @param locationId The ID of the location.
   * @returns An array of hive DTOs.
   */
  findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]>;

  /**
   * Deletes a hive record by its ID.
   * @param hiveId The unique ID of the hive to delete.
   * @param locationId The optional unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  delete(hiveId: string, locationId?: string): Promise<number>;

  /**
   * Deletes a hive record by its ID.
   * @param locationId The unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  deleteAll(locationId: string): Promise<number>;
}


// filepath: repositories\interfaces\i-location-repository.ts
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

/**
 * Interface defining the data access operations for the Location model.
 * All location services will depend on this contract, not a concrete implementation.
 */
export interface ILocationRepository {
  create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO>;

  findById(id: string): Promise<LocationServiceRetrievedDTO | null>;

  findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]>;

  update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]>;

  delete(id: string): Promise<number>;
}


// filepath: repositories\interfaces\i-major-inspection-repository.ts
import { MajorInspectionServiceCreateDTO, MajorInspectionServiceRetrievedDTO, MajorInspectionServiceUpdateDTO } from 'services/dto/major-inspection-service.dto.js';

export interface IMajorInspectionRepository {
  /**
   * Creates a new major inspection record.
   * @param inspection The data for the new major inspection.
   * @returns The created major inspection DTO.
   */
  create(inspection: MajorInspectionServiceCreateDTO): Promise<MajorInspectionServiceRetrievedDTO>;

  update(inspectionId: string, locationId: string, inspection: MajorInspectionServiceUpdateDTO): Promise<[number, MajorInspectionServiceRetrievedDTO[]]>;

  findById(inspectionId: string, locationId: string): Promise<MajorInspectionServiceRetrievedDTO | null>;

  findAllByLocationId(locationId: string): Promise<MajorInspectionServiceRetrievedDTO[]>;

  delete(inspectionId: string, locationId?: string): Promise<number>;

  findInspectionByLocationAndUser(inspectionId: string, locationId: string, userId: string): Promise<MajorInspectionServiceRetrievedDTO | null>;
}


// filepath: repositories\interfaces\i-user-repository.ts
// import { users } from '../../database/models-ts/users.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export interface IUserRepository {
  create(user: UserCreationDTO): Promise<UserRetrievedDTO>;
  readById(id: string): Promise<UserRetrievedDTO | null>;
  readByEmail(email: string): Promise<UserRetrievedDTO | null>;
  readAll(): Promise<UserRetrievedDTO[]>;
  update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]>;
  delete(id: string): Promise<number>;
}


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router } from 'express';

import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { UserRepository } from '../repositories/implementations/user-repository.js';
import { UserService } from '../services/user-service.js';
//import { RegisterUserDto } from '../types/DTO/per-controller/dtos.js'; // Assuming these DTOs exist
import { RegisterUserIncomingDTO, LoginUserIncomingDTO, UpdateUserIncomingDTO } from '../controllers/dto/auth-controller.dto.js';

import { AuthController } from '../controllers/auth-controller.js';

import { isAuthenticated } from '../middleware/auth.js';

const authRouter = Router();

// --- DI SETUP ---
const userRepository = new UserRepository(); // Concrete implementation
const userService = new UserService(userRepository); // Inject Repository into Service
const authController = new AuthController(userService); // Inject Service into Controller
// --- END DI SETUP ---

const registerSchema = Joi.object<RegisterUserIncomingDTO>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required',
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
});

const loginSchema = Joi.object<LoginUserIncomingDTO>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required',
  }),
});

const updateSchema = Joi.object<UpdateUserIncomingDTO>({
  username: Joi.string().trim().optional(),
  email: Joi.string().email().optional().messages({
    'string.email': 'Email must be a valid email address',
  }),
  password: Joi.string().min(6).optional().messages({
    'string.min': 'Password must be at least 6 characters long',
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',
  validate({ body: registerSchema }), // Apply Joi validation middleware
  authController.register // Call the controller function here
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // Apply Joi validation middleware
  authController.login // Call the controller function here
);

authRouter.get('/me', isAuthenticated, authController.getMe);

authRouter.post(
  '/logout',
  isAuthenticated, // Optional: You might want to ensure only authenticated users can "logout"
  // Or, if you simply want to provide a path to clear client-side token, it can be without auth.
  authController.logout
);

authRouter.put('/me', isAuthenticated, validate({ body: updateSchema }), authController.updateMe);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;


// filepath: routes\hiveInspectionRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';

//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
//import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';
import { HiveInspectionController } from '../controllers/hive-inspection-controller.js';

const hiveInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for HiveInspection ---
// const beehiveConfigurationSchema = Joi.object({
//   type: Joi.string().required(),
//   numberOfFrames: Joi.number().integer().min(1).required(),
//   materials: Joi.array().items(Joi.string()).optional(),
//   isInsulated: Joi.boolean().optional(),
// });

const createHiveInspectionSchema = Joi.object({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  // Use the exact snake_case names from your model
  hive_id: Joi.string().uuid().required(),
  inspection_time: Joi.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .required(),
  colony_health_status_id: Joi.number().integer().required(),
  num_chambers: Joi.number().integer().min(1).required(),
  brood_chambers_count: Joi.number().integer().min(1).required(),
  supers_count: Joi.number().integer().min(0).required(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().required(),
  approx_honey_weight_kg: Joi.number().integer().min(0).max(50).optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().min(0).max(10).optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().optional().allow(null),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<hive_inspectionsAttributes>({
  hive_id: Joi.string().trim().optional(),
  inspection_time: Joi.string()
    .pattern(/^([01]\d|2[0-3]):([0-5]\d)$/)
    .optional()
    .messages({
      'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)',
    }),
  colony_health_status_id: Joi.number().integer().optional(),
  num_chambers: Joi.number().integer().min(1).optional(),
  brood_chambers_count: Joi.number().integer().min(1).optional(),
  supers_count: Joi.number().integer().min(0).optional(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().optional(),
  approx_honey_weight_kg: Joi.number().integer().optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const specificHiveInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hiveInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const rootHiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  // Add the locationId to the schema to allow it
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
    body: createHiveInspectionSchema,
  }),
  // (req, res, next) => {
  //   console.log('Validation successful');
  //   next();
  // },
  //checkMajorInspectionOwnership, // Verify parent MajorInspection ownership
  HiveInspectionController.createHiveInspection
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
  }),

  //  checkMajorInspectionOwnership,
  (req, res, next) => {
    console.log('****** GET /  ownership verified *****');
    next();
  },
  HiveInspectionController.getHiveInspectionsByMajorInspectionId
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** GET /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  //checkMajorInspectionOwnership,
  HiveInspectionController.getHiveInspectionById
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** PUT /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({
    params: specificHiveInspectionParamsSchema,
    body: updateHiveInspectionSchema,
  }),
  //checkMajorInspectionOwnership,
  HiveInspectionController.updateHiveInspection
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** DELETE /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  //checkMajorInspectionOwnership,
  HiveInspectionController.deleteHiveInspection
);

export default hiveInspectionRouter;


// filepath: routes\hiveRoutes.ts
/* define endpoints, joi schemas, and controllers for hive inspections */
import { Router } from 'express';
import Joi from 'joi';

import { HiveController } from '../controllers/hive-controller.js';
import { HiveRepository } from 'repositories/implementations/hive-repository.js';
import { HiveService } from 'services/hive-service.js';
//import { hivesAttributes } from '../database/models-ts/hives.js';
import { isAuthenticated } from '../middleware/auth.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { validate } from '../middleware/validation.js';
import { HiveControllerCreateDTO, HiveControllerCreateStrongDTO, HiveControllerUpdateDTO } from 'controllers/dto/hive-controller.dto.js';

const hiveRouter = Router({ mergeParams: true });
// --- DI SETUP ---
const hiveRepository = new HiveRepository(database); // Concrete implementation
const hiveService = new HiveService(hiveRepository); // Inject Repository into Service
const hiveController = new HiveController(hiveService); // Inject Service into Controller
// --- END DI SETUP ---

const createHivesBodySchema = Joi.object<HiveControllerCreateStrongDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .required(),
  hive_name: Joi.string().min(2).max(50).required(),
  description: Joi.string().min(2).max(200).required(),
  is_active: Joi.boolean().required(),
});

const updateHivesBodySchema = Joi.object<HiveControllerUpdateDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .optional(),
  hive_name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().min(2).max(200).optional(),
  is_active: Joi.boolean().optional(),
});

const createHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const updateHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hive_id: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

//GET /api/v1/locations/:locationId/hives - Get all hives for a specific location.
hiveRouter.get(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching hives...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.getAllHives
);
//POST /api/v1/locations/:locationId/hives - Create a new hive within a specific location.
hiveRouter.post('/', isAuthenticated, validate({ params: createHiveParamSchema, body: createHivesBodySchema }), hiveController.createHive);

//GET /api/v1/locations/:locationId/hives/:hiveId - Get a specific hive.
hiveRouter.get(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.getHiveById
);

//PUT /api/v1/locations/:locationId/hives/:hiveId - Update a specific hive.
hiveRouter.put(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Updating specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema, body: updateHivesBodySchema }),
  hiveController.updateHive
);

//DELETE /api/v1/locations/:locationId/hives/:hiveId - Delete a specific hive.
hiveRouter.delete(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.deleteHive
);
hiveRouter.delete(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting all hives ...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.deleteAllHives
);

export default hiveRouter;


// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { LocationController } from '../controllers/location-controller.js';
import { LocationService } from '../services/location-service.js';
import { LocationRepository } from '../repositories/implementations/location-repository.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { LocationControllerUpdateInputDTO, LocationControllerCreateInputDTO } from '../controllers/dto/location-controller.dto.js';
//import { createLocation, getLocations, getLocationById, updateLocation, deleteLocation, getMapData } from '../controllers/location-controller.js'; // <-- Import the controller functions

//import { locationsAttributes } from '../database/models-ts/locations.js';

import majorInspectionRouter from './majorInspectionRoutes.js';
import hiveRouter from './hiveRoutes.js';
import { checkLocationOwnership } from 'middleware/ownership.js';

const locationRouter = Router();

// --- DI SETUP ---
const locationRepository = new LocationRepository(database); // Concrete implementation
const locationService = new LocationService(locationRepository); // Inject Repository into Service
const locationController = new LocationController(locationService); // Inject Service into Controller
// --- END DI SETUP ---

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<LocationControllerCreateInputDTO>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  notes: Joi.string().trim().max(500).allow(null, ''),
  country: Joi.string().trim().max(100).allow(null, ''),
});

const updateLocationSchema = Joi.object<LocationControllerUpdateInputDTO>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  notes: Joi.string().trim().max(500).allow(null, '').optional(),
  country: Joi.string().trim().max(100).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(), // Validate as UUID
});

const ownershipMiddleware = checkLocationOwnership(locationService);

// Mount nested major inspection routes
locationRouter.use('/:locationId/major-inspections', isAuthenticated, majorInspectionRouter);
locationRouter.use('/:locationId/hives', isAuthenticated, hiveRouter);

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  locationController.createLocation
);

// GET /api/locations/map - Get map data
locationRouter.get('/map', isAuthenticated, locationController.getMapData);

// GET /api/locations - Get all locations for the authenticated user
locationRouter.get('/', isAuthenticated, locationController.getAllLocations);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  ownershipMiddleware,
  locationController.getLocationById
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  ownershipMiddleware,
  locationController.updateLocation
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  ownershipMiddleware,
  locationController.deleteLocation
);

// // Mount nested major inspection routes
// locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);

export default locationRouter;


// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { NextFunction, Response, Request, Router } from 'express';
import Joi from 'joi';

//import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { MajorInspectionService } from '../services/major-inspection-service.js';
import { MajorInspectionController } from '../controllers/major-inspection-contoller.js';
import { IMajorInspectionRepository } from '../repositories/interfaces/i-major-inspection-repository.js';
import { MajorInspectionRepository } from '../repositories/implementations/major-inspection-repository.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { checkMajorInspectionOwnership } from '../middleware/ownership.js';

import { checkLocationOwnership } from '../middleware/ownership.js';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import hiveInspectionRouter from './hiveInspectionRoutes.js';

const majorInspectionRouter = Router({ mergeParams: true });

// --- DI SETUP ---

const majorInspectionRepository: IMajorInspectionRepository = new MajorInspectionRepository(database);
const majorInspectionService = new MajorInspectionService(majorInspectionRepository);
const majorInspectionController = new MajorInspectionController(majorInspectionService);

// --- Instantiate the HOF to create the middleware function ---
const majorInspectionOwnershipMiddleware = checkMajorInspectionOwnership(majorInspectionService);
// --- END DI SETUP ---

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspection_date: Joi.date().iso().required(),
  general_notes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  inspection_date: Joi.date().iso().optional(),
  general_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const loggging = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Logging major inspections requests ...', req.params, req.body);
  next();
};
//majorInspectionRouter.use(loggging);

// Mount nested major inspection routes
// majorInspectionRouter.use('/:majorInspectionId/hive-inspections', (req, res, next) => {
//   next();
// });
majorInspectionRouter.use('/:majorInspectionId/hive-inspections', hiveInspectionRouter);

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/',
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  majorInspectionOwnershipMiddleware,
  majorInspectionController.createMajorInspection
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get('/', majorInspectionOwnershipMiddleware, majorInspectionController.getMajorInspections);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), majorInspectionOwnershipMiddleware, majorInspectionController.getSpecificMajorInspectionById);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/:majorInspectionId',
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  majorInspectionOwnershipMiddleware,
  majorInspectionController.updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), majorInspectionOwnershipMiddleware, majorInspectionController.deleteMajorInspection);

export default majorInspectionRouter;


// filepath: routes\manual-tests\hiveInspections\hiveInspections.http
###
# Hive Inspections API Tests
#
# This file assumes you have already run the `major-inspections.http` tests and have a valid token, hive ID, and major inspection ID.
# The Hive API tests might be useful for getting the hive_id.
#
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@baseUrl = http://localhost:3000/api/v1/locations/{{locationId}}
# @token = <paste_your_token_here>
# @majorInspectionId = <paste_your_major_inspection_id_here>
# @hiveId = <paste_your_hive_id_here> 
# @token =
@majorInspectionId = 3dd79818-4e59-49d7-bb82-a65b0145d87c

@hiveId = ec5ffc71-b700-4837-acdf-4dfa5b1b73e3



### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### get token
@token = {{authenticate.response.body.token}}

###
# Create a new hive inspection for a major inspection.
# @name createHiveInspection
POST {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_id": "bfdd1ef0-0cc1-4886-9ba9-572e60a70ef0",
  "inspection_time": "14:41",
  "colony_health_status_id": 1,
  "num_chambers": 3,
  "brood_chambers_count": 2,
  "supers_count": 1,
  "brood_frames_count": 15,
  "brood_percentage": 79,
  "queen_status_id": 2,
  "approx_honey_weight_kg": 10,
  "drone_comb_frames_count": 2,
  "drone_comb_percentage": 5.0,
  "sugar_feed_added": false,
  "sugar_feed_quantity_kg": null,
  "queen_excluder_present": true,
  "num_varroa_mites_found": 5,
  "varroa_treatment_id": 1,
  "varroa_treatment_dosage": "100ml",
  "raising_new_queen": false,
  "queen_cell_age_days": null,
  "queen_cell_status_id": null,
  "other_notes": "The colony seems strong and healthy. Found a few varroa mites, will continue to monitor."
}

###
# Get all hive inspections for a major inspection.
# @name getHiveInspections
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Authorization: Bearer {{token}}

###
# Get a specific hive inspection.
#
# To run this, first run the `createHiveInspection` request and copy the `hive_inspection_id`.
# @hiveInspectionId = <paste_hive_inspection_id_here>
@hiveInspectionId = {{createHiveInspection.response.body.hive_inspection_id}}
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId`.
PUT {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "brood_percentage": 33,
  "approx_honey_weight_kg": 25,
  "num_chambers": 8,
  "drone_comb_frames_count": 3,  
  "colony_health_status_id": 3,
  "other_notes": "Updated notes: The colony is doing well, but I noticed a few varroa mites."
}

###
# Delete a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\hives\hives.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@hiveId = 01127c49-7230-4405-9ef3-bba06e71a968

// --- Helper Request: Create a Hive (if you need one) ---
// @name createHive
POST {{baseUrl}}/locations/{{locationId}}/hives
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My SIXTH Hive",
  "description": "Newly established hive with a strong queen.",
  "is_active": true
}

###

// --- 1. GET all Hives for a Location ---
// @name getAllHives
GET {{baseUrl}}/locations/{{locationId}}/hives
Authorization: Bearer {{token}}

###

// --- 2. GET a single Hive by ID ---
// @name getHiveById
GET {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

###

// --- 3. Update an existing Hive ---
// @name updateHive
PUT {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My Updated Hive Name",
  "description": "Updated notes after a routine check."
}

###

// --- 4. DELETE a Hive ---
// @name deleteHive
DELETE {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

// filepath: routes\manual-tests\locations\locations.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI


### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

###
# @name createLocation
# Creates a new location.
@token2 = {{authenticate.response.body.token}}
POST {{baseUrl}}/locations
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Apiary 1",
  "address": "123 Main St, Anytown",
  "latitude": 46.0569,
  "longitude": 14.5058,
  "notes": "Main apiary location.",
  "country": "Slovenia"
}

###
# Get all locations for the authenticated user.
# @name getLocations
GET {{baseUrl}}/locations
Authorization: Bearer {{authenticate.response.body.token}}

###
# Get map data for all beehive locations.
# @name getMapData
GET {{baseUrl}}/locations/map
Authorization: Bearer {{token2}}

###
# Get a specific location by ID.
#
# To run this, first run the `createLocation` request and copy the `location_id` from the response.
# @locationId = <paste_location_id_here>
@locationId = {{createLocation.response.body.data.location_id}}
# Use the commented line below if you prefer to set the ID manually
# @locationId =
GET {{baseUrl}}/locations/{{locationId}}
Authorization: Bearer {{token}}

###
# Update a specific location by ID.
#
# To run this, you must first have a valid `locationId` from the `createLocation` request.
PUT {{baseUrl}}/locations/{{locationId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Main Apiary - Updated",
  "notes": "Updated notes for the main apiary."
}

###
# Delete a specific location by ID.
#
# To run this, you must have a valid `locationId` that has not already been deleted.
#DELETE {{baseUrl}}/locations/{{locationId}}
DELETE {{baseUrl}}/locations/2af520b3-c43a-47a8-9372-f1a3e819513b
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\majorInspections\majorInspections.http
###
# Major Inspections API Tests
#
# This file assumes you have already run the `locations.http` tests and have a valid token and location ID.
#
@baseUrl = http://localhost:3000/api/v1
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
# @locationId = <paste_your_location_id_here>

@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8

###
# Create a new major inspection for a specific location.
# @name createMajorInspection
POST {{baseUrl}}/locations/{{locationId}}/major-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "inspection_date": "2024-09-08T10:00:00.000Z",
  "general_notes": "This is temporary test foobar record."
}

###
# Get all major inspections for a specific location.
# @name getMajorInspections
GET {{baseUrl}}/locations/{{locationId}}/major-inspections
Authorization: Bearer {{token}}

###
# Get a specific major inspection by ID.
#
# To run this, first run the `createMajorInspection` request and copy the `major_inspection_id`.
# @majorInspectionId = <paste_major_inspection_id_here>
@majorInspectionId = {{createMajorInspection.response.body.data.major_inspection_id}}
GET {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId`.
PUT {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "general_notes": "Updated notes: Queen seems healthy."
}

###
# Delete a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
#DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/dee8f057-9efb-463b-93da-76ccfad03a54
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\users\user_requests.http
### Check HEALTH Endpoint
# @name checkHealth
GET http://localhost:3000/api/v1/health
Content-Type: application/json    


### Register a New User
###
# @name registerUser
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "TonyClark",
  "email": "tonyclark@gmail.com",
  "password": "password1234"
}

### Register a User with Existing Email (Expected: 409 Conflict)
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "anotheruser",
  "email": "test2@example.com",
  "password": "anotherpassword"
}


### Login with Valid Credentials
# @name loginValidUser
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json
Accept: application/json

{
    "email" : "tonyclark@gmail.com",    
    "password" : "password1234"
}

### Login with Invalid Password (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "tonyclark@gmail.com",
  "password": "password1234"
} 

### Login with Non-Existent Email (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez55@gmail.com",
    "password" : "Cada_73NUN5"
}

### Get Current User (without token - Expected: 401 Unauthorized)
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json

### Get Current User (with valid token)
# Replace {{authToken}} with the token received from a successful login request
@token2 = {{loginValidUser.response.body.token}}
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json
Authorization: Bearer {{token2}}


### Logout User
# This request is mainly for demonstration/logging purposes on the server.
# The real logout happens on the client by deleting the token.
POST http://localhost:3000/api/v1/auth/logout
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later

const startServer = async () => {
  try {
    const testVar: any = 'This should trigger a warning';
    // 1. Connect to the database
    console.log('Attempting to connect to the database...');
    await connectDB();
    console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`âš¡ï¸[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\nðŸ™ˆ-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('âŒ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log('startServer();');
startServer();


// filepath: services\dto\hive-inspection.dto.ts
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

export type HiveInspectionServiceCreateDTO = Omit<hive_inspectionsAttributes, 'hive_inspection_id' | 'created_at' | 'updated_at'>;
export type HiveInspectionServiceUpdateDTO = Partial<HiveInspectionServiceCreateDTO>;
export type HiveInspectionServiceRetrievedDTO = hive_inspectionsAttributes;


// filepath: services\dto\hive-service.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// Input for creating a new hive (omits ID and timestamps)
export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Input for updating a hive (all fields optional, omits foreign key and IDs)
export type HiveServiceUpdateDTO = Partial<HiveServiceCreateDTO>;

// Output/Retrieved DTO for a hive
export type HiveServiceRetrievedDTO = hivesAttributes;


// filepath: services\dto\location-service.dto.ts
import { locationsAttributes } from '../../database/models-ts/locations.js';

// Location domain types - for creating, updating, and retrieving location data
// The service layer uses these DTOs to enforce data shape and decouple from Sequelize's model attributes.

// Data required to create a new location
export type LocationServiceCreateDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;

// Data used to update an existing location (all fields optional)
export type LocationServiceUpdateDTO = Partial<Omit<LocationServiceCreateDTO, 'user_id'>>;

// Data shape of a fully retrieved location record
export type LocationServiceRetrievedDTO = locationsAttributes;


// filepath: services\dto\major-inspection-service.dto.ts
import { major_inspectionsAttributes, major_inspections } from 'database/models-ts/major-inspections.js';

export type MajorInspectionServiceCreateDTO = Omit<major_inspectionsAttributes, 'major_inspection_id' | 'created_at' | 'updated_at'>;
export type MajorInspectionServiceUpdateDTO = Partial<MajorInspectionServiceCreateDTO>;
export type MajorInspectionServiceRetrievedDTO = major_inspectionsAttributes;


// filepath: services\dto\user-service.dto.ts
import { usersAttributes } from '../../database/models-ts/users.js';

// User domain types - for creating, updating, and retrieving user data ... called on the services layer
export type UserCreationDTO = Omit<usersAttributes, 'user_id' | 'created_at' | 'updated_at' | 'google_id' | 'linkedin_id'>;
export type UserUpdateDTO = Partial<UserCreationDTO>;
export type UserRetrievedDTO = Omit<usersAttributes, 'google_id' | 'linkedin_id'>;


// filepath: services\hive-inspection-service.ts
// src/services/hiveInspectionService.ts

import { hive_inspections } from '../database/models-ts/hive_inspections.js';
//import { major_inspections } from 'database/models-ts/major_inspections.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js'; // Importing the type for hive inspection attributes
//import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
//import { HiveInspectionCreationAttributes } from '../database/models-obsolete/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(hiveInspectionData: hive_inspectionsAttributes): Promise<hive_inspectionsAttributes> {
    const newHiveInspection = await hive_inspections.create({ ...hiveInspectionData });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(majorInspectionId: string): Promise<hive_inspectionsAttributes[]> {
    const hiveInspections = await hive_inspections.findAll({ where: { major_inspection_id: majorInspectionId }, order: [['created_at', 'ASC']] });
    return hiveInspections.map((hi) => hi.toJSON());
  }

  public static async getHiveInspectionById(id: string, majorInspectionId: string): Promise<hive_inspectionsAttributes | null> {
    const hiveInspection = await hive_inspections.findOne({ where: { hive_inspection_id: id, major_inspection_id: majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(id: string, majorInspectionId: string, updateData: Partial<hive_inspectionsAttributes>): Promise<hive_inspectionsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await hive_inspections.update(updateData, {
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(id: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await hive_inspections.destroy({
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
    });
    return deletedRows > 0;
  }

  /**
   * Retrieves hive inspections for a specific hive, ensuring both the hive itself
   * and its associated major inspection belong to the given location.
   * This enforces a strong authorization chain and filters results precisely.
   *
   * @param locationId The ID of the location to filter by.
   * @param hiveNumber The ID of the hive to filter by (corresponds to hive_id).
   * @returns A promise that resolves to an array of hive inspection attributes.
   */
  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<hive_inspectionsAttributes[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await hive_inspections.findAll({
      include: [
        {
          // 1. Include the 'majorInspection' association
          // This ensures the hive inspection is linked to a major inspection
          // that belongs to the specified location.
          association: 'majorInspection', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          where: { location_id: locationId }, // Filter major_inspections by their location_id column
          required: true, // Perform an INNER JOIN, meaning the major inspection must exist and match the locationId
        },
        {
          // 2. Include the 'hive' association
          // This ensures the hive inspection is linked to a hive
          // that also belongs to the specified location.
          association: 'hive', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          required: true, // Perform an INNER JOIN, meaning the hive must exist
          where: { location_id: locationId }, // Filter hives by their location_id column
        },
      ],
      where: {
        // 3. Filter the primary hive_inspections by the specific hive_id
        hive_id: hiveNumber,
      },
      order: [['created_at', 'ASC']],
    });
    return hiveInspections.map((hi) => hi.toJSON());
  }
}


// filepath: services\hive-service.ts
// src/services/hiveService.ts

//import { hives, hivesAttributes } from '../database/models-ts/hives.js';
import { IHiveRepository } from '../repositories/interfaces/i-hive-repository.js'; // repositories/interfaces/i-hive-repository.js';
import { HiveInspectionServiceRetrievedDTO } from './dto/hive-inspection.dto.js';
//import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';
//import { locations } from '../database/models-ts/locations.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';

export class HiveService {
  private _hiveRepository: IHiveRepository;

  constructor(private hiveRepository: IHiveRepository) {
    this._hiveRepository = hiveRepository;
  }

  // TODO MODIFY METHODS TO USE REPOSITORY INSTEAD OF DIRECT MODEL ACCESS
  /**
   * Retrieves all hives associated with a specific location, ensuring the location belongs to the user.
   * @param locationId The ID of the location to retrieve hives for.
   * @returns A promise that resolves to an array of hive objects.
   */
  public async getHivesByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const hivesFound: HiveServiceRetrievedDTO[] = await this._hiveRepository.findAllByLocationId(locationId); //  .findAll({

    return hivesFound;
  }

  /**
   * Retrieves a single hive by its ID and location ID, ensuring the location belongs to the user.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to retrieve.
   * @returns A promise that resolves to the hive object or null if not found.
   */
  public async getHiveById(locationId: string, hiveId: string): Promise<HiveServiceRetrievedDTO | null> {
    const hive = await this._hiveRepository.findById(hiveId, locationId); // .findOne({

    return hive ? hive : null;
  }

  /**
   * Creates a new hive for a given location.
   * @param hiveData The data for the new hive.
   * @returns A promise that resolves to the newly created hive object.
   */
  public async createHive(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    console.log('Service Creating hive...', hiveData);

    const newCreatedHive = await this._hiveRepository.create(hiveData);
    return newCreatedHive; //.toJSON();
  }

  /**
   * Updates an existing hive.
   * @param hiveId The ID of the hive to update.
   * @param updateData The data to update.
   * @returns A promise that resolves to the updated hive object or null if not found.
   */
  public async updateHive(hiveId: string, updateData: HiveServiceUpdateDTO): Promise<HiveServiceRetrievedDTO | null> {
    // Check if the hive exists and belongs to the user and location
    const hiveToUpdate = await this._hiveRepository.findById(hiveId);

    if (!hiveToUpdate) {
      return null;
    }

    const [numberOfAffectedRows, affectedRows] = await this._hiveRepository.update(hiveId, updateData);

    if (numberOfAffectedRows === 0) {
      return null;
    }

    return affectedRows[0];
  }

  /**
   * Deletes a hive by its ID and location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to delete.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteHive(locationId: string, hiveId: string): Promise<boolean> {
    console.log('Service (deleteHive) Deleting hive...', locationId, hiveId);

    // if the location is given, the Hive ID must belong to that Location
    const hiveToDelete = await this._hiveRepository.findById(hiveId, locationId);

    if (!hiveToDelete) {
      return false;
    }

    console.log('Service (deleteHive) Found hive to delete:', hiveToDelete);

    const deletedRows = await this.hiveRepository.delete(hiveId, locationId);

    return deletedRows > 0;
  }

  /**
   * Deletes all hives by their location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteAllHives(locationId: string): Promise<boolean> {
    const deletedRows = await this._hiveRepository.deleteAll(locationId);

    return deletedRows > 0;
  }
}


// filepath: services\location-service.ts
import { ILocationRepository } from '../repositories/interfaces/i-location-repository.js';
import { LocationServiceRetrievedDTO, LocationServiceCreateDTO, LocationServiceUpdateDTO } from './dto/location-service.dto.js';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

export class LocationService {
  private readonly locationRepository: ILocationRepository;

  // Dependency Injection: Injecting the repository contract
  constructor(locationRepository: ILocationRepository) {
    this.locationRepository = locationRepository;
  }

  /**
   * Creates a new location entry.
   * @param locationData The data for the new location, including user_id.
   * @returns The created location DTO.
   */
  public async createLocation(locationData: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    // No complex business logic here yet (e.g., uniqueness checks), so delegate directly.
    return this.locationRepository.create(locationData);
  }

  /**
   * Retrieves all locations belonging to a specific user.
   * @param userId The ID of the owner.
   * @returns An array of location DTOs.
   */
  public async getAllLocationsByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    return this.locationRepository.findAllByUserId(userId);
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public async getLocationById(locationId: string): Promise<LocationServiceRetrievedDTO | null> {
    const _loc = await this.locationRepository.findById(locationId);
    return _loc;
  }

  /**
   * Updates an existing location.
   * @param locationId The ID of the location to update.
   * @param updateData The fields to update.
   * @returns The updated location DTO.
   */
  public async updateLocation(locationId: string, updateData: LocationServiceUpdateDTO): Promise<LocationServiceRetrievedDTO> {
    // Check if the location exists before updating
    const existingLocation = await this.locationRepository.findById(locationId);
    if (!existingLocation) {
      const error = new Error('Location not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    const [updatedCount, updatedLocations] = await this.locationRepository.update(locationId, updateData);

    if (updatedCount > 1) {
      // This error indicates a serious issue in the repository or ORM logic
      const error = new Error(`Failed to update location with ID ${locationId}. Concurrency issue suspected.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      // Should not happen after the initial existence check, but is a safety net
      const error = new Error(`Location with ID ${locationId} not found during update.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    // Return the single updated location DTO
    return updatedLocations[0];
  }

  /**
   * Deletes a location.
   * @param locationId The ID of the location to delete.
   * @returns The number of records deleted (should be 1).
   */
  public async deleteLocation(locationId: string): Promise<number> {
    // Optional: Add pre-delete check or business logic here (e.g., cannot delete if hives are present)
    return this.locationRepository.delete(locationId);
  }

  /**
   * Checks if a location is owned by a specific user. Helpful for authorization middleware checks
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns True if the location is owned by the user, false otherwise.
   */
  public async checkLocationOwnership(locationId: string, userId: string): Promise<boolean> {
    const location = await this.locationRepository.findById(locationId);
    return location ? location.user_id === userId : false;
  }
}


// filepath: services\major-inspection-service.ts
// src/services/majorInspectionService.ts
import { IMajorInspectionRepository } from 'repositories/interfaces/i-major-inspection-repository.js';
import { MajorInspectionServiceCreateDTO, MajorInspectionServiceRetrievedDTO, MajorInspectionServiceUpdateDTO } from './dto/major-inspection-service.dto.js';

export class MajorInspectionService {
  // Dependency Injection: Injecting the repository contract
  private _majorInspectionRepository: IMajorInspectionRepository;

  constructor(majorInspectionRepository: IMajorInspectionRepository) {
    /**
     * Initializes the MajorInspectionService with a concrete repository implementation.
     * This implements Dependency Injection (DI).
     * @param majorInspectionRepository The repository instance (e.g., MajorInspectionRepository or MockMajorInspectionRepository).
     */
    this._majorInspectionRepository = majorInspectionRepository;
  }

  public async createMajorInspection(inspectionData: MajorInspectionServiceCreateDTO): Promise<MajorInspectionServiceRetrievedDTO> {
    const newMajorInspection = await this._majorInspectionRepository.create(inspectionData);
    return newMajorInspection;
  }

  public async getMajorInspectionsByLocationId(locationId: string): Promise<MajorInspectionServiceRetrievedDTO[]> {
    const majorInspections = await this._majorInspectionRepository.findAllByLocationId(locationId);
    return majorInspections;
  }

  public async getMajorInspectionById(majorInspectionId: string, locationId: string): Promise<MajorInspectionServiceRetrievedDTO | null> {
    try {
      const majorInspection = await this._majorInspectionRepository.findById(majorInspectionId, locationId);
      return majorInspection;
    } catch (error) {
      console.error('TEST Error fetching major inspection by ID:', error);
      return null;
    }
  }

  public async updateMajorInspection(majorInspectionId: string, updateData: MajorInspectionServiceUpdateDTO): Promise<MajorInspectionServiceRetrievedDTO | null> {
    const [numberOfAffectedRows, affectedRows] = await this._majorInspectionRepository.update(majorInspectionId, updateData.location_id!, updateData);

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0];
  }

  public async deleteMajorInspection(locationId: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await await this._majorInspectionRepository.delete(majorInspectionId, locationId);

    return deletedRows > 0;
  }

  public async foodbar(): Promise<void> {
    console.log('Foodbar method called');
  }

  // public async checkOwnership(majorInspectionId: string, locationId: string, userId: string): Promise<boolean> {
  //   const majorInspection = await this._majorInspectionRepository.findById(majorInspectionId, locationId);
  //   if (!majorInspection) {
  //     return false;
  //   }
  //   return true;
  // }

  /**
   * Checks if a Major Inspection exists at a specific Location owned by a specific User.
   * Delegates the triple-check to the Repository for efficiency.
   */
  public async checkMajorInspectionOwnership(majorInspectionId: string, locationId: string, userId: string): Promise<boolean> {
    // The repository will perform the JOIN/WHERE clause query.
    const inspection = await this._majorInspectionRepository.findInspectionByLocationAndUser(majorInspectionId, locationId, userId);

    return inspection !== null;
  }
}


// filepath: services\user-service.ts
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user creation attributes
import { IUserRepository } from '../repositories/interfaces/i-user-repository.js'; // The contract
import { UserRetrievedDTO, UserCreationDTO, UserUpdateDTO } from './dto/user-service.dto.js'; // The data shapes
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

// This class handles business logic (e.g., uniqueness check, error handling). No direct access to DB, just through repository.
export class UserService {
  private readonly userRepository: IUserRepository;
  constructor(userRepository: IUserRepository) {
    this.userRepository = userRepository;
  }

  public async findUserByEmail(email: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readByEmail(email);
  }

  public async findUserById(id: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readById(id);
  }

  public async createUser(userData: UserCreationDTO): Promise<UserRetrievedDTO> {
    // Check if user already exists (Business Logic)
    const existingUser = await this.userRepository.readByEmail(userData.email);
    if (existingUser) {
      // Throw a specific error that the Controller/ErrorHandler can catch
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = httpStatus.CONFLICT; // 409
      throw error;
    }

    // Delegate the creation to the repository (Data Access)
    return this.userRepository.create(userData);
  }

  public async updateUser(id: string, userData: Partial<UserUpdateDTO>): Promise<UserRetrievedDTO> {
    // Check if user exists
    const existingUser = await this.userRepository.readById(id);
    if (!existingUser) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Delegate the update to the repository (Data Access)
    const [updatedCount, updatedUsers] = await this.userRepository.update(id, userData);

    if (updatedCount > 1) {
      const error = new Error(`Failed to update user with ID ${id}.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      const error = new Error(`User with ID ${id} not found.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    return updatedUsers[0]; // decide for later if you want to return array or single object
  }
}


// filepath: src-summary3.txt
// filepath: .env
# Environment variables for MyHives App
PORT=3000

NODE_ENV=development
API_BASE_URL=http://localhost:3000/api

# Database Configuration
DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=Cada_2068_new # <--- IMPORTANT: Replace with your actual password!
DB_NAME=myhives_db                     # <--- IMPORTANT: Replace with the database name you created!

DATABASE_URL=postgresql://postgres:Cada_2068_new@localhost:5432/myhives_db
JWT_SECRET=my_jwt_super_dupper_secret_key


# Google OAuth Credentials
GOOGLE_CLIENT_ID="your_google_client_id"
GOOGLE_CLIENT_SECRET="your_google_client_secret"

# LinkedIn OAuth Credentials
LINKEDIN_CLIENT_ID="your_linkedin_client_id"
LINKEDIN_CLIENT_SECRET="your_linkedin_client_secret"

# Frontend URL for CORS and OAuth redirects
FRONTEND_URL="http://localhost:5173" # Or your deployed frontend URL


// filepath: appExpressInstance.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import 'reflect-metadata';
import config from './config/index.js';
import errorHandler, { CustomError } from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
import authRoutes from './routes/authRoutes.js';
import locationRoutes from './routes/locationRoutes.js';
//import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
//  import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
// import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();
const apiRouter = express.Router(); // Create a new router instance

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(
  cors({
    origin: config.frontendUrl, // Allow requests from your frontend URL
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true, // Allow cookies to be sent
  })
);

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// Mount your API router on the main app
app.use('/api/v1', apiRouter);

// --- Routes ---
// Basic health check route
apiRouter.get('/health', (req: Request, res: Response) => {
  console.log('ðŸš‘ Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');

// Mount your API routes here
apiRouter.use('/auth', authRoutes);
apiRouter.use('/locations', locationRoutes);

console.log('API routes mounted');
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 404; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;


// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url);

// Get the current directory's path
const __dirname = path.dirname(__filename);

// Load environment variables from .env file
const dotEnvConfigObject = dotenv.config({ path: path.resolve(__dirname, '../../src/.env') });
console.log('dotenv config object:', dotEnvConfigObject);

// Define the IConfig interface
interface IConfig {
  port: number;
  nodeEnv: string;
  databaseUrl: string;
  jwtSecret: string;
  googleClientId: string;
  googleClientSecret: string;
  linkedinClientId: string;
  linkedinClientSecret: string;
  frontendUrl: string; // For CORS and OAuth redirects
}

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port
};

console.log('Config loaded:', config);
console.log('config.jwtSecret:', config.jwtSecret);

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
  console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
}
if (!config.databaseUrl || config.databaseUrl === 'unknown') {
  console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
}
if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
  console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
}

export default config;


// filepath: controllers\auth-controller.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/user-service.js'; // New service

import config from '../config/index.js';
import httpStatus from 'http-status'; // Good practice for error codes

import { LoginUserOutgoingDTO, UserOutgoingDTO, UpdateUserIncomingDTO } from './dto/auth-controller.dto.js';
import { UserCreationDTO, UserUpdateDTO, UserRetrievedDTO } from '../services/dto/user-service.dto.js';

export class AuthController {
  private readonly _userService: UserService;

  constructor(userService: UserService) {
    this._userService = userService;
  }

  public register = async (req: Request, res: Response, next: NextFunction) => {
    console.log('Registering user:', req.body);
    try {
      const { username, email, password } = req.body;

      // Check if user already exists
      const existingUser: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (existingUser) {
        const error = new Error('User with this email already exists.') as CustomError;
        error.statusCode = httpStatus.CONFLICT; // 409
        throw error;
      }

      // Hash password
      const hashedPassword: string = await bcrypt.hash(password, 10); // Salt rounds = 10

      const userDataLoad: UserCreationDTO = { username, email, password_hash: hashedPassword };

      // Create user
      const newUser: UserRetrievedDTO = await this._userService.createUser(userDataLoad);

      // // Generate token (optional, could just return success message)
      // const token = generateToken({ userId: newUser.user_id! });
      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User registered successfully! Please log in.',
        user: {
          id: newUser.user_id!,
          username: newUser.username,
          email: newUser.email,
        },
      };

      res.status(201).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body;

      const user: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (!user || !user.password_hash) {
        // Check for user existence and if they have a password (for traditional login)
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      // Compare password
      const isMatch: boolean = await bcrypt.compare(password, user.password_hash);
      if (!isMatch) {
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      // Generate token
      const token: string = generateToken({ userId: user.user_id! });

      res.cookie('jwtcookie', token, {
        httpOnly: true,
        secure: config.nodeEnv === 'production',
        maxAge: 1000 * 3600 * 24 * 7, // 7 days in milliseconds
      });

      const responseObj: LoginUserOutgoingDTO = {
        success: true,
        message: 'Logged in successfully!',
        token,
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public logout = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // In a stateless JWT system, the server doesn't need to do much for logout.
      // The client simply discards the token.
      // However, it's good practice to send a success message.

      // If using HTTP-only cookies for tokens, you'd clear the cookie here.
      // For example:
      res.clearCookie('jwtcookie'); // Assuming your JWT is in a cookie named 'jwtcookie'

      // You might also want to do some logging for audit purposes
      console.log(`User ${req.currentUser?.id || 'unknown'} logged out.`);

      res.status(200).json({
        success: true,
        message: 'Logged out successfully.',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('getMe called');
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      console.log('Current user ID:', req.currentUser.id);

      const user: UserRetrievedDTO | null = await this._userService.findUserById(req.currentUser.id);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      // Return user data (excluding password)
      const { password_hash: password, ...userData } = user;
      res.status(200).json({ success: true, user: userData });
    } catch (error) {
      next(error);
    }
  };

  public updateMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      const userId = req.currentUser!.id;
      const updateData: UpdateUserIncomingDTO = req.body;
      console.log('Update data received:', updateData);

      const readyToUpdate: UserUpdateDTO = { ...updateData, password_hash: updateData.password ? await bcrypt.hash(updateData.password, 10) : undefined };

      const user: UserRetrievedDTO = await this._userService.updateUser(userId, readyToUpdate);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User updated successfully!',
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\dto\auth-controller.dto.ts
// incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

export interface RegisterUserIncomingDTO {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}
// outgoing DTO for authentication response

export interface UserOutgoingDTO {
  success: boolean;
  message: string;
  user: {
    id: string;
    username: string;
    email: string;
  };
}
// DTO for user update (all fields optional)

export interface UpdateUserIncomingDTO {
  username?: string;
  email?: string;
  password?: string;
}

export type GetMeUserOutgoingDTO = Omit<UserOutgoingDTO, 'pass'>;

// DTO for user login
export type LoginUserOutgoingDTO = UserOutgoingDTO & {
  token: string;
};

export interface LoginUserIncomingDTO {
  email: string;
  password: string;
}


// filepath: controllers\dto\hive-controller.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// these DTO types are used in the HiveRouter files to define the shape of request body data it expects to receive and send out
export type HiveControllerCreateDTO = Omit<hivesAttributes, 'hive_id' | 'location_id' | 'created_at' | 'updated_at'>;
export type HiveControllerUpdateDTO = Partial<HiveControllerCreateDTO>;
export type HiveControllerCreateStrongDTO = Omit<HiveControllerCreateDTO, 'description'> & Required<Pick<HiveControllerCreateDTO, 'description'>>;

// const some: HiveControllerCreateStrongDTO = {
//   hive_name: 'Test Hive',
//   description: 'A test hive description',
//   is_active: true,
// };


// filepath: controllers\dto\location-controller.dto.ts
// DTOs for the Controller Layer (API input/output)

// Incoming DTO for creating a new location (user_id is implicit from the authenticated user)
export interface LocationControllerCreateInputDTO {
  name: string;
  address?: string;
  country?: string;
  latitude?: number;
  longitude?: number;
  notes?: string;
}

// Incoming DTO for updating an existing location (all fields optional)
export type LocationControllerUpdateInputDTO = Partial<LocationControllerCreateInputDTO>;

// Outgoing DTO for a single location response
export interface LocationControllerOutputDTO {
  success: boolean;
  message: string;
  location: {
    id: string;
    userId: string;
    name: string;
    address?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
    description?: string;
    createdAt: string;
    updatedAt: string;
  };
}

// Outgoing DTO for a list of locations
export interface LocationControllerListOutputDTO {
  success: boolean;
  message: string;
  locations: Array<LocationControllerOutputDTO['location']>;
}


// filepath: controllers\hive-controller.ts
import { Request, Response, NextFunction } from 'express';
import { HiveService } from '../services/hive-service.js';
import { CustomError } from '../middleware/errorHandler.js';
import { HiveServiceCreateDTO, HiveServiceRetrievedDTO, HiveServiceUpdateDTO } from 'services/dto/hive-service.dto.js';

export class HiveController {
  private _hiveService: HiveService;

  constructor(hiveService: HiveService) {
    this._hiveService = hiveService;
  }

  // Get all hives
  public getAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hives...', req.params);

      const location_id = req.params.locationId;

      const hives = await this._hiveService.getHivesByLocationId(location_id);

      res.status(200).json({
        success: true,
        message: 'Hives fetched successfully',
        data: hives,
      });
    } catch (error) {
      //res.status(500).json({ error: 'Failed to fetch hives' });
      next(error);
    }
  };

  // Get hive by ID
  public getHiveById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hive...', req.params);

      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      const hive: HiveServiceRetrievedDTO | null = await this._hiveService.getHiveById(location_id, hive_id);

      if (!hive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({
        success: true,
        message: 'Hive fetched successfully',
        data: hive,
      });
    } catch (error) {
      next(error);
    }
  };

  public createHive = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      console.log('Creating hive...', req.params.locationId, req.body);
      const location_id = req.params.locationId;
      const hiveBodyData = req.body;

      const hiveData: HiveServiceCreateDTO = { ...hiveBodyData, locationId: location_id };

      console.log('Hive data:', hiveData);

      const newHiveCreated = await this._hiveService.createHive(hiveData);

      res.status(201).json(newHiveCreated);
    } catch (error) {
      next(error);
    }
  };

  // Update a hive
  public updateHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;
      const updatedHiveData = req.body;
      const updateHivePayload: HiveServiceUpdateDTO = { ...updatedHiveData, location_id: location_id };

      const updatedHive = await this._hiveService.updateHive(hive_id, updateHivePayload);
      if (!updatedHive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive updated successfully',
        data: updatedHive,
      });
    } catch (error) {
      next(error);
    }
  };

  // Delete a hive
  public deleteHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      console.log('Controller : Deleting hive...', req.params);

      const deleted = await this._hiveService.deleteHive(location_id, hive_id);
      if (!deleted) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.location_id;

      const deleted = await this._hiveService.deleteAllHives(location_id);
      if (!deleted) {
        const error = new Error('Hives not deleted.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.json({ message: 'Hives deleted successfully', success: true });
    } catch (error) {
      next(error);
    }
  };
} // end of class HiveController

// export default {
//   getAllHives,
//   getHiveById,
//   createHive,
//   updateHive,
//   deleteHive,
//   deleteAllHives,
// };


// filepath: controllers\hive-inspection-controller.ts
// src/controllers/hiveInspectionController.ts

import { Response, NextFunction } from 'express';
import { CustomRequest } from '../types/DTO/per-controller/custom-request.js';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { MajorInspectionService } from '../services/major-inspection-service.js'; // Needed for ownership check
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

//import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import { UniqueConstraintError } from 'sequelize';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    console.log('Controller: Creating hive inspection');
    try {
      const { majorInspectionId } = req.params;
      //const userId = req.currentUser!.id; // Authenticated user ID

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }
      console.log('Controller: Major inspection ownership verified:', majorInspection);

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: hive_inspectionsAttributes = { ...req.body, major_inspection_id: majorInspectionId }; // Ensure majorInspectionId from param is used
      console.log('Hive inspection data to be created:', hiveData);

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(hiveData);
      console.log('Controller: New hive inspection created on database:', newHiveInspection);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      if (error instanceof UniqueConstraintError) {
        // <-- Check for the specific error
        // A specific hive should only be inspected once per major inspection event
        const _err = new Error('A hive inspection for this hive already exists in this major inspection.') as CustomError;
        _err.statusCode = httpStatus.CONFLICT; // Return 409 Conflict
        next(_err);
      } else {
        next(error);
      }
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const updateData: hive_inspectionsAttributes = req.body; // Joi validation should ensure valid partial data

      console.log('------------------ Controller: Updating hive inspection with data:', updateData);

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      console.log('------------------ Controller: Updated hive inspection:', updatedHiveInspection);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed
      console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspection);
      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('hicMajor inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\location-controller.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/location-service.js'; // Import the service
import { LocationControllerOutputDTO, LocationControllerListOutputDTO, LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from './dto/location-controller.dto.js';
import { LocationServiceCreateDTO, LocationServiceRetrievedDTO, LocationServiceUpdateDTO } from '../services/dto/location-service.dto.js';
import { LocationServiceToControllerMapper } from '../utils/converters/location/service-to-controller.mapper.js';
import { LocationControllerToServiceMapper } from '../utils/converters/location/controller-to-service.mapper.js';
import httpStatus from 'http-status';

export class LocationController {
  private readonly _locationService: LocationService;

  constructor(locationService: LocationService) {
    this._locationService = locationService;
  }

  public createLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const incomingData: LocationControllerCreateInputDTO = req.body; // from controller dto interface definition

      const serviceDataParam: LocationServiceCreateDTO = LocationControllerToServiceMapper.toServiceCreateDTO(incomingData, userId);

      const location: LocationServiceRetrievedDTO = await this._locationService.createLocation(serviceDataParam);

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(location, 'Location created successfully!', true);

      return res.status(httpStatus.CREATED).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getAllLocations = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      // we serve the GET method .... for "/" all locations for that user
      const locations: LocationServiceRetrievedDTO[] = await this._locationService.getAllLocationsByUserId(req.currentUser.id);

      const responseData: LocationControllerListOutputDTO = LocationServiceToControllerMapper.toControllerListOutputDTO(locations, 'Locations retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getLocationById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const specificLocation: LocationServiceRetrievedDTO | null = await this._locationService.getLocationById(locationId);

      if (!specificLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(specificLocation, 'Location retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public updateLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const updateDataRaw: LocationControllerUpdateInputDTO = req.body;

      const updateDataForService: LocationServiceUpdateDTO = LocationControllerToServiceMapper.toServiceUpdateDTO(updateDataRaw, userId);

      const updatedLocation: LocationServiceRetrievedDTO = await this._locationService.updateLocation(locationId, updateDataForService);

      if (!updatedLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location updated successfully',
        data: updatedLocation,
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      const { locationId } = req.params;
      const deleted: number = await this._locationService.deleteLocation(locationId);

      if (deleted === 0) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMapData = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // This endpoint retrieves data for the map view.
      // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
      // If it's only for logged-in users, keep authenticate middleware.
      // For showing "all registered beehive locations within a country" with owner email/username,
      // it might require a join query to get hive counts and owner info across all users.
      // For simplicity, let's just return a placeholder or mock data for now.
      // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
      // to aggregate hive counts per location.
      const mockMapData = [
        {
          id: 'loc1',
          latitude: 46.0569, // Ljubljana, Slovenia
          longitude: 14.5058,
          hiveCount: 12,
          ownerUsername: 'SlovenianBeekeeper',
        },
        {
          id: 'loc2',
          latitude: 46.5547, // Maribor, Slovenia
          longitude: 15.6459,
          hiveCount: 8,
          ownerUsername: 'ApiaryExplorer',
        },
      ];

      res.status(200).json({
        success: true,
        data: mockMapData,
      });
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\major-inspection-contoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/major-inspection-service.js';
import { LocationService } from '../services/location-service.js'; // To check location ownership
// import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
// import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';
import { major_inspectionsAttributes } from 'database/models-ts/major-inspections.js';

// // Middleware to ensure location belongs to the authenticated user
// const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Checking location ownership...', req.params, req.body, req.currentUser);
//     const userId = req.currentUser!.id;
//     const { locationId } = req.params;

//     const location = await LocationService.getLocationById(locationId, userId);
//     if (!location) {
//       const error = new Error('Location not found or unauthorized.') as CustomError;
//       error.statusCode = 403; // Forbidden
//       throw error;
//     }
//     next(); // Location is owned by the user, proceed
//   } catch (error) {
//     next(error);
//   }
// };

export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Creating major inspection...ABCD', req.params, req.body);
    const { locationId } = req.params;
    //const inspectionData: Partial<MajorInspectionInterface> = req.body;
    const inspectionData: major_inspectionsAttributes = req.body;

    const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

    res.status(201).json({
      success: true,
      message: 'Major inspection created successfully',
      data: newMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Fetching major inspections...');
    const { locationId } = req.params;

    const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

    res.status(200).json({
      success: true,
      data: majorInspections,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: majorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const updateData: major_inspectionsAttributes = req.body;
    console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);

    const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(locationId, majorInspectionId, updateData);

    if (!updatedMajorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection updated successfully',
      data: updatedMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const deleted = await MajorInspectionService.deleteMajorInspection(userId, locationId, majorInspectionId);

    if (!deleted) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

//export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
â”œâ”€â”€ app.ts // Express app setup, middleware, routes
â”œâ”€â”€ server.ts // Entry point, starts the server
â”œâ”€â”€ config/ // Environment variables, database config
â”‚ â””â”€â”€ index.ts
â”œâ”€â”€ database/ // ORM setup (Sequelize/TypeORM), models, migrations
â”‚ â”œâ”€â”€ index.ts
â”‚ â”œâ”€â”€ models/
â”‚ â”‚ â”œâ”€â”€ User.ts
â”‚ â”‚ â”œâ”€â”€ Location.ts
â”‚ â”‚ â”œâ”€â”€ MajorInspection.ts
â”‚ â”‚ â””â”€â”€ HiveInspection.ts
â”‚ â””â”€â”€ migrations/
â”œâ”€â”€ middleware/ // Custom middleware (auth, validation, error handling)
â”‚ â”œâ”€â”€ auth.ts // JWT verification, authorization checks
â”‚ â”œâ”€â”€ validation.ts // Joi/Zod for input validation
â”‚ â””â”€â”€ errorHandler.ts // Centralized error handling
â”œâ”€â”€ controllers/ // Business logic for each resource
â”‚ â”œâ”€â”€ authController.ts
â”‚ â”œâ”€â”€ locationController.ts
â”‚ â”œâ”€â”€ majorInspectionController.ts
â”‚ â””â”€â”€ hiveInspectionController.ts
â”œâ”€â”€ routes/ // API routes for each resource
â”‚ â”œâ”€â”€ authRoutes.ts
â”‚ â”œâ”€â”€ locationRoutes.ts
â”‚ â”œâ”€â”€ majorInspectionRoutes.ts
â”‚ â””â”€â”€ hiveInspectionRoutes.ts
â”œâ”€â”€ services/ // Database interaction logic (optional, for separation of concerns)
â”‚ â”œâ”€â”€ locationService.ts
â”‚ â””â”€â”€ ...
â”œâ”€â”€ types/ // TypeScript interfaces/types
â”‚ â”œâ”€â”€ express.d.ts // Extend Request for user property
â”‚ â”œâ”€â”€ models.ts
â”‚ â””â”€â”€ auth.ts
â””â”€â”€ utils/ // Utility functions (e.g., password hashing)
â””â”€â”€ jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts
import { Sequelize } from 'sequelize-typescript';
import config from '../config/index.js';
import { users } from './models-ts/users.js'; // To be created
import { locations } from './models-ts/locations.js'; // To be created
import { hive_inspections } from './models-ts/hive_inspections.js';
import { major_inspections } from './models-ts/major-inspections.js';
import { hives } from './models-ts/hives.js'; // To be created
import { associateModels } from './models-ts/associations.js'; // Adjust path if you placed it elsewhere, e.g., './models-obsolete/associations.js'

console.log('Connecting to PostgreSQL database... ', process.env.DATABASE_URL);

const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;
console.log('Database connection string:', databaseUrl);

// Initialize Sequelize with your database connection string<br>
const sequelize = new Sequelize({
  database: DB_NAME,
  username: DB_USER,
  password: DB_PASSWORD,
  host: DB_HOST,
  port: DB_PORT,
  dialect: DB_DIALECT,
  logging: false, // Enable logging to see SQL queries
  models: [users, locations, hive_inspections, major_inspections, hives], // Add all models here
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  },
  // Required for proper PostgreSQL UUID handling
  dialectOptions: {
    useUTC: false,
  },
  timezone: '+00:00', // Set timezone to UTC for consistency
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Set up associations between models
    associateModels();
    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
      console.log('Syncing database models (development mode)...');
      //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
      await sequelize.sync({ alter: false });
      console.log('Database models synchronized.');
    } else {
      // In production, rely on migrations. If you haven't run migrations,
      // you might still want a simple sync without alter.
      // Or remove this line entirely if you strictly use migrations.
      // await sequelize.sync();
      console.log('In production, use database migrations to manage schema changes.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};

export { sequelize as sequelizeInstance };
//export const db = sequelize;


// filepath: database\models-ts\associations.ts
import { users } from './users.js';
import { locations } from './locations.js';
import { major_inspections } from './major-inspections.js';
import { hives } from './hives.js';
import { hive_inspections } from './hive_inspections.js';

export function associateModels() {
  // User to Location (one-to-many)
  users.hasMany(locations, {
    foreignKey: 'user_id',
    as: 'locations',
  });
  locations.belongsTo(users, {
    foreignKey: 'user_id',
    as: 'user',
  });

  // Location to MajorInspection (one-to-many)
  locations.hasMany(major_inspections, {
    foreignKey: 'location_id',
    as: 'locations_majorInspections',
  });
  major_inspections.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'majorInspection_location',
  });

  // Location to Hives (one-to-many)
  locations.hasMany(hives, {
    foreignKey: 'location_id',
    as: 'locations_hives',
  });
  hives.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'hives_location',
  });

  // MajorInspection to HiveInspection (one-to-many)
  major_inspections.hasMany(hive_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'majors_hiveInspections',
  });
  hive_inspections.belongsTo(major_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'hiveInspections_majorInspection',
  });

  // Hive to HiveInspection (one-to-many)
  hives.hasMany(hive_inspections, {
    foreignKey: 'hive_id',
    as: 'hives_hiveInspections',
  });

  hive_inspections.belongsTo(hives, {
    foreignKey: 'hive_id',
    as: 'hiveInspections_hive',
  });
}


// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface hivesAttributes {
  hive_id?: string;
  location_id: string;
  hive_name: string;
  description?: string;
  is_active?: boolean;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hives',
  schema: 'public',
  timestamps: false,
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING(255),
  })
  hive_name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  description?: string;

  @Column({
    allowNull: true,
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('true'),
  })
  is_active?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  //   // --- Associations for Hive Inspections ---
  //   @HasMany(() => hive_inspections, {
  //     foreignKey: 'hive_id', // The foreign key in the 'hive_inspections' table that links back to 'hives'
  //     as: 'hiveInspections', // Alias for when you include hive inspections with a hive
  //   })
  //   hiveInspections?: hive_inspections[]; // Property to hold an array of associated hive inspections
}


// filepath: database\models-ts\hive_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

import { hives } from './hives.js'; // Import hives model
import { major_inspections } from './major-inspections.js'; // Import major_inspections model

export interface hive_inspectionsAttributes {
  hive_inspection_id?: string;
  major_inspection_id: string;
  hive_id: string;
  inspection_time: string;
  colony_health_status_id: number;
  num_chambers: number;
  brood_frames_count?: number;
  brood_percentage?: number; // no longer string
  queen_status_id: number;
  approx_honey_weight_kg?: number;
  drone_comb_frames_count?: number;
  drone_comb_percentage?: number; // no longer string
  sugar_feed_added?: boolean;
  sugar_feed_quantity_kg?: number;
  brood_chambers_count: number;
  supers_count: number;
  queen_excluder_present?: boolean;
  num_varroa_mites_found?: number;
  varroa_treatment_id?: number;
  varroa_treatment_dosage?: string;
  raising_new_queen?: boolean;
  queen_cell_age_days?: number;
  queen_cell_status_id?: number;
  other_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hive_inspections',
  schema: 'public',
  timestamps: false,
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_inspection_id?: string;

  @ForeignKey(() => major_inspections) // Indicates that major_inspection_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  major_inspection_id!: string;

  @ForeignKey(() => hives) // Indicates that hive_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  hive_id!: string;

  //   @BelongsTo(() => hives, {
  //     foreignKey: 'hive_id',
  //     as: 'hive', // Alias for when you include the hive with a hive inspection
  //   })
  //   hive?: hives; // Property to hold the associated hive

  @Column({
    type: DataType.STRING,
  })
  inspection_time!: string;

  @Column({
    type: DataType.INTEGER,
  })
  colony_health_status_id!: number;

  @Column({
    type: DataType.INTEGER,
  })
  num_chambers!: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_percentage?: number;

  @Column({
    type: DataType.INTEGER,
  })
  queen_status_id!: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  approx_honey_weight_kg?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  drone_comb_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(3, 0),
  })
  drone_comb_percentage?: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  sugar_feed_added?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  sugar_feed_quantity_kg?: number;

  @Column({
    type: DataType.INTEGER,
  })
  brood_chambers_count!: number;

  @Column({
    type: DataType.INTEGER,
  })
  supers_count!: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  queen_excluder_present?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  num_varroa_mites_found?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  varroa_treatment_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  varroa_treatment_dosage?: string;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  raising_new_queen?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_age_days?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_status_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  other_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // @BelongsTo(() => major_inspections, {
  //   foreignKey: 'major_inspection_id',
  //   as: 'majorInspection', // This alias is consistent with what you used in HiveInspectionService
  // })
  // majorInspection?: major_inspections; // Property to hold the associated major inspection
}


// filepath: database\models-ts\index.ts
export * from './hives.js';
export * from './users.js';
export * from './locations.js';
export * from './major-inspections.js';
export * from './hive_inspections.js';
export * from './colony_health_statuses.js';
export * from './queen-statuses.js';
export * from './varroa_treatments.js';
export * from './queen-cell-statuses.js';


// filepath: database\models-ts\locations.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { users } from './users.js';
// import { hives } from './hives.js'; // Import hives model
// import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface locationsAttributes {
  location_id?: string;
  user_id: string;
  name: string;
  address?: string;
  latitude?: string;
  longitude?: string;
  country?: string;
  notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'locations',
  schema: 'public',
  timestamps: false,
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  location_id?: string;

  @ForeignKey(() => users)
  @Column({
    type: DataType.UUID,
  })
  user_id!: string;

  @Column({
    type: DataType.STRING(255),
  })
  name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(500),
  })
  address?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  latitude?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  longitude?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(100),
  })
  country?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // Association with users model
  //   @BelongsTo(() => users)
  //   user?: users; // This property would hold the associated user object

  // --- Associations for Hives ---
  //   @HasMany(() => hives, {
  //     foreignKey: 'location_id', // The foreign key in the 'hives' table that links back to 'locations'
  //     as: 'hives', // Alias for when you include hives with a location
  //   })
  //   hives?: hives[]; // Property to hold an array of associated hives

  // --- Associations for Major Inspections ---
  //   @HasMany(() => major_inspections, {
  //     foreignKey: 'location_id', // The foreign key in the 'major_inspections' table that links back to 'locations'
  //     as: 'majorInspections', // Alias for when you include major inspections with a location
  //   })
  //   majorInspections?: major_inspections[]; // Property to hold an array of associated major inspections
}


// filepath: database\models-ts\major-inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';

import { locations } from './locations.js'; // Import locations model
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface major_inspectionsAttributes {
  major_inspection_id?: string;
  location_id: string;
  inspection_date: string;
  general_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'major_inspections',
  schema: 'public',
  timestamps: false,
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  major_inspection_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  // @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  // location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING,
  })
  inspection_date!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  general_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
  // --- Associations for Hive Inspections ---
  @HasMany(() => hive_inspections, {
    foreignKey: 'major_inspection_id', // The foreign key in the 'hive_inspections' table that links back to 'major_inspections'
    as: 'hiveInspections', // Alias for when you include hive inspections with a major inspection
  })
  hiveInspections?: hive_inspections;
  */
}


// filepath: database\models-ts\queen-cell-statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen-statuses.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

export interface queen_statusesAttributes {
  status_id?: number;
  status_name: string;
}

@Table({
  tableName: 'queen_statuses',
  schema: 'public',
  timestamps: false,
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {
  @Column({
    primaryKey: true,
    autoIncrement: true,
    type: DataType.INTEGER,
    defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)"),
  })
  status_id?: number;

  @Column({
    type: DataType.STRING(50),
  })
  status_name!: string;
}


// filepath: database\models-ts\users.ts
import { Model, Table, Column, DataType, Index, Sequelize, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';

export interface usersAttributes {
  user_id?: string;
  username: string;
  password_hash?: string;
  email: string;
  google_id?: string;
  linkedin_id?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'users',
  schema: 'public',
  timestamps: false,
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  user_id?: string;

  @Column({
    type: DataType.STRING(255),
  })
  username!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  password_hash?: string;

  @Column({
    type: DataType.STRING(255),
  })
  email!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  google_id?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  linkedin_id?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
	// Association with locations model
	@HasMany(() => locations, { foreignKey: 'user_id' })
    locations?: locations[]; // This property would hold an array of associated locations
	*/
}


// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: database\myhives_db_script.sql
-- Enable the pgcrypto extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Table for Users
-- Stores user authentication details, supporting traditional, Google, and LinkedIn logins.
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- Storing hashed password for traditional login
    email VARCHAR(255) UNIQUE NOT NULL,
    google_id VARCHAR(255) UNIQUE, -- Google OAuth ID
    linkedin_id VARCHAR(255) UNIQUE, -- LinkedIn OAuth ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index on commonly searched authentication fields
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_google_id ON users(google_id);
CREATE INDEX idx_users_linkedin_id ON users(linkedin_id);


-- Table for Beehive Locations/Stands
-- Stores information about where beekeepers manage their hives.
CREATE TABLE locations (
    location_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE, -- Link to the owner
    name VARCHAR(255) NOT NULL, -- Name of the location (e.g., "Backyard Apiary", "Field A")
    address VARCHAR(500), -- Optional: physical address
    latitude NUMERIC(9,6), -- Latitude for map display
    longitude NUMERIC(9,6), -- Longitude for map display
    country VARCHAR(100), -- Country for potential regional filtering/map views
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_LocationName_User UNIQUE (user_id, name) -- Location names must be unique per user
);

-- Indexes for location data
CREATE INDEX idx_locations_user_id ON locations(user_id);
CREATE INDEX idx_locations_lat_lon ON locations(latitude, longitude);


-- Table for Individual Beehives
-- Represents a specific beehive within a location, allowing tracking of its history.
CREATE TABLE hives (
    hive_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE, -- Link to its physical location
    hive_name VARCHAR(255) NOT NULL, -- Unique name/identifier for the hive within its location (e.g., "Hive 1", "Blue Box")
    description TEXT, -- General description of the hive
    is_active BOOLEAN DEFAULT TRUE, -- Flag if the hive is currently active at this location
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_HiveName_Location UNIQUE (location_id, hive_name) -- Hive names must be unique within a location
);

-- Index for hive data
CREATE INDEX idx_hives_location_id ON hives(location_id);


-- Lookup Table: Colony Health Statuses
-- Predefined options for colony health (e.g., thriving, weak, failing)
CREATE TABLE colony_health_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO colony_health_statuses (status_name) VALUES
('Thriving'),
('Weak'),
('Failing'),
('Unknown');


-- Lookup Table: Queen Statuses
-- Predefined options for queen status (e.g., seen, not seen, laying well)
CREATE TABLE queen_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_statuses (status_name) VALUES
('Seen'),
('Not Seen'),
('Laying Well'),
('Queen Cells Present'),
('Superseded'),
('Absent'),
('Virgin'),
('Unknown');


-- Lookup Table: Varroa Treatments
-- Predefined options for varroa treatments (e.g., Formic acid, Oxalic acid, None)
CREATE TABLE varroa_treatments (
    treatment_id SERIAL PRIMARY KEY,
    treatment_name VARCHAR(100) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO varroa_treatments (treatment_name) VALUES
('Formic Acid'),
('Oxalic Acid'),
('Apivar'),
('Api Life Var'),
('Mite Away Quick Strips'),
('None'),
('Other');


-- Lookup Table: Queen Cell Statuses
-- Predefined options for queen cell status (e.g., open, closed)
CREATE TABLE queen_cell_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_cell_statuses (status_name) VALUES
('Open'),
('Closed'),
('Hatched'),
('Destroyed'),
('Emerging'),
('Unknown');


-- Table for Major Inspections
-- Represents a single visit to a location where one or more hives were inspected.
CREATE TABLE major_inspections (
    major_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE,
    inspection_date DATE NOT NULL,
    general_notes TEXT, -- General notes for the entire location visit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_MajorInspection_LocationDate UNIQUE (location_id, inspection_date)
);

-- Index for major inspections
CREATE INDEX idx_major_inspections_location_date ON major_inspections(location_id, inspection_date);


-- Table for Individual Hive Inspections
-- Detailed records for each specific hive inspection within a major inspection.
CREATE TABLE hive_inspections (
    hive_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    major_inspection_id UUID NOT NULL REFERENCES major_inspections(major_inspection_id) ON DELETE CASCADE,
    hive_id UUID NOT NULL REFERENCES hives(hive_id) ON DELETE CASCADE,
    inspection_time TIME WITHOUT TIME ZONE NOT NULL, -- Hour of inspection specific to this hive
    
    -- Colony Health
    colony_health_status_id INTEGER NOT NULL REFERENCES colony_health_statuses(status_id),
    num_chambers INTEGER NOT NULL, -- Number of hive boxes/chambers
    
    -- Brood details (allowing for either count or percentage, or both)
    brood_frames_count INTEGER, -- Number of frames with brood
    brood_percentage NUMERIC(5,2), -- Percentage of brood (e.g., 75.00 for 75%)
    
    -- Queen Status
    queen_status_id INTEGER NOT NULL REFERENCES queen_statuses(status_id),
    
    -- Honey and Drone Comb
    approx_honey_weight_kg NUMERIC(8,2), -- Approximate amount of honey in kg
    drone_comb_frames_count INTEGER, -- Number of frames with drone comb
    drone_comb_percentage NUMERIC(5,2), -- Percentage of drone comb
    
    -- Feeding and Configuration
    sugar_feed_added BOOLEAN NOT NULL DEFAULT FALSE,
    sugar_feed_quantity_kg NUMERIC(8,2), -- Quantity of sugar feed added in kg
    brood_chambers_count INTEGER NOT NULL,
    supers_count INTEGER NOT NULL,
    queen_excluder_present BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Varroa Mites
    num_varroa_mites_found INTEGER,
    varroa_treatment_id INTEGER REFERENCES varroa_treatments(treatment_id),
    varroa_treatment_dosage VARCHAR(255), -- Dosage/amount (e.g., "5ml", "2 strips")
    
    -- Queen Rearing
    raising_new_queen BOOLEAN NOT NULL DEFAULT FALSE,
    queen_cell_age_days INTEGER, -- Age in days, if known
    queen_cell_status_id INTEGER REFERENCES queen_cell_statuses(status_id),
    
    other_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- A specific hive should only be inspected once per major inspection event
    CONSTRAINT UQ_HiveInspection_MajorHive UNIQUE (major_inspection_id, hive_id)
);

-- Indexes for hive inspections
CREATE INDEX idx_hive_inspections_major_id ON hive_inspections(major_inspection_id);
CREATE INDEX idx_hive_inspections_hive_id ON hive_inspections(hive_id);


-- Function to update the `updated_at` column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to automatically update `updated_at` on row modification
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_locations_updated_at
BEFORE UPDATE ON locations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hives_updated_at
BEFORE UPDATE ON hives
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_major_inspections_updated_at
BEFORE UPDATE ON major_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hive_inspections_updated_at
BEFORE UPDATE ON hive_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Authentication middleware called');
    const authHeader = req.headers.authorization;
    console.log('Token received:', req.headers.authorization);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);
    console.log('Decoded token:', decoded);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.currentUser = { id: decoded.userId }; // Ensure 'user_id' is set for compatibility};

    next();
  } catch (error: any) {
    console.error('Authentication error:', error);
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    console.error(`Error status code: ${err.statusCode}, message: ${err.message}`);
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };


// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error Handler  occurred:', {
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
  });
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;


// filepath: middleware\ownership.ts
import { Request, Response, NextFunction } from 'express';
import { LocationService } from '../services/location-service.js'; // To check location ownership
import { MajorInspectionService } from '../services/major-inspection-service.js';
import httpStatus from 'http-status';
import { CustomError } from '../middleware/errorHandler.js';
import { ParamsDictionary } from 'express-serve-static-core';

interface LocationParams extends ParamsDictionary {
  locationId: string;
}

// Middleware to ensure location belongs to the authenticated user
// Goal is to check if the :majorInspectionId in the URL param belongs to the authenticated user
// This assumes MajorInspectionService has a method to verify ownership without requiring locationId in URL
const checkMajorInspectionOwnershipForHive = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Checking major inspection ownership for hive inspections...', req.params, req.body, req.currentUser);
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    // IMPORTANT: You need to implement this method in your MajorInspectionService.
    // It should fetch the major inspection and ensure its associated location's userId matches the current user.
    //const majorInspectionOwned = await MajorInspectionService.getMajorInspectionByIdAndVerifyUser(
    // console.log(
    //   '\t\t @Ownership/checkMajorInspectionOwnershipForHive Checking major inspection ownership for hive inspections...',
    //   '\nmajorInspectionId:',
    //   majorInspectionId,
    //   '\nlocationId:',
    //   locationId,
    //   '\nuserId:',
    //   userId
    // );

    const majorInspectionOwned = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspectionOwned) {
      const error: CustomError = new Error('oMajor Inspection not found or not owned by user') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Store the fetched object on res.locals for subsequent handlers
    res.locals.majorInspectionOwned = majorInspectionOwned;
    //console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspectionOwned);

    next();
  } catch (error) {
    console.error('%%% Error checking major inspection ownership for hive:', error);
    next(error);
  }
};

/**
 * Middleware factory that accepts an instance of LocationService via Dependency Injection.
 * It returns the actual Express middleware function which checks if the authenticated user
 * owns the resource specified by :locationId.
 *
 * @param locationService An instance of the LocationService used to perform the check.
 * @returns The Express middleware function to be used in routes.
 */
const checkLocationOwnership = (locationService: LocationService) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const locationId = req.params.locationId as string;
      // req.currentUser is set by a preceding authentication middleware (like isAuthenticated)
      const userId = req.currentUser?.id;

      if (!userId) {
        // This should be caught by isAuthenticated, but is a necessary safety check
        const error = new Error('Authentication required for ownership check.') as CustomError;
        error.statusCode = httpStatus.UNAUTHORIZED; // 401
        throw error;
      }

      // Call the non-static instance method on the injected service
      const isOwner = await locationService.checkLocationOwnership(locationId, userId);

      if (!isOwner) {
        const error = new Error('Forbidden. You do not own this location.') as CustomError;
        error.statusCode = httpStatus.FORBIDDEN; // 403
        throw error;
      }

      // Ownership confirmed, proceed
      next();
    } catch (error) {
      next(error);
    }
  };
};

export { checkLocationOwnership, checkMajorInspectionOwnershipForHive };


// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { CustomError } from './errorHandler.js';
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/foobar.js';

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  // console.log('Validation middleware initialized with schemas:', schemas);
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: repositories\implementations\hive-repository.ts
import { Sequelize } from 'sequelize';
import { IHiveRepository } from '../interfaces/i-hive-repository.js';
import { hives } from '../../database/models-ts/hives.js'; //'../ database/models-ts/hives.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Concrete Hive repository.
 *
 * Note: This file provides a pragmatic implementation using Prisma.
 * The exported instance is asserted to IHiveRepository to match your interface
 * even if the exact method signatures differ from this example.
 */
export class HiveRepository implements IHiveRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    const newHive = await hives.create(hiveData);
    return newHive as HiveServiceRetrievedDTO;
  }

  async update(id: string, hiveData: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]> {
    return this.db.transaction(async (t) => {
      const [updatedCount, [updatedHive]] = await hives.update(hiveData, {
        where: { hive_id: id },
        returning: true,
      });
      return [updatedCount, updatedCount > 0 ? [updatedHive as HiveServiceRetrievedDTO] : []];
    });
  }

  async findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null> {
    if (locationId) {
      const hiveWithLocation = await hives.findOne({
        where: {
          hive_id: hiveId,
          location_id: locationId,
        },
      });
      return hiveWithLocation ? (hiveWithLocation as HiveServiceRetrievedDTO) : null;
    } else {
      const hive = await hives.findByPk(hiveId);
      return hive ? (hive as HiveServiceRetrievedDTO) : null;
    }
  }

  async findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const allHives = await hives.findAll({ where: { location_id: locationId } });
    return allHives as HiveServiceRetrievedDTO[];
  }

  async delete(id: string, locationId?: string): Promise<number> {
    const whereCondition = locationId ? { hive_id: id, location_id: locationId } : { hive_id: id };

    const deletedCount: number = await hives.destroy({ where: whereCondition });
    return deletedCount;
  }

  async deleteAll(locationId: string): Promise<number> {
    const deletedCount: number = await hives.destroy({ where: { location_id: locationId } });
    return deletedCount;
  }
}


// filepath: repositories\implementations\location-repository.ts
import { Sequelize } from 'sequelize';
import { ILocationRepository } from '../interfaces/i-location-repository.js';
import { locations } from '../../database/models-ts/locations.js'; // Assuming model is imported like this
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

export class LocationRepository implements ILocationRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    const newLocation = await locations.create(location);
    return newLocation.toJSON() as LocationServiceRetrievedDTO;
  }

  async findById(id: string): Promise<LocationServiceRetrievedDTO | null> {
    const location = await locations.findByPk(id);
    return location ? (location.toJSON() as LocationServiceRetrievedDTO) : null;
  }

  async findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    const allLocations = await locations.findAll({ where: { user_id: userId } });
    return allLocations.map((location) => location.toJSON() as LocationServiceRetrievedDTO);
  }

  async update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedLocations] = await locations.update(location, {
        where: { location_id: id },
        returning: true,
        transaction: t, // Pass the transaction object
      });

      if (updatedCount > 1) {
        // Safety mechanism: If more than one row was somehow affected, trigger rollback.
        throw new Error('Concurrency failure: More than one location record updated.');
      }

      // If successful, commit automatically.
      return [updatedCount, updatedLocations.map((loc) => loc.toJSON() as LocationServiceRetrievedDTO)];
    });
  }

  async delete(id: string): Promise<number> {
    return locations.destroy({ where: { location_id: id } });
  }
}


// filepath: repositories\implementations\major-inspection-repository.ts
import { Sequelize } from 'sequelize';
import { IMajorInspectionRepository } from '../interfaces/i-major-inspection-repository.js';
import { major_inspections } from '../../database/models-ts/major-inspections.js';
import { MajorInspectionServiceCreateDTO, MajorInspectionServiceRetrievedDTO, MajorInspectionServiceUpdateDTO } from '../../services/dto/major-inspection-service.dto.js';

export class MajorInspectionRepository implements IMajorInspectionRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(inspection: MajorInspectionServiceCreateDTO): Promise<MajorInspectionServiceRetrievedDTO> {
    const newInspection = await major_inspections.create(inspection);

    return newInspection.toJSON() as MajorInspectionServiceRetrievedDTO;
  }

  async update(inspectionId: string, locationId: string, inspection: MajorInspectionServiceUpdateDTO): Promise<[number, MajorInspectionServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedInspections] = await major_inspections.update(inspection, {
        where: { major_inspection_id: inspectionId, location_id: locationId },
        returning: true,
        transaction: t, // Pass the transaction object
      });
      return [updatedCount, updatedInspections];
    });
  }

  async findById(inspectionId: string, location_id?: string): Promise<MajorInspectionServiceRetrievedDTO | null> {
    const inspection = await major_inspections.findOne({
      where: location_id ? { major_inspection_id: inspectionId, location_id: location_id } : { major_inspection_id: inspectionId },
    });
    return inspection ? (inspection.toJSON() as MajorInspectionServiceRetrievedDTO) : null;
  }

  async findAllByLocationId(locationId: string): Promise<MajorInspectionServiceRetrievedDTO[]> {
    const allInspections = await major_inspections.findAll({ where: { location_id: locationId } });
    return allInspections.map((insp) => insp.toJSON() as MajorInspectionServiceRetrievedDTO);
  }

  async delete(inspectionId: string, locationId?: string): Promise<number> {
    const deleteCount = await major_inspections.destroy({
      where: locationId ? { major_inspection_id: inspectionId, location_id: locationId } : { major_inspection_id: inspectionId },
    });
    return deleteCount;
  }

  // end of class
}


// filepath: repositories\implementations\user-repository.ts
import { IUserRepository } from '../interfaces/i-user-repository.js';
import { users } from '../../database/models-ts/users.js';
import { sequelizeInstance as database } from '../../database/connect.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export class UserRepository implements IUserRepository {
  private readonly db = database;

  async create(user: UserCreationDTO): Promise<UserRetrievedDTO> {
    const newUser = await users.create(user);
    return newUser.toJSON() as UserRetrievedDTO;
  }

  async readById(id: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findByPk(id);
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readByEmail(email: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findOne({ where: { email } });
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readAll(): Promise<UserRetrievedDTO[]> {
    const allUsers = await users.findAll();
    return allUsers.map((user) => user.toJSON() as UserRetrievedDTO);
  }

  async update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]> {
    const transaction = await this.db.transaction();
    try {
      const [updatedCount, updatedUsers] = await users.update(user, {
        where: { user_id: id },
        returning: true,
        transaction: transaction,
      });

      if (updatedCount > 1) {
        // Rollback if the count is unexpected (the actual fix would be to prevent this query from updating >1 in the first place,
        // but the rollback is the safety net).
        await transaction.rollback();
        throw new Error('Concurrency failure: More than one record updated.');
      }

      // COMMIT if successful
      await transaction.commit();

      return [updatedCount, updatedUsers.map((user) => user.toJSON() as UserRetrievedDTO)];
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  async delete(id: string): Promise<number> {
    const deletedCount = await users.destroy({ where: { user_id: id } });
    return deletedCount;
  }
}


// filepath: repositories\interfaces\i-hive-inspection-repository.ts


// filepath: repositories\interfaces\i-hive-repository.ts
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Interface for the Hive data access layer.
 * Manages CRUD operations for the 'hives' table.
 */
export interface IHiveRepository {
  /**
   * Creates a new hive record.
   * @param hive The data for the new hive, including the location_id.
   * @returns The created hive DTO.
   */
  create(hive: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO>;

  /**
   * Updates an existing hive record.
   * @param id The unique ID of the hive to update.
   * @param hive The partial update data.
   * @returns A tuple: [number of updated rows (should be 1), array of updated hive DTOs].
   */
  update(id: string, hive: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]>;

  /**
   * Retrieves a single hive by its ID.
   * @param hiveId The unique ID of the hive.
   * @param locationId The optional unique ID of the location.
   * @returns The hive DTO or null if not found.
   */
  findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null>;

  /**
   * Retrieves all hives associated with a specific location.
   * @param locationId The ID of the location.
   * @returns An array of hive DTOs.
   */
  findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]>;

  /**
   * Deletes a hive record by its ID.
   * @param hiveId The unique ID of the hive to delete.
   * @param locationId The optional unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  delete(hiveId: string, locationId?: string): Promise<number>;

  /**
   * Deletes a hive record by its ID.
   * @param locationId The unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  deleteAll(locationId: string): Promise<number>;
}


// filepath: repositories\interfaces\i-location-repository.ts
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

/**
 * Interface defining the data access operations for the Location model.
 * All location services will depend on this contract, not a concrete implementation.
 */
export interface ILocationRepository {
  create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO>;

  findById(id: string): Promise<LocationServiceRetrievedDTO | null>;

  findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]>;

  update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]>;

  delete(id: string): Promise<number>;
}


// filepath: repositories\interfaces\i-major-inspection-repository.ts
import { MajorInspectionServiceCreateDTO, MajorInspectionServiceRetrievedDTO, MajorInspectionServiceUpdateDTO } from 'services/dto/major-inspection-service.dto.js';

export interface IMajorInspectionRepository {
  /**
   * Creates a new major inspection record.
   * @param inspection The data for the new major inspection.
   * @returns The created major inspection DTO.
   */
  create(inspection: MajorInspectionServiceCreateDTO): Promise<MajorInspectionServiceRetrievedDTO>;

  update(inspectionId: string, locationId: string, inspection: MajorInspectionServiceUpdateDTO): Promise<[number, MajorInspectionServiceRetrievedDTO[]]>;

  findById(inspectionId: string, hiveId: string): Promise<MajorInspectionServiceRetrievedDTO | null>;

  findAllByLocationId(locationId: string): Promise<MajorInspectionServiceRetrievedDTO[]>;

  delete(inspectionId: string, hiveId?: string): Promise<number>;
}


// filepath: repositories\interfaces\i-user-repository.ts
// import { users } from '../../database/models-ts/users.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export interface IUserRepository {
  create(user: UserCreationDTO): Promise<UserRetrievedDTO>;
  readById(id: string): Promise<UserRetrievedDTO | null>;
  readByEmail(email: string): Promise<UserRetrievedDTO | null>;
  readAll(): Promise<UserRetrievedDTO[]>;
  update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]>;
  delete(id: string): Promise<number>;
}


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router } from 'express';

import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { UserRepository } from '../repositories/implementations/user-repository.js';
import { UserService } from '../services/user-service.js';
//import { RegisterUserDto } from '../types/DTO/per-controller/dtos.js'; // Assuming these DTOs exist
import { RegisterUserIncomingDTO, LoginUserIncomingDTO, UpdateUserIncomingDTO } from '../controllers/dto/auth-controller.dto.js';

import { AuthController } from '../controllers/auth-controller.js';

import { isAuthenticated } from '../middleware/auth.js';

const authRouter = Router();

// --- DI SETUP ---
const userRepository = new UserRepository(); // Concrete implementation
const userService = new UserService(userRepository); // Inject Repository into Service
const authController = new AuthController(userService); // Inject Service into Controller
// --- END DI SETUP ---

const registerSchema = Joi.object<RegisterUserIncomingDTO>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required',
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
});

const loginSchema = Joi.object<LoginUserIncomingDTO>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required',
  }),
});

const updateSchema = Joi.object<UpdateUserIncomingDTO>({
  username: Joi.string().trim().optional(),
  email: Joi.string().email().optional().messages({
    'string.email': 'Email must be a valid email address',
  }),
  password: Joi.string().min(6).optional().messages({
    'string.min': 'Password must be at least 6 characters long',
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',
  validate({ body: registerSchema }), // Apply Joi validation middleware
  authController.register // Call the controller function here
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // Apply Joi validation middleware
  authController.login // Call the controller function here
);

authRouter.get('/me', isAuthenticated, authController.getMe);

authRouter.post(
  '/logout',
  isAuthenticated, // Optional: You might want to ensure only authenticated users can "logout"
  // Or, if you simply want to provide a path to clear client-side token, it can be without auth.
  authController.logout
);

authRouter.put('/me', isAuthenticated, validate({ body: updateSchema }), authController.updateMe);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;


// filepath: routes\hiveInspectionRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { checkMajorInspectionOwnershipForHive as checkMajorInspectionOwnership } from '../middleware/ownership.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
//import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';
import { HiveInspectionController } from '../controllers/hive-inspection-controller.js';

const hiveInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for HiveInspection ---
// const beehiveConfigurationSchema = Joi.object({
//   type: Joi.string().required(),
//   numberOfFrames: Joi.number().integer().min(1).required(),
//   materials: Joi.array().items(Joi.string()).optional(),
//   isInsulated: Joi.boolean().optional(),
// });

const createHiveInspectionSchema = Joi.object({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  // Use the exact snake_case names from your model
  hive_id: Joi.string().uuid().required(),
  inspection_time: Joi.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .required(),
  colony_health_status_id: Joi.number().integer().required(),
  num_chambers: Joi.number().integer().min(1).required(),
  brood_chambers_count: Joi.number().integer().min(1).required(),
  supers_count: Joi.number().integer().min(0).required(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().required(),
  approx_honey_weight_kg: Joi.number().integer().min(0).max(50).optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().min(0).max(10).optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().optional().allow(null),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<hive_inspectionsAttributes>({
  hive_id: Joi.string().trim().optional(),
  inspection_time: Joi.string()
    .pattern(/^([01]\d|2[0-3]):([0-5]\d)$/)
    .optional()
    .messages({
      'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)',
    }),
  colony_health_status_id: Joi.number().integer().optional(),
  num_chambers: Joi.number().integer().min(1).optional(),
  brood_chambers_count: Joi.number().integer().min(1).optional(),
  supers_count: Joi.number().integer().min(0).optional(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().optional(),
  approx_honey_weight_kg: Joi.number().integer().optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const specificHiveInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hiveInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const rootHiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  // Add the locationId to the schema to allow it
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
    body: createHiveInspectionSchema,
  }),
  // (req, res, next) => {
  //   console.log('Validation successful');
  //   next();
  // },
  checkMajorInspectionOwnership, // Verify parent MajorInspection ownership
  HiveInspectionController.createHiveInspection
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
  }),

  checkMajorInspectionOwnership,
  (req, res, next) => {
    console.log('****** GET /  ownership verified *****');
    next();
  },
  HiveInspectionController.getHiveInspectionsByMajorInspectionId
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** GET /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.getHiveInspectionById
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** PUT /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({
    params: specificHiveInspectionParamsSchema,
    body: updateHiveInspectionSchema,
  }),
  checkMajorInspectionOwnership,
  HiveInspectionController.updateHiveInspection
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** DELETE /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.deleteHiveInspection
);

export default hiveInspectionRouter;


// filepath: routes\hiveRoutes.ts
/* define endpoints, joi schemas, and controllers for hive inspections */
import { Router } from 'express';
import Joi from 'joi';

import { HiveController } from '../controllers/hive-controller.js';
import { HiveRepository } from 'repositories/implementations/hive-repository.js';
import { HiveService } from 'services/hive-service.js';
//import { hivesAttributes } from '../database/models-ts/hives.js';
import { isAuthenticated } from '../middleware/auth.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { validate } from '../middleware/validation.js';
import { HiveControllerCreateDTO, HiveControllerCreateStrongDTO, HiveControllerUpdateDTO } from 'controllers/dto/hive-controller.dto.js';

const hiveRouter = Router({ mergeParams: true });
// --- DI SETUP ---
const hiveRepository = new HiveRepository(database); // Concrete implementation
const hiveService = new HiveService(hiveRepository); // Inject Repository into Service
const hiveController = new HiveController(hiveService); // Inject Service into Controller
// --- END DI SETUP ---

const createHivesBodySchema = Joi.object<HiveControllerCreateStrongDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .required(),
  hive_name: Joi.string().min(2).max(50).required(),
  description: Joi.string().min(2).max(200).required(),
  is_active: Joi.boolean().required(),
});

const updateHivesBodySchema = Joi.object<HiveControllerUpdateDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .optional(),
  hive_name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().min(2).max(200).optional(),
  is_active: Joi.boolean().optional(),
});

const createHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const updateHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hive_id: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

//GET /api/v1/locations/:locationId/hives - Get all hives for a specific location.
hiveRouter.get(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching hives...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.getAllHives
);
//POST /api/v1/locations/:locationId/hives - Create a new hive within a specific location.
hiveRouter.post('/', isAuthenticated, validate({ params: createHiveParamSchema, body: createHivesBodySchema }), hiveController.createHive);

//GET /api/v1/locations/:locationId/hives/:hiveId - Get a specific hive.
hiveRouter.get(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.getHiveById
);

//PUT /api/v1/locations/:locationId/hives/:hiveId - Update a specific hive.
hiveRouter.put(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Updating specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema, body: updateHivesBodySchema }),
  hiveController.updateHive
);

//DELETE /api/v1/locations/:locationId/hives/:hiveId - Delete a specific hive.
hiveRouter.delete(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.deleteHive
);
hiveRouter.delete(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting all hives ...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.deleteAllHives
);

export default hiveRouter;


// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { LocationController } from '../controllers/location-controller.js';
import { LocationService } from '../services/location-service.js';
import { LocationRepository } from '../repositories/implementations/location-repository.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { LocationControllerUpdateInputDTO, LocationControllerCreateInputDTO } from '../controllers/dto/location-controller.dto.js';
//import { createLocation, getLocations, getLocationById, updateLocation, deleteLocation, getMapData } from '../controllers/location-controller.js'; // <-- Import the controller functions

//import { locationsAttributes } from '../database/models-ts/locations.js';

import majorInspectionRouter from './majorInspectionRoutes.js';
import hiveRouter from './hiveRoutes.js';
import { checkLocationOwnership } from 'middleware/ownership.js';

const locationRouter = Router();

// --- DI SETUP ---
const locationRepository = new LocationRepository(database); // Concrete implementation
const locationService = new LocationService(locationRepository); // Inject Repository into Service
const locationController = new LocationController(locationService); // Inject Service into Controller
// --- END DI SETUP ---

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<LocationControllerCreateInputDTO>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  notes: Joi.string().trim().max(500).allow(null, ''),
  country: Joi.string().trim().max(100).allow(null, ''),
});

const updateLocationSchema = Joi.object<LocationControllerUpdateInputDTO>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  notes: Joi.string().trim().max(500).allow(null, '').optional(),
  country: Joi.string().trim().max(100).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(), // Validate as UUID
});

// Mount nested major inspection routes
locationRouter.use('/:locationId/major-inspections', isAuthenticated, majorInspectionRouter);
locationRouter.use('/:locationId/hives', isAuthenticated, hiveRouter);

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  locationController.createLocation
);

// GET /api/locations/map - Get map data
locationRouter.get('/map', isAuthenticated, locationController.getMapData);

// GET /api/locations - Get all locations for the authenticated user
locationRouter.get('/', isAuthenticated, locationController.getAllLocations);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  checkLocationOwnership(locationService),
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.getLocationById
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  locationController.updateLocation
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.deleteLocation
);

// // Mount nested major inspection routes
// locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);

export default locationRouter;


// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { NextFunction, Response, Request, Router } from 'express';
import Joi from 'joi';

//import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';

import { createMajorInspection, getMajorInspections, getMajorInspectionById, updateMajorInspection, deleteMajorInspection } from '../controllers/major-inspection-contoller.js';
import { checkLocationOwnership } from '../middleware/ownership.js';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import hiveInspectionRouter from './hiveInspectionRoutes.js';

const majorInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspection_date: Joi.date().iso().required(),
  general_notes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  inspection_date: Joi.date().iso().optional(),
  general_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const loggging = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Logging major inspections requests ...', req.params, req.body);
  next();
};
//majorInspectionRouter.use(loggging);

// Mount nested major inspection routes
// majorInspectionRouter.use('/:majorInspectionId/hive-inspections', (req, res, next) => {
//   next();
// });
majorInspectionRouter.use('/:majorInspectionId/hive-inspections', hiveInspectionRouter);

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/',
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  checkLocationOwnership, // Ensure the location belongs to the user //createMajorInspection
  createMajorInspection
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get('/', checkLocationOwnership, getMajorInspections);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, getMajorInspectionById);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/:majorInspectionId',
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  checkLocationOwnership,
  updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, deleteMajorInspection);

export default majorInspectionRouter;


// filepath: routes\manual-tests\hiveInspections\hiveInspections.http
###
# Hive Inspections API Tests
#
# This file assumes you have already run the `major-inspections.http` tests and have a valid token, hive ID, and major inspection ID.
# The Hive API tests might be useful for getting the hive_id.
#
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@baseUrl = http://localhost:3000/api/v1/locations/{{locationId}}
# @token = <paste_your_token_here>
# @majorInspectionId = <paste_your_major_inspection_id_here>
# @hiveId = <paste_your_hive_id_here> 
# @token =
@majorInspectionId = 3dd79818-4e59-49d7-bb82-a65b0145d87c

@hiveId = ec5ffc71-b700-4837-acdf-4dfa5b1b73e3



### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### get token
@token = {{authenticate.response.body.token}}

###
# Create a new hive inspection for a major inspection.
# @name createHiveInspection
POST {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_id": "bfdd1ef0-0cc1-4886-9ba9-572e60a70ef0",
  "inspection_time": "14:41",
  "colony_health_status_id": 1,
  "num_chambers": 3,
  "brood_chambers_count": 2,
  "supers_count": 1,
  "brood_frames_count": 15,
  "brood_percentage": 79,
  "queen_status_id": 2,
  "approx_honey_weight_kg": 10,
  "drone_comb_frames_count": 2,
  "drone_comb_percentage": 5.0,
  "sugar_feed_added": false,
  "sugar_feed_quantity_kg": null,
  "queen_excluder_present": true,
  "num_varroa_mites_found": 5,
  "varroa_treatment_id": 1,
  "varroa_treatment_dosage": "100ml",
  "raising_new_queen": false,
  "queen_cell_age_days": null,
  "queen_cell_status_id": null,
  "other_notes": "The colony seems strong and healthy. Found a few varroa mites, will continue to monitor."
}

###
# Get all hive inspections for a major inspection.
# @name getHiveInspections
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Authorization: Bearer {{token}}

###
# Get a specific hive inspection.
#
# To run this, first run the `createHiveInspection` request and copy the `hive_inspection_id`.
# @hiveInspectionId = <paste_hive_inspection_id_here>
@hiveInspectionId = {{createHiveInspection.response.body.hive_inspection_id}}
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId`.
PUT {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "brood_percentage": 33,
  "approx_honey_weight_kg": 25,
  "num_chambers": 8,
  "drone_comb_frames_count": 3,  
  "colony_health_status_id": 3,
  "other_notes": "Updated notes: The colony is doing well, but I noticed a few varroa mites."
}

###
# Delete a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\hives\hives.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@hiveId = 01127c49-7230-4405-9ef3-bba06e71a968

// --- Helper Request: Create a Hive (if you need one) ---
// @name createHive
POST {{baseUrl}}/locations/{{locationId}}/hives
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My SIXTH Hive",
  "description": "Newly established hive with a strong queen.",
  "is_active": true
}

###

// --- 1. GET all Hives for a Location ---
// @name getAllHives
GET {{baseUrl}}/locations/{{locationId}}/hives
Authorization: Bearer {{token}}

###

// --- 2. GET a single Hive by ID ---
// @name getHiveById
GET {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

###

// --- 3. Update an existing Hive ---
// @name updateHive
PUT {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My Updated Hive Name",
  "description": "Updated notes after a routine check."
}

###

// --- 4. DELETE a Hive ---
// @name deleteHive
DELETE {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

// filepath: routes\manual-tests\locations\locations.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI


### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

###
# @name createLocation
# Creates a new location.
@token2 = {{authenticate.response.body.token}}
POST {{baseUrl}}/locations
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Apiary 1",
  "address": "123 Main St, Anytown",
  "latitude": 46.0569,
  "longitude": 14.5058,
  "notes": "Main apiary location.",
  "country": "Slovenia"
}

###
# Get all locations for the authenticated user.
# @name getLocations
GET {{baseUrl}}/locations
Authorization: Bearer {{authenticate.response.body.token}}

###
# Get map data for all beehive locations.
# @name getMapData
GET {{baseUrl}}/locations/map
Authorization: Bearer {{token2}}

###
# Get a specific location by ID.
#
# To run this, first run the `createLocation` request and copy the `location_id` from the response.
# @locationId = <paste_location_id_here>
@locationId = {{createLocation.response.body.data.location_id}}
# Use the commented line below if you prefer to set the ID manually
# @locationId =
GET {{baseUrl}}/locations/{{locationId}}
Authorization: Bearer {{token}}

###
# Update a specific location by ID.
#
# To run this, you must first have a valid `locationId` from the `createLocation` request.
PUT {{baseUrl}}/locations/{{locationId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Main Apiary - Updated",
  "notes": "Updated notes for the main apiary."
}

###
# Delete a specific location by ID.
#
# To run this, you must have a valid `locationId` that has not already been deleted.
#DELETE {{baseUrl}}/locations/{{locationId}}
DELETE {{baseUrl}}/locations/2af520b3-c43a-47a8-9372-f1a3e819513b
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\majorInspections\majorInspections.http
###
# Major Inspections API Tests
#
# This file assumes you have already run the `locations.http` tests and have a valid token and location ID.
#
@baseUrl = http://localhost:3000/api/v1
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
# @locationId = <paste_your_location_id_here>

@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8

###
# Create a new major inspection for a specific location.
# @name createMajorInspection
POST {{baseUrl}}/locations/{{locationId}}/major-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "inspection_date": "2024-09-08T10:00:00.000Z",
  "general_notes": "This is temporary test foobar record."
}

###
# Get all major inspections for a specific location.
# @name getMajorInspections
GET {{baseUrl}}/locations/{{locationId}}/major-inspections
Authorization: Bearer {{token}}

###
# Get a specific major inspection by ID.
#
# To run this, first run the `createMajorInspection` request and copy the `major_inspection_id`.
# @majorInspectionId = <paste_major_inspection_id_here>
@majorInspectionId = {{createMajorInspection.response.body.data.major_inspection_id}}
GET {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId`.
PUT {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "general_notes": "Updated notes: Queen seems healthy."
}

###
# Delete a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
#DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/dee8f057-9efb-463b-93da-76ccfad03a54
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\users\user_requests.http
### Check HEALTH Endpoint
# @name checkHealth
GET http://localhost:3000/api/v1/health
Content-Type: application/json    


### Register a New User
###
# @name registerUser
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "TonyClark",
  "email": "tonyclark@gmail.com",
  "password": "password1234"
}

### Register a User with Existing Email (Expected: 409 Conflict)
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "anotheruser",
  "email": "test2@example.com",
  "password": "anotherpassword"
}


### Login with Valid Credentials
# @name loginValidUser
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json
Accept: application/json

{
    "email" : "tonyclark@gmail.com",    
    "password" : "password1234"
}

### Login with Invalid Password (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "tonyclark@gmail.com",
  "password": "password1234"
} 

### Login with Non-Existent Email (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez55@gmail.com",
    "password" : "Cada_73NUN5"
}

### Get Current User (without token - Expected: 401 Unauthorized)
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json

### Get Current User (with valid token)
# Replace {{authToken}} with the token received from a successful login request
@token2 = {{loginValidUser.response.body.token}}
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json
Authorization: Bearer {{token2}}


### Logout User
# This request is mainly for demonstration/logging purposes on the server.
# The real logout happens on the client by deleting the token.
POST http://localhost:3000/api/v1/auth/logout
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later

const startServer = async () => {
  try {
    const testVar: any = 'This should trigger a warning';
    // 1. Connect to the database
    console.log('Attempting to connect to the database...');
    await connectDB();
    console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`âš¡ï¸[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\nðŸ™ˆ-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('âŒ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log('startServer();');
startServer();


// filepath: services\dto\hive-inspection.dto.ts
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

export type HiveInspectionServiceCreateDTO = Omit<hive_inspectionsAttributes, 'hive_inspection_id' | 'created_at' | 'updated_at'>;
export type HiveInspectionServiceUpdateDTO = Partial<HiveInspectionServiceCreateDTO>;
export type HiveInspectionServiceRetrievedDTO = hive_inspectionsAttributes;


// filepath: services\dto\hive-service.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// Input for creating a new hive (omits ID and timestamps)
export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Input for updating a hive (all fields optional, omits foreign key and IDs)
export type HiveServiceUpdateDTO = Partial<HiveServiceCreateDTO>;

// Output/Retrieved DTO for a hive
export type HiveServiceRetrievedDTO = hivesAttributes;


// filepath: services\dto\location-service.dto.ts
import { locationsAttributes } from '../../database/models-ts/locations.js';

// Location domain types - for creating, updating, and retrieving location data
// The service layer uses these DTOs to enforce data shape and decouple from Sequelize's model attributes.

// Data required to create a new location
export type LocationServiceCreateDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;

// Data used to update an existing location (all fields optional)
export type LocationServiceUpdateDTO = Partial<Omit<LocationServiceCreateDTO, 'user_id'>>;

// Data shape of a fully retrieved location record
export type LocationServiceRetrievedDTO = locationsAttributes;


// filepath: services\dto\major-inspection-service.dto.ts
import { major_inspectionsAttributes, major_inspections } from 'database/models-ts/major-inspections.js';

export type MajorInspectionServiceCreateDTO = Omit<major_inspectionsAttributes, 'major_inspection_id' | 'created_at' | 'updated_at'>;
export type MajorInspectionServiceUpdateDTO = Partial<MajorInspectionServiceCreateDTO>;
export type MajorInspectionServiceRetrievedDTO = major_inspectionsAttributes;


// filepath: services\dto\user-service.dto.ts
import { usersAttributes } from '../../database/models-ts/users.js';

// User domain types - for creating, updating, and retrieving user data ... called on the services layer
export type UserCreationDTO = Omit<usersAttributes, 'user_id' | 'created_at' | 'updated_at' | 'google_id' | 'linkedin_id'>;
export type UserUpdateDTO = Partial<UserCreationDTO>;
export type UserRetrievedDTO = Omit<usersAttributes, 'google_id' | 'linkedin_id'>;


// filepath: services\hive-inspection-service.ts
// src/services/hiveInspectionService.ts

import { hive_inspections } from '../database/models-ts/hive_inspections.js';
//import { major_inspections } from 'database/models-ts/major_inspections.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js'; // Importing the type for hive inspection attributes
//import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
//import { HiveInspectionCreationAttributes } from '../database/models-obsolete/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(hiveInspectionData: hive_inspectionsAttributes): Promise<hive_inspectionsAttributes> {
    const newHiveInspection = await hive_inspections.create({ ...hiveInspectionData });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(majorInspectionId: string): Promise<hive_inspectionsAttributes[]> {
    const hiveInspections = await hive_inspections.findAll({ where: { major_inspection_id: majorInspectionId }, order: [['created_at', 'ASC']] });
    return hiveInspections.map((hi) => hi.toJSON());
  }

  public static async getHiveInspectionById(id: string, majorInspectionId: string): Promise<hive_inspectionsAttributes | null> {
    const hiveInspection = await hive_inspections.findOne({ where: { hive_inspection_id: id, major_inspection_id: majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(id: string, majorInspectionId: string, updateData: Partial<hive_inspectionsAttributes>): Promise<hive_inspectionsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await hive_inspections.update(updateData, {
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(id: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await hive_inspections.destroy({
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
    });
    return deletedRows > 0;
  }

  /**
   * Retrieves hive inspections for a specific hive, ensuring both the hive itself
   * and its associated major inspection belong to the given location.
   * This enforces a strong authorization chain and filters results precisely.
   *
   * @param locationId The ID of the location to filter by.
   * @param hiveNumber The ID of the hive to filter by (corresponds to hive_id).
   * @returns A promise that resolves to an array of hive inspection attributes.
   */
  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<hive_inspectionsAttributes[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await hive_inspections.findAll({
      include: [
        {
          // 1. Include the 'majorInspection' association
          // This ensures the hive inspection is linked to a major inspection
          // that belongs to the specified location.
          association: 'majorInspection', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          where: { location_id: locationId }, // Filter major_inspections by their location_id column
          required: true, // Perform an INNER JOIN, meaning the major inspection must exist and match the locationId
        },
        {
          // 2. Include the 'hive' association
          // This ensures the hive inspection is linked to a hive
          // that also belongs to the specified location.
          association: 'hive', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          required: true, // Perform an INNER JOIN, meaning the hive must exist
          where: { location_id: locationId }, // Filter hives by their location_id column
        },
      ],
      where: {
        // 3. Filter the primary hive_inspections by the specific hive_id
        hive_id: hiveNumber,
      },
      order: [['created_at', 'ASC']],
    });
    return hiveInspections.map((hi) => hi.toJSON());
  }
}


// filepath: services\hive-service.ts
// src/services/hiveService.ts

//import { hives, hivesAttributes } from '../database/models-ts/hives.js';
import { IHiveRepository } from '../repositories/interfaces/i-hive-repository.js'; // repositories/interfaces/i-hive-repository.js';
import { HiveInspectionServiceRetrievedDTO } from './dto/hive-inspection.dto.js';
//import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';
//import { locations } from '../database/models-ts/locations.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';

export class HiveService {
  private _hiveRepository: IHiveRepository;

  constructor(private hiveRepository: IHiveRepository) {
    this._hiveRepository = hiveRepository;
  }

  // TODO MODIFY METHODS TO USE REPOSITORY INSTEAD OF DIRECT MODEL ACCESS
  /**
   * Retrieves all hives associated with a specific location, ensuring the location belongs to the user.
   * @param locationId The ID of the location to retrieve hives for.
   * @returns A promise that resolves to an array of hive objects.
   */
  public async getHivesByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const hivesFound: HiveServiceRetrievedDTO[] = await this._hiveRepository.findAllByLocationId(locationId); //  .findAll({

    return hivesFound;
  }

  /**
   * Retrieves a single hive by its ID and location ID, ensuring the location belongs to the user.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to retrieve.
   * @returns A promise that resolves to the hive object or null if not found.
   */
  public async getHiveById(locationId: string, hiveId: string): Promise<HiveServiceRetrievedDTO | null> {
    const hive = await this._hiveRepository.findById(hiveId, locationId); // .findOne({

    return hive ? hive : null;
  }

  /**
   * Creates a new hive for a given location.
   * @param hiveData The data for the new hive.
   * @returns A promise that resolves to the newly created hive object.
   */
  public async createHive(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    console.log('Service Creating hive...', hiveData);

    const newCreatedHive = await this._hiveRepository.create(hiveData);
    return newCreatedHive; //.toJSON();
  }

  /**
   * Updates an existing hive.
   * @param hiveId The ID of the hive to update.
   * @param updateData The data to update.
   * @returns A promise that resolves to the updated hive object or null if not found.
   */
  public async updateHive(hiveId: string, updateData: HiveServiceUpdateDTO): Promise<HiveServiceRetrievedDTO | null> {
    // Check if the hive exists and belongs to the user and location
    const hiveToUpdate = await this._hiveRepository.findById(hiveId);

    if (!hiveToUpdate) {
      return null;
    }

    const [numberOfAffectedRows, affectedRows] = await this._hiveRepository.update(hiveId, updateData);

    if (numberOfAffectedRows === 0) {
      return null;
    }

    return affectedRows[0];
  }

  /**
   * Deletes a hive by its ID and location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to delete.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteHive(locationId: string, hiveId: string): Promise<boolean> {
    console.log('Service (deleteHive) Deleting hive...', locationId, hiveId);

    // if the location is given, the Hive ID must belong to that Location
    const hiveToDelete = await this._hiveRepository.findById(hiveId, locationId);

    if (!hiveToDelete) {
      return false;
    }

    console.log('Service (deleteHive) Found hive to delete:', hiveToDelete);

    const deletedRows = await this.hiveRepository.delete(hiveId, locationId);

    return deletedRows > 0;
  }

  /**
   * Deletes all hives by their location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteAllHives(locationId: string): Promise<boolean> {
    const deletedRows = await this._hiveRepository.deleteAll(locationId);

    return deletedRows > 0;
  }
}


// filepath: services\location-service.ts
import { ILocationRepository } from '../repositories/interfaces/i-location-repository.js';
import { LocationServiceRetrievedDTO, LocationServiceCreateDTO, LocationServiceUpdateDTO } from './dto/location-service.dto.js';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

export class LocationService {
  private readonly locationRepository: ILocationRepository;

  // Dependency Injection: Injecting the repository contract
  constructor(locationRepository: ILocationRepository) {
    this.locationRepository = locationRepository;
  }

  /**
   * Creates a new location entry.
   * @param locationData The data for the new location, including user_id.
   * @returns The created location DTO.
   */
  public async createLocation(locationData: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    // No complex business logic here yet (e.g., uniqueness checks), so delegate directly.
    return this.locationRepository.create(locationData);
  }

  /**
   * Retrieves all locations belonging to a specific user.
   * @param userId The ID of the owner.
   * @returns An array of location DTOs.
   */
  public async getAllLocationsByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    return this.locationRepository.findAllByUserId(userId);
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public async getLocationById(locationId: string): Promise<LocationServiceRetrievedDTO | null> {
    const _loc = await this.locationRepository.findById(locationId);
    return _loc;
  }

  /**
   * Updates an existing location.
   * @param locationId The ID of the location to update.
   * @param updateData The fields to update.
   * @returns The updated location DTO.
   */
  public async updateLocation(locationId: string, updateData: LocationServiceUpdateDTO): Promise<LocationServiceRetrievedDTO> {
    // Check if the location exists before updating
    const existingLocation = await this.locationRepository.findById(locationId);
    if (!existingLocation) {
      const error = new Error('Location not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    const [updatedCount, updatedLocations] = await this.locationRepository.update(locationId, updateData);

    if (updatedCount > 1) {
      // This error indicates a serious issue in the repository or ORM logic
      const error = new Error(`Failed to update location with ID ${locationId}. Concurrency issue suspected.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      // Should not happen after the initial existence check, but is a safety net
      const error = new Error(`Location with ID ${locationId} not found during update.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    // Return the single updated location DTO
    return updatedLocations[0];
  }

  /**
   * Deletes a location.
   * @param locationId The ID of the location to delete.
   * @returns The number of records deleted (should be 1).
   */
  public async deleteLocation(locationId: string): Promise<number> {
    // Optional: Add pre-delete check or business logic here (e.g., cannot delete if hives are present)
    return this.locationRepository.delete(locationId);
  }

  /**
   * Checks if a location is owned by a specific user. Helpful for authorization middleware checks
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns True if the location is owned by the user, false otherwise.
   */
  public async checkLocationOwnership(locationId: string, userId: string): Promise<boolean> {
    const location = await this.locationRepository.findById(locationId);
    return location ? location.user_id === userId : false;
  }
}


// filepath: services\major-inspection-service.ts
// src/services/majorInspectionService.ts

//import { MajorInspection } from '../database/models-obsolete/MajorInspection.js'  ;
import { major_inspections } from '../database/models-ts/major-inspections.js'; // Updated to use the new TypeScript model
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js'; // Importing the type for major inspection attributes
import { locations } from '../database/models-ts/locations.js';
//import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
//import {MajorInspectionCreationAttributes} from '../database/models/MajorInspection'; // Import the creation attributes type
//import { CreateMajorInspectionDto, UpdateHiveInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class MajorInspectionService {
  public static async createMajorInspection(location_id: string, inspectionData: major_inspectionsAttributes): Promise<major_inspectionsAttributes> {
    console.log('Creating major inspection with data:', location_id, inspectionData);
    // Convert inspectionDate string from DTO to a Date object
    const newInspectionDate = new Date(inspectionData.inspection_date);

    // Create the object to be passed to Sequelize.create()
    const inspectionDataForCreation = {
      ...inspectionData,
      //inspection_date: new Date(inspectionData.inspection_date),
      location_id: location_id, // Ensure the location_id is set correctly
    };

    console.log('Inspection data for creation via sequelize:', inspectionDataForCreation);
    const newMajorInspection = await major_inspections.create({
      ...inspectionDataForCreation,
    });

    return newMajorInspection.toJSON();
  }

  public static async getMajorInspectionsByLocationId(locationId: string): Promise<major_inspectionsAttributes[]> {
    const majorInspections = await major_inspections.findAll({
      where: { location_id: locationId },
      order: [['inspection_date', 'DESC']],
    });
    return majorInspections.map((mi) => mi.toJSON());
  }

  public static async getMajorInspectionById(
    // ZAKAJ MI TO 2x klice z razlicnim vrstnim redom argumentov???????????
    userId: string, // Check ownership by userId
    majorInspectionId: string,
    locationId: string
  ): Promise<major_inspectionsAttributes | null> {
    console.log(`Fetching major inspection by ID...\nmajorInspectionId: ${majorInspectionId}\nlocationId: ${locationId}\nuserId: ${userId}`);

    try {
      const majorInspection = await major_inspections.findOne({
        where: { major_inspection_id: majorInspectionId, location_id: locationId },
      });
    } catch (error) {
      console.error('TEST Error fetching major inspection by ID:', error);
    }

    const majorInspection = await major_inspections.findOne({
      where: { major_inspection_id: majorInspectionId, location_id: locationId },
      include: [
        {
          association: 'majorInspection_location', // Make sure this matches your association name in the MajorInspection model

          where: { location_id: locationId, user_id: userId }, // Ensure the location belongs to the user
          required: true,
        },
      ],
    });
    return majorInspection ? majorInspection.toJSON() : null;
  }

  public static async updateMajorInspection(
    locationId: string,
    majorInspectionId: string,
    updateData: major_inspectionsAttributes
    // Partial<MajorInspectionInterface>
  ): Promise<major_inspectionsAttributes | null> {
    console.log('Updating major inspection service..', majorInspectionId, locationId, updateData);
    const [numberOfAffectedRows, affectedRows] = await major_inspections.update(updateData, {
      where: { location_id: locationId, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteMajorInspection(userId: string, locationId: string, majorInspectionId: string): Promise<boolean> {
    console.log('Deleting major inspection service..', majorInspectionId, locationId, userId);
    // Step 1: Find the major inspection ID that matches all criteria
    const majorInspectionToDelete = await major_inspections.findOne({
      attributes: ['major_inspection_id'], // Only select the ID to minimize data transfer
      where: {
        major_inspection_id: majorInspectionId,
      },
      include: [
        {
          model: locations,
          //as: 'location', // Ensure this matches your association alias
          as: 'majorInspection_location',
          attributes: [],
          where: {
            location_id: locationId,
            user_id: userId, // Ensure the location belongs to the user
          },
          required: true, // This acts as an INNER JOIN, ensuring all conditions must be met
        },
      ],
    });

    if (!majorInspectionToDelete) {
      // No matching major inspection found for the given user, location, and majorInspectionId
      return false;
    }

    // Step 2: Delete the identified major inspection
    const deletedRows = await major_inspections.destroy({
      where: {
        major_inspection_id: majorInspectionToDelete.toJSON().major_inspection_id,
      },
    });

    return deletedRows > 0;
  }
}


// filepath: services\user-service.ts
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user creation attributes
import { IUserRepository } from '../repositories/interfaces/i-user-repository.js'; // The contract
import { UserRetrievedDTO, UserCreationDTO, UserUpdateDTO } from './dto/user-service.dto.js'; // The data shapes
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

// This class handles business logic (e.g., uniqueness check, error handling). No direct access to DB, just through repository.
export class UserService {
  private readonly userRepository: IUserRepository;
  constructor(userRepository: IUserRepository) {
    this.userRepository = userRepository;
  }

  public async findUserByEmail(email: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readByEmail(email);
  }

  public async findUserById(id: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readById(id);
  }

  public async createUser(userData: UserCreationDTO): Promise<UserRetrievedDTO> {
    // Check if user already exists (Business Logic)
    const existingUser = await this.userRepository.readByEmail(userData.email);
    if (existingUser) {
      // Throw a specific error that the Controller/ErrorHandler can catch
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = httpStatus.CONFLICT; // 409
      throw error;
    }

    // Delegate the creation to the repository (Data Access)
    return this.userRepository.create(userData);
  }

  public async updateUser(id: string, userData: Partial<UserUpdateDTO>): Promise<UserRetrievedDTO> {
    // Check if user exists
    const existingUser = await this.userRepository.readById(id);
    if (!existingUser) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Delegate the update to the repository (Data Access)
    const [updatedCount, updatedUsers] = await this.userRepository.update(id, userData);

    if (updatedCount > 1) {
      const error = new Error(`Failed to update user with ID ${id}.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      const error = new Error(`User with ID ${id} not found.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    return updatedUsers[0]; // decide for later if you want to return array or single object
  }
}


// filepath: src-summary3.txt
// filepath: .env
# Environment variables for MyHives App
PORT=3000

NODE_ENV=development
API_BASE_URL=http://localhost:3000/api

# Database Configuration
DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=Cada_2068_new # <--- IMPORTANT: Replace with your actual password!
DB_NAME=myhives_db                     # <--- IMPORTANT: Replace with the database name you created!

DATABASE_URL=postgresql://postgres:Cada_2068_new@localhost:5432/myhives_db
JWT_SECRET=my_jwt_super_dupper_secret_key


# Google OAuth Credentials
GOOGLE_CLIENT_ID="your_google_client_id"
GOOGLE_CLIENT_SECRET="your_google_client_secret"

# LinkedIn OAuth Credentials
LINKEDIN_CLIENT_ID="your_linkedin_client_id"
LINKEDIN_CLIENT_SECRET="your_linkedin_client_secret"

# Frontend URL for CORS and OAuth redirects
FRONTEND_URL="http://localhost:5173" # Or your deployed frontend URL


// filepath: appExpressInstance.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import 'reflect-metadata';
import config from './config/index.js';
import errorHandler, { CustomError } from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
import authRoutes from './routes/authRoutes.js';
import locationRoutes from './routes/locationRoutes.js';
//import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
//  import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
// import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();
const apiRouter = express.Router(); // Create a new router instance

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(
  cors({
    origin: config.frontendUrl, // Allow requests from your frontend URL
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true, // Allow cookies to be sent
  })
);

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// Mount your API router on the main app
app.use('/api/v1', apiRouter);

// --- Routes ---
// Basic health check route
apiRouter.get('/health', (req: Request, res: Response) => {
  console.log('ðŸš‘ Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');

// Mount your API routes here
apiRouter.use('/auth', authRoutes);
apiRouter.use('/locations', locationRoutes);

console.log('API routes mounted');
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 404; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;


// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url);

// Get the current directory's path
const __dirname = path.dirname(__filename);

// Load environment variables from .env file
const dotEnvConfigObject = dotenv.config({ path: path.resolve(__dirname, '../../src/.env') });
console.log('dotenv config object:', dotEnvConfigObject);

// Define the IConfig interface
interface IConfig {
  port: number;
  nodeEnv: string;
  databaseUrl: string;
  jwtSecret: string;
  googleClientId: string;
  googleClientSecret: string;
  linkedinClientId: string;
  linkedinClientSecret: string;
  frontendUrl: string; // For CORS and OAuth redirects
}

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port
};

console.log('Config loaded:', config);
console.log('config.jwtSecret:', config.jwtSecret);

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
  console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
}
if (!config.databaseUrl || config.databaseUrl === 'unknown') {
  console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
}
if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
  console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
}

export default config;


// filepath: controllers\auth-controller.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/user-service.js'; // New service

import config from '../config/index.js';
import httpStatus from 'http-status'; // Good practice for error codes

import { LoginUserOutgoingDTO, UserOutgoingDTO, UpdateUserIncomingDTO } from './dto/auth-controller.dto.js';
import { UserCreationDTO, UserUpdateDTO, UserRetrievedDTO } from '../services/dto/user-service.dto.js';

export class AuthController {
  private readonly _userService: UserService;

  constructor(userService: UserService) {
    this._userService = userService;
  }

  public register = async (req: Request, res: Response, next: NextFunction) => {
    console.log('Registering user:', req.body);
    try {
      const { username, email, password } = req.body;

      // Check if user already exists
      const existingUser: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (existingUser) {
        const error = new Error('User with this email already exists.') as CustomError;
        error.statusCode = httpStatus.CONFLICT; // 409
        throw error;
      }

      // Hash password
      const hashedPassword: string = await bcrypt.hash(password, 10); // Salt rounds = 10

      const userDataLoad: UserCreationDTO = { username, email, password_hash: hashedPassword };

      // Create user
      const newUser: UserRetrievedDTO = await this._userService.createUser(userDataLoad);

      // // Generate token (optional, could just return success message)
      // const token = generateToken({ userId: newUser.user_id! });
      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User registered successfully! Please log in.',
        user: {
          id: newUser.user_id!,
          username: newUser.username,
          email: newUser.email,
        },
      };

      res.status(201).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body;

      const user: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (!user || !user.password_hash) {
        // Check for user existence and if they have a password (for traditional login)
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      // Compare password
      const isMatch: boolean = await bcrypt.compare(password, user.password_hash);
      if (!isMatch) {
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      // Generate token
      const token: string = generateToken({ userId: user.user_id! });

      res.cookie('jwtcookie', token, {
        httpOnly: true,
        secure: config.nodeEnv === 'production',
        maxAge: 1000 * 3600 * 24 * 7, // 7 days in milliseconds
      });

      const responseObj: LoginUserOutgoingDTO = {
        success: true,
        message: 'Logged in successfully!',
        token,
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public logout = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // In a stateless JWT system, the server doesn't need to do much for logout.
      // The client simply discards the token.
      // However, it's good practice to send a success message.

      // If using HTTP-only cookies for tokens, you'd clear the cookie here.
      // For example:
      res.clearCookie('jwtcookie'); // Assuming your JWT is in a cookie named 'jwtcookie'

      // You might also want to do some logging for audit purposes
      console.log(`User ${req.currentUser?.id || 'unknown'} logged out.`);

      res.status(200).json({
        success: true,
        message: 'Logged out successfully.',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('getMe called');
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      console.log('Current user ID:', req.currentUser.id);

      const user: UserRetrievedDTO | null = await this._userService.findUserById(req.currentUser.id);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      // Return user data (excluding password)
      const { password_hash: password, ...userData } = user;
      res.status(200).json({ success: true, user: userData });
    } catch (error) {
      next(error);
    }
  };

  public updateMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      const userId = req.currentUser!.id;
      const updateData: UpdateUserIncomingDTO = req.body;
      console.log('Update data received:', updateData);

      const readyToUpdate: UserUpdateDTO = { ...updateData, password_hash: updateData.password ? await bcrypt.hash(updateData.password, 10) : undefined };

      const user: UserRetrievedDTO = await this._userService.updateUser(userId, readyToUpdate);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User updated successfully!',
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\dto\auth-controller.dto.ts
// incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

export interface RegisterUserIncomingDTO {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}
// outgoing DTO for authentication response

export interface UserOutgoingDTO {
  success: boolean;
  message: string;
  user: {
    id: string;
    username: string;
    email: string;
  };
}
// DTO for user update (all fields optional)

export interface UpdateUserIncomingDTO {
  username?: string;
  email?: string;
  password?: string;
}

export type GetMeUserOutgoingDTO = Omit<UserOutgoingDTO, 'pass'>;

// DTO for user login
export type LoginUserOutgoingDTO = UserOutgoingDTO & {
  token: string;
};

export interface LoginUserIncomingDTO {
  email: string;
  password: string;
}


// filepath: controllers\dto\hive-controller.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// these DTO types are used in the HiveRouter files to define the shape of request body data it expects to receive and send out
export type HiveControllerCreateDTO = Omit<hivesAttributes, 'hive_id' | 'location_id' | 'created_at' | 'updated_at'>;
export type HiveControllerUpdateDTO = Partial<HiveControllerCreateDTO>;
export type HiveControllerCreateStrongDTO = Omit<HiveControllerCreateDTO, 'description'> & Required<Pick<HiveControllerCreateDTO, 'description'>>;

// const some: HiveControllerCreateStrongDTO = {
//   hive_name: 'Test Hive',
//   description: 'A test hive description',
//   is_active: true,
// };


// filepath: controllers\dto\location-controller.dto.ts
// DTOs for the Controller Layer (API input/output)

// Incoming DTO for creating a new location (user_id is implicit from the authenticated user)
export interface LocationControllerCreateInputDTO {
  name: string;
  address?: string;
  country?: string;
  latitude?: number;
  longitude?: number;
  notes?: string;
}

// Incoming DTO for updating an existing location (all fields optional)
export type LocationControllerUpdateInputDTO = Partial<LocationControllerCreateInputDTO>;

// Outgoing DTO for a single location response
export interface LocationControllerOutputDTO {
  success: boolean;
  message: string;
  location: {
    id: string;
    userId: string;
    name: string;
    address?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
    description?: string;
    createdAt: string;
    updatedAt: string;
  };
}

// Outgoing DTO for a list of locations
export interface LocationControllerListOutputDTO {
  success: boolean;
  message: string;
  locations: Array<LocationControllerOutputDTO['location']>;
}


// filepath: controllers\hive-controller.ts
import { Request, Response, NextFunction } from 'express';
import { HiveService } from '../services/hive-service.js';
import { CustomError } from '../middleware/errorHandler.js';
import { HiveServiceCreateDTO, HiveServiceRetrievedDTO, HiveServiceUpdateDTO } from 'services/dto/hive-service.dto.js';

export class HiveController {
  private _hiveService: HiveService;

  constructor(hiveService: HiveService) {
    this._hiveService = hiveService;
  }

  // Get all hives
  public getAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hives...', req.params);

      const location_id = req.params.locationId;

      const hives = await this._hiveService.getHivesByLocationId(location_id);

      res.status(200).json({
        success: true,
        message: 'Hives fetched successfully',
        data: hives,
      });
    } catch (error) {
      //res.status(500).json({ error: 'Failed to fetch hives' });
      next(error);
    }
  };

  // Get hive by ID
  public getHiveById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hive...', req.params);

      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      const hive: HiveServiceRetrievedDTO | null = await this._hiveService.getHiveById(location_id, hive_id);

      if (!hive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({
        success: true,
        message: 'Hive fetched successfully',
        data: hive,
      });
    } catch (error) {
      next(error);
    }
  };

  public createHive = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      console.log('Creating hive...', req.params.locationId, req.body);
      const location_id = req.params.locationId;
      const hiveBodyData = req.body;

      const hiveData: HiveServiceCreateDTO = { ...hiveBodyData, locationId: location_id };

      console.log('Hive data:', hiveData);

      const newHiveCreated = await this._hiveService.createHive(hiveData);

      res.status(201).json(newHiveCreated);
    } catch (error) {
      next(error);
    }
  };

  // Update a hive
  public updateHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;
      const updatedHiveData = req.body;
      const updateHivePayload: HiveServiceUpdateDTO = { ...updatedHiveData, location_id: location_id };

      const updatedHive = await this._hiveService.updateHive(hive_id, updateHivePayload);
      if (!updatedHive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive updated successfully',
        data: updatedHive,
      });
    } catch (error) {
      next(error);
    }
  };

  // Delete a hive
  public deleteHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      console.log('Controller : Deleting hive...', req.params);

      const deleted = await this._hiveService.deleteHive(location_id, hive_id);
      if (!deleted) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.location_id;

      const deleted = await this._hiveService.deleteAllHives(location_id);
      if (!deleted) {
        const error = new Error('Hives not deleted.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.json({ message: 'Hives deleted successfully', success: true });
    } catch (error) {
      next(error);
    }
  };
} // end of class HiveController

// export default {
//   getAllHives,
//   getHiveById,
//   createHive,
//   updateHive,
//   deleteHive,
//   deleteAllHives,
// };


// filepath: controllers\hive-inspection-controller.ts
// src/controllers/hiveInspectionController.ts

import { Response, NextFunction } from 'express';
import { CustomRequest } from '../types/DTO/per-controller/custom-request.js';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { MajorInspectionService } from '../services/major-inspection-service.js'; // Needed for ownership check
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

//import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import { UniqueConstraintError } from 'sequelize';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    console.log('Controller: Creating hive inspection');
    try {
      const { majorInspectionId } = req.params;
      //const userId = req.currentUser!.id; // Authenticated user ID

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }
      console.log('Controller: Major inspection ownership verified:', majorInspection);

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: hive_inspectionsAttributes = { ...req.body, major_inspection_id: majorInspectionId }; // Ensure majorInspectionId from param is used
      console.log('Hive inspection data to be created:', hiveData);

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(hiveData);
      console.log('Controller: New hive inspection created on database:', newHiveInspection);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      if (error instanceof UniqueConstraintError) {
        // <-- Check for the specific error
        // A specific hive should only be inspected once per major inspection event
        const _err = new Error('A hive inspection for this hive already exists in this major inspection.') as CustomError;
        _err.statusCode = httpStatus.CONFLICT; // Return 409 Conflict
        next(_err);
      } else {
        next(error);
      }
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const updateData: hive_inspectionsAttributes = req.body; // Joi validation should ensure valid partial data

      console.log('------------------ Controller: Updating hive inspection with data:', updateData);

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      console.log('------------------ Controller: Updated hive inspection:', updatedHiveInspection);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed
      console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspection);
      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('hicMajor inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\location-controller.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/location-service.js'; // Import the service
import { LocationControllerOutputDTO, LocationControllerListOutputDTO, LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from './dto/location-controller.dto.js';
import { LocationServiceCreateDTO, LocationServiceRetrievedDTO, LocationServiceUpdateDTO } from '../services/dto/location-service.dto.js';
import { LocationServiceToControllerMapper } from '../utils/converters/location/service-to-controller.mapper.js';
import { LocationControllerToServiceMapper } from '../utils/converters/location/controller-to-service.mapper.js';
import httpStatus from 'http-status';

export class LocationController {
  private readonly _locationService: LocationService;

  constructor(locationService: LocationService) {
    this._locationService = locationService;
  }

  public createLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const incomingData: LocationControllerCreateInputDTO = req.body; // from controller dto interface definition

      const serviceDataParam: LocationServiceCreateDTO = LocationControllerToServiceMapper.toServiceCreateDTO(incomingData, userId);

      const location: LocationServiceRetrievedDTO = await this._locationService.createLocation(serviceDataParam);

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(location, 'Location created successfully!', true);

      return res.status(httpStatus.CREATED).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getAllLocations = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      // we serve the GET method .... for "/" all locations for that user
      const locations: LocationServiceRetrievedDTO[] = await this._locationService.getAllLocationsByUserId(req.currentUser.id);

      const responseData: LocationControllerListOutputDTO = LocationServiceToControllerMapper.toControllerListOutputDTO(locations, 'Locations retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getLocationById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const specificLocation: LocationServiceRetrievedDTO | null = await this._locationService.getLocationById(locationId);

      if (!specificLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(specificLocation, 'Location retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public updateLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const updateDataRaw: LocationControllerUpdateInputDTO = req.body;

      const updateDataForService: LocationServiceUpdateDTO = LocationControllerToServiceMapper.toServiceUpdateDTO(updateDataRaw, userId);

      const updatedLocation: LocationServiceRetrievedDTO = await this._locationService.updateLocation(locationId, updateDataForService);

      if (!updatedLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location updated successfully',
        data: updatedLocation,
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      const { locationId } = req.params;
      const deleted: number = await this._locationService.deleteLocation(locationId);

      if (deleted === 0) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMapData = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // This endpoint retrieves data for the map view.
      // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
      // If it's only for logged-in users, keep authenticate middleware.
      // For showing "all registered beehive locations within a country" with owner email/username,
      // it might require a join query to get hive counts and owner info across all users.
      // For simplicity, let's just return a placeholder or mock data for now.
      // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
      // to aggregate hive counts per location.
      const mockMapData = [
        {
          id: 'loc1',
          latitude: 46.0569, // Ljubljana, Slovenia
          longitude: 14.5058,
          hiveCount: 12,
          ownerUsername: 'SlovenianBeekeeper',
        },
        {
          id: 'loc2',
          latitude: 46.5547, // Maribor, Slovenia
          longitude: 15.6459,
          hiveCount: 8,
          ownerUsername: 'ApiaryExplorer',
        },
      ];

      res.status(200).json({
        success: true,
        data: mockMapData,
      });
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\major-inspection-contoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/major-inspection-service.js';
import { LocationService } from '../services/location-service.js'; // To check location ownership
// import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
// import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';
import { major_inspectionsAttributes } from 'database/models-ts/major-inspections.js';

// // Middleware to ensure location belongs to the authenticated user
// const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Checking location ownership...', req.params, req.body, req.currentUser);
//     const userId = req.currentUser!.id;
//     const { locationId } = req.params;

//     const location = await LocationService.getLocationById(locationId, userId);
//     if (!location) {
//       const error = new Error('Location not found or unauthorized.') as CustomError;
//       error.statusCode = 403; // Forbidden
//       throw error;
//     }
//     next(); // Location is owned by the user, proceed
//   } catch (error) {
//     next(error);
//   }
// };

export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Creating major inspection...ABCD', req.params, req.body);
    const { locationId } = req.params;
    //const inspectionData: Partial<MajorInspectionInterface> = req.body;
    const inspectionData: major_inspectionsAttributes = req.body;

    const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

    res.status(201).json({
      success: true,
      message: 'Major inspection created successfully',
      data: newMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Fetching major inspections...');
    const { locationId } = req.params;

    const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

    res.status(200).json({
      success: true,
      data: majorInspections,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: majorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const updateData: major_inspectionsAttributes = req.body;
    console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);

    const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(locationId, majorInspectionId, updateData);

    if (!updatedMajorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection updated successfully',
      data: updatedMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const deleted = await MajorInspectionService.deleteMajorInspection(userId, locationId, majorInspectionId);

    if (!deleted) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

//export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
â”œâ”€â”€ app.ts // Express app setup, middleware, routes
â”œâ”€â”€ server.ts // Entry point, starts the server
â”œâ”€â”€ config/ // Environment variables, database config
â”‚ â””â”€â”€ index.ts
â”œâ”€â”€ database/ // ORM setup (Sequelize/TypeORM), models, migrations
â”‚ â”œâ”€â”€ index.ts
â”‚ â”œâ”€â”€ models/
â”‚ â”‚ â”œâ”€â”€ User.ts
â”‚ â”‚ â”œâ”€â”€ Location.ts
â”‚ â”‚ â”œâ”€â”€ MajorInspection.ts
â”‚ â”‚ â””â”€â”€ HiveInspection.ts
â”‚ â””â”€â”€ migrations/
â”œâ”€â”€ middleware/ // Custom middleware (auth, validation, error handling)
â”‚ â”œâ”€â”€ auth.ts // JWT verification, authorization checks
â”‚ â”œâ”€â”€ validation.ts // Joi/Zod for input validation
â”‚ â””â”€â”€ errorHandler.ts // Centralized error handling
â”œâ”€â”€ controllers/ // Business logic for each resource
â”‚ â”œâ”€â”€ authController.ts
â”‚ â”œâ”€â”€ locationController.ts
â”‚ â”œâ”€â”€ majorInspectionController.ts
â”‚ â””â”€â”€ hiveInspectionController.ts
â”œâ”€â”€ routes/ // API routes for each resource
â”‚ â”œâ”€â”€ authRoutes.ts
â”‚ â”œâ”€â”€ locationRoutes.ts
â”‚ â”œâ”€â”€ majorInspectionRoutes.ts
â”‚ â””â”€â”€ hiveInspectionRoutes.ts
â”œâ”€â”€ services/ // Database interaction logic (optional, for separation of concerns)
â”‚ â”œâ”€â”€ locationService.ts
â”‚ â””â”€â”€ ...
â”œâ”€â”€ types/ // TypeScript interfaces/types
â”‚ â”œâ”€â”€ express.d.ts // Extend Request for user property
â”‚ â”œâ”€â”€ models.ts
â”‚ â””â”€â”€ auth.ts
â””â”€â”€ utils/ // Utility functions (e.g., password hashing)
â””â”€â”€ jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts
import { Sequelize } from 'sequelize-typescript';
import config from '../config/index.js';
import { users } from './models-ts/users.js'; // To be created
import { locations } from './models-ts/locations.js'; // To be created
import { hive_inspections } from './models-ts/hive_inspections.js';
import { major_inspections } from './models-ts/major-inspections.js';
import { hives } from './models-ts/hives.js'; // To be created
import { associateModels } from './models-ts/associations.js'; // Adjust path if you placed it elsewhere, e.g., './models-obsolete/associations.js'

console.log('Connecting to PostgreSQL database... ', process.env.DATABASE_URL);

const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;
console.log('Database connection string:', databaseUrl);

// Initialize Sequelize with your database connection string<br>
const sequelize = new Sequelize({
  database: DB_NAME,
  username: DB_USER,
  password: DB_PASSWORD,
  host: DB_HOST,
  port: DB_PORT,
  dialect: DB_DIALECT,
  logging: false, // Enable logging to see SQL queries
  models: [users, locations, hive_inspections, major_inspections, hives], // Add all models here
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  },
  // Required for proper PostgreSQL UUID handling
  dialectOptions: {
    useUTC: false,
  },
  timezone: '+00:00', // Set timezone to UTC for consistency
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Set up associations between models
    associateModels();
    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
      console.log('Syncing database models (development mode)...');
      //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
      await sequelize.sync({ alter: false });
      console.log('Database models synchronized.');
    } else {
      // In production, rely on migrations. If you haven't run migrations,
      // you might still want a simple sync without alter.
      // Or remove this line entirely if you strictly use migrations.
      // await sequelize.sync();
      console.log('In production, use database migrations to manage schema changes.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};

export { sequelize as sequelizeInstance };
//export const db = sequelize;


// filepath: database\models-ts\associations.ts
import { users } from './users.js';
import { locations } from './locations.js';
import { major_inspections } from './major-inspections.js';
import { hives } from './hives.js';
import { hive_inspections } from './hive_inspections.js';

export function associateModels() {
  // User to Location (one-to-many)
  users.hasMany(locations, {
    foreignKey: 'user_id',
    as: 'locations',
  });
  locations.belongsTo(users, {
    foreignKey: 'user_id',
    as: 'user',
  });

  // Location to MajorInspection (one-to-many)
  locations.hasMany(major_inspections, {
    foreignKey: 'location_id',
    as: 'locations_majorInspections',
  });
  major_inspections.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'majorInspection_location',
  });

  // Location to Hives (one-to-many)
  locations.hasMany(hives, {
    foreignKey: 'location_id',
    as: 'locations_hives',
  });
  hives.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'hives_location',
  });

  // MajorInspection to HiveInspection (one-to-many)
  major_inspections.hasMany(hive_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'majors_hiveInspections',
  });
  hive_inspections.belongsTo(major_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'hiveInspections_majorInspection',
  });

  // Hive to HiveInspection (one-to-many)
  hives.hasMany(hive_inspections, {
    foreignKey: 'hive_id',
    as: 'hives_hiveInspections',
  });

  hive_inspections.belongsTo(hives, {
    foreignKey: 'hive_id',
    as: 'hiveInspections_hive',
  });
}


// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface hivesAttributes {
  hive_id?: string;
  location_id: string;
  hive_name: string;
  description?: string;
  is_active?: boolean;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hives',
  schema: 'public',
  timestamps: false,
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING(255),
  })
  hive_name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  description?: string;

  @Column({
    allowNull: true,
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('true'),
  })
  is_active?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  //   // --- Associations for Hive Inspections ---
  //   @HasMany(() => hive_inspections, {
  //     foreignKey: 'hive_id', // The foreign key in the 'hive_inspections' table that links back to 'hives'
  //     as: 'hiveInspections', // Alias for when you include hive inspections with a hive
  //   })
  //   hiveInspections?: hive_inspections[]; // Property to hold an array of associated hive inspections
}


// filepath: database\models-ts\hive_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

import { hives } from './hives.js'; // Import hives model
import { major_inspections } from './major-inspections.js'; // Import major_inspections model

export interface hive_inspectionsAttributes {
  hive_inspection_id?: string;
  major_inspection_id: string;
  hive_id: string;
  inspection_time: string;
  colony_health_status_id: number;
  num_chambers: number;
  brood_frames_count?: number;
  brood_percentage?: number; // no longer string
  queen_status_id: number;
  approx_honey_weight_kg?: number;
  drone_comb_frames_count?: number;
  drone_comb_percentage?: number; // no longer string
  sugar_feed_added?: boolean;
  sugar_feed_quantity_kg?: number;
  brood_chambers_count: number;
  supers_count: number;
  queen_excluder_present?: boolean;
  num_varroa_mites_found?: number;
  varroa_treatment_id?: number;
  varroa_treatment_dosage?: string;
  raising_new_queen?: boolean;
  queen_cell_age_days?: number;
  queen_cell_status_id?: number;
  other_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hive_inspections',
  schema: 'public',
  timestamps: false,
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_inspection_id?: string;

  @ForeignKey(() => major_inspections) // Indicates that major_inspection_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  major_inspection_id!: string;

  @ForeignKey(() => hives) // Indicates that hive_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  hive_id!: string;

  //   @BelongsTo(() => hives, {
  //     foreignKey: 'hive_id',
  //     as: 'hive', // Alias for when you include the hive with a hive inspection
  //   })
  //   hive?: hives; // Property to hold the associated hive

  @Column({
    type: DataType.STRING,
  })
  inspection_time!: string;

  @Column({
    type: DataType.INTEGER,
  })
  colony_health_status_id!: number;

  @Column({
    type: DataType.INTEGER,
  })
  num_chambers!: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_percentage?: number;

  @Column({
    type: DataType.INTEGER,
  })
  queen_status_id!: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  approx_honey_weight_kg?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  drone_comb_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(3, 0),
  })
  drone_comb_percentage?: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  sugar_feed_added?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  sugar_feed_quantity_kg?: number;

  @Column({
    type: DataType.INTEGER,
  })
  brood_chambers_count!: number;

  @Column({
    type: DataType.INTEGER,
  })
  supers_count!: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  queen_excluder_present?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  num_varroa_mites_found?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  varroa_treatment_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  varroa_treatment_dosage?: string;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  raising_new_queen?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_age_days?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_status_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  other_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // @BelongsTo(() => major_inspections, {
  //   foreignKey: 'major_inspection_id',
  //   as: 'majorInspection', // This alias is consistent with what you used in HiveInspectionService
  // })
  // majorInspection?: major_inspections; // Property to hold the associated major inspection
}


// filepath: database\models-ts\index.ts
export * from './hives.js';
export * from './users.js';
export * from './locations.js';
export * from './major-inspections.js';
export * from './hive_inspections.js';
export * from './colony_health_statuses.js';
export * from './queen-statuses.js';
export * from './varroa_treatments.js';
export * from './queen-cell-statuses.js';


// filepath: database\models-ts\locations.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { users } from './users.js';
// import { hives } from './hives.js'; // Import hives model
// import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface locationsAttributes {
  location_id?: string;
  user_id: string;
  name: string;
  address?: string;
  latitude?: string;
  longitude?: string;
  country?: string;
  notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'locations',
  schema: 'public',
  timestamps: false,
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  location_id?: string;

  @ForeignKey(() => users)
  @Column({
    type: DataType.UUID,
  })
  user_id!: string;

  @Column({
    type: DataType.STRING(255),
  })
  name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(500),
  })
  address?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  latitude?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  longitude?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(100),
  })
  country?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // Association with users model
  //   @BelongsTo(() => users)
  //   user?: users; // This property would hold the associated user object

  // --- Associations for Hives ---
  //   @HasMany(() => hives, {
  //     foreignKey: 'location_id', // The foreign key in the 'hives' table that links back to 'locations'
  //     as: 'hives', // Alias for when you include hives with a location
  //   })
  //   hives?: hives[]; // Property to hold an array of associated hives

  // --- Associations for Major Inspections ---
  //   @HasMany(() => major_inspections, {
  //     foreignKey: 'location_id', // The foreign key in the 'major_inspections' table that links back to 'locations'
  //     as: 'majorInspections', // Alias for when you include major inspections with a location
  //   })
  //   majorInspections?: major_inspections[]; // Property to hold an array of associated major inspections
}


// filepath: database\models-ts\major-inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';

import { locations } from './locations.js'; // Import locations model
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface major_inspectionsAttributes {
  major_inspection_id?: string;
  location_id: string;
  inspection_date: string;
  general_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'major_inspections',
  schema: 'public',
  timestamps: false,
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  major_inspection_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  // @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  // location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING,
  })
  inspection_date!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  general_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
  // --- Associations for Hive Inspections ---
  @HasMany(() => hive_inspections, {
    foreignKey: 'major_inspection_id', // The foreign key in the 'hive_inspections' table that links back to 'major_inspections'
    as: 'hiveInspections', // Alias for when you include hive inspections with a major inspection
  })
  hiveInspections?: hive_inspections;
  */
}


// filepath: database\models-ts\queen-cell-statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen-statuses.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

export interface queen_statusesAttributes {
  status_id?: number;
  status_name: string;
}

@Table({
  tableName: 'queen_statuses',
  schema: 'public',
  timestamps: false,
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {
  @Column({
    primaryKey: true,
    autoIncrement: true,
    type: DataType.INTEGER,
    defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)"),
  })
  status_id?: number;

  @Column({
    type: DataType.STRING(50),
  })
  status_name!: string;
}


// filepath: database\models-ts\users.ts
import { Model, Table, Column, DataType, Index, Sequelize, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';

export interface usersAttributes {
  user_id?: string;
  username: string;
  password_hash?: string;
  email: string;
  google_id?: string;
  linkedin_id?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'users',
  schema: 'public',
  timestamps: false,
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  user_id?: string;

  @Column({
    type: DataType.STRING(255),
  })
  username!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  password_hash?: string;

  @Column({
    type: DataType.STRING(255),
  })
  email!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  google_id?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  linkedin_id?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
	// Association with locations model
	@HasMany(() => locations, { foreignKey: 'user_id' })
    locations?: locations[]; // This property would hold an array of associated locations
	*/
}


// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: database\myhives_db_script.sql
-- Enable the pgcrypto extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Table for Users
-- Stores user authentication details, supporting traditional, Google, and LinkedIn logins.
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- Storing hashed password for traditional login
    email VARCHAR(255) UNIQUE NOT NULL,
    google_id VARCHAR(255) UNIQUE, -- Google OAuth ID
    linkedin_id VARCHAR(255) UNIQUE, -- LinkedIn OAuth ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index on commonly searched authentication fields
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_google_id ON users(google_id);
CREATE INDEX idx_users_linkedin_id ON users(linkedin_id);


-- Table for Beehive Locations/Stands
-- Stores information about where beekeepers manage their hives.
CREATE TABLE locations (
    location_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE, -- Link to the owner
    name VARCHAR(255) NOT NULL, -- Name of the location (e.g., "Backyard Apiary", "Field A")
    address VARCHAR(500), -- Optional: physical address
    latitude NUMERIC(9,6), -- Latitude for map display
    longitude NUMERIC(9,6), -- Longitude for map display
    country VARCHAR(100), -- Country for potential regional filtering/map views
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_LocationName_User UNIQUE (user_id, name) -- Location names must be unique per user
);

-- Indexes for location data
CREATE INDEX idx_locations_user_id ON locations(user_id);
CREATE INDEX idx_locations_lat_lon ON locations(latitude, longitude);


-- Table for Individual Beehives
-- Represents a specific beehive within a location, allowing tracking of its history.
CREATE TABLE hives (
    hive_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE, -- Link to its physical location
    hive_name VARCHAR(255) NOT NULL, -- Unique name/identifier for the hive within its location (e.g., "Hive 1", "Blue Box")
    description TEXT, -- General description of the hive
    is_active BOOLEAN DEFAULT TRUE, -- Flag if the hive is currently active at this location
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_HiveName_Location UNIQUE (location_id, hive_name) -- Hive names must be unique within a location
);

-- Index for hive data
CREATE INDEX idx_hives_location_id ON hives(location_id);


-- Lookup Table: Colony Health Statuses
-- Predefined options for colony health (e.g., thriving, weak, failing)
CREATE TABLE colony_health_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO colony_health_statuses (status_name) VALUES
('Thriving'),
('Weak'),
('Failing'),
('Unknown');


-- Lookup Table: Queen Statuses
-- Predefined options for queen status (e.g., seen, not seen, laying well)
CREATE TABLE queen_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_statuses (status_name) VALUES
('Seen'),
('Not Seen'),
('Laying Well'),
('Queen Cells Present'),
('Superseded'),
('Absent'),
('Virgin'),
('Unknown');


-- Lookup Table: Varroa Treatments
-- Predefined options for varroa treatments (e.g., Formic acid, Oxalic acid, None)
CREATE TABLE varroa_treatments (
    treatment_id SERIAL PRIMARY KEY,
    treatment_name VARCHAR(100) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO varroa_treatments (treatment_name) VALUES
('Formic Acid'),
('Oxalic Acid'),
('Apivar'),
('Api Life Var'),
('Mite Away Quick Strips'),
('None'),
('Other');


-- Lookup Table: Queen Cell Statuses
-- Predefined options for queen cell status (e.g., open, closed)
CREATE TABLE queen_cell_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_cell_statuses (status_name) VALUES
('Open'),
('Closed'),
('Hatched'),
('Destroyed'),
('Emerging'),
('Unknown');


-- Table for Major Inspections
-- Represents a single visit to a location where one or more hives were inspected.
CREATE TABLE major_inspections (
    major_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE,
    inspection_date DATE NOT NULL,
    general_notes TEXT, -- General notes for the entire location visit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_MajorInspection_LocationDate UNIQUE (location_id, inspection_date)
);

-- Index for major inspections
CREATE INDEX idx_major_inspections_location_date ON major_inspections(location_id, inspection_date);


-- Table for Individual Hive Inspections
-- Detailed records for each specific hive inspection within a major inspection.
CREATE TABLE hive_inspections (
    hive_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    major_inspection_id UUID NOT NULL REFERENCES major_inspections(major_inspection_id) ON DELETE CASCADE,
    hive_id UUID NOT NULL REFERENCES hives(hive_id) ON DELETE CASCADE,
    inspection_time TIME WITHOUT TIME ZONE NOT NULL, -- Hour of inspection specific to this hive
    
    -- Colony Health
    colony_health_status_id INTEGER NOT NULL REFERENCES colony_health_statuses(status_id),
    num_chambers INTEGER NOT NULL, -- Number of hive boxes/chambers
    
    -- Brood details (allowing for either count or percentage, or both)
    brood_frames_count INTEGER, -- Number of frames with brood
    brood_percentage NUMERIC(5,2), -- Percentage of brood (e.g., 75.00 for 75%)
    
    -- Queen Status
    queen_status_id INTEGER NOT NULL REFERENCES queen_statuses(status_id),
    
    -- Honey and Drone Comb
    approx_honey_weight_kg NUMERIC(8,2), -- Approximate amount of honey in kg
    drone_comb_frames_count INTEGER, -- Number of frames with drone comb
    drone_comb_percentage NUMERIC(5,2), -- Percentage of drone comb
    
    -- Feeding and Configuration
    sugar_feed_added BOOLEAN NOT NULL DEFAULT FALSE,
    sugar_feed_quantity_kg NUMERIC(8,2), -- Quantity of sugar feed added in kg
    brood_chambers_count INTEGER NOT NULL,
    supers_count INTEGER NOT NULL,
    queen_excluder_present BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Varroa Mites
    num_varroa_mites_found INTEGER,
    varroa_treatment_id INTEGER REFERENCES varroa_treatments(treatment_id),
    varroa_treatment_dosage VARCHAR(255), -- Dosage/amount (e.g., "5ml", "2 strips")
    
    -- Queen Rearing
    raising_new_queen BOOLEAN NOT NULL DEFAULT FALSE,
    queen_cell_age_days INTEGER, -- Age in days, if known
    queen_cell_status_id INTEGER REFERENCES queen_cell_statuses(status_id),
    
    other_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- A specific hive should only be inspected once per major inspection event
    CONSTRAINT UQ_HiveInspection_MajorHive UNIQUE (major_inspection_id, hive_id)
);

-- Indexes for hive inspections
CREATE INDEX idx_hive_inspections_major_id ON hive_inspections(major_inspection_id);
CREATE INDEX idx_hive_inspections_hive_id ON hive_inspections(hive_id);


-- Function to update the `updated_at` column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to automatically update `updated_at` on row modification
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_locations_updated_at
BEFORE UPDATE ON locations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hives_updated_at
BEFORE UPDATE ON hives
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_major_inspections_updated_at
BEFORE UPDATE ON major_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hive_inspections_updated_at
BEFORE UPDATE ON hive_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Authentication middleware called');
    const authHeader = req.headers.authorization;
    console.log('Token received:', req.headers.authorization);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);
    console.log('Decoded token:', decoded);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.currentUser = { id: decoded.userId }; // Ensure 'user_id' is set for compatibility};

    next();
  } catch (error: any) {
    console.error('Authentication error:', error);
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    console.error(`Error status code: ${err.statusCode}, message: ${err.message}`);
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };


// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error Handler  occurred:', {
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
  });
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;


// filepath: middleware\ownership.ts
import { Request, Response, NextFunction } from 'express';
import { LocationService } from '../services/location-service.js'; // To check location ownership
import { MajorInspectionService } from '../services/major-inspection-service.js';
import httpStatus from 'http-status';
import { CustomError } from '../middleware/errorHandler.js';
import { ParamsDictionary } from 'express-serve-static-core';

interface LocationParams extends ParamsDictionary {
  locationId: string;
}

// Middleware to ensure location belongs to the authenticated user
// Goal is to check if the :majorInspectionId in the URL param belongs to the authenticated user
// This assumes MajorInspectionService has a method to verify ownership without requiring locationId in URL
const checkMajorInspectionOwnershipForHive = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Checking major inspection ownership for hive inspections...', req.params, req.body, req.currentUser);
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    // IMPORTANT: You need to implement this method in your MajorInspectionService.
    // It should fetch the major inspection and ensure its associated location's userId matches the current user.
    //const majorInspectionOwned = await MajorInspectionService.getMajorInspectionByIdAndVerifyUser(
    // console.log(
    //   '\t\t @Ownership/checkMajorInspectionOwnershipForHive Checking major inspection ownership for hive inspections...',
    //   '\nmajorInspectionId:',
    //   majorInspectionId,
    //   '\nlocationId:',
    //   locationId,
    //   '\nuserId:',
    //   userId
    // );

    const majorInspectionOwned = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspectionOwned) {
      const error: CustomError = new Error('oMajor Inspection not found or not owned by user') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Store the fetched object on res.locals for subsequent handlers
    res.locals.majorInspectionOwned = majorInspectionOwned;
    //console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspectionOwned);

    next();
  } catch (error) {
    console.error('%%% Error checking major inspection ownership for hive:', error);
    next(error);
  }
};

/**
 * Middleware factory that accepts an instance of LocationService via Dependency Injection.
 * It returns the actual Express middleware function which checks if the authenticated user
 * owns the resource specified by :locationId.
 *
 * @param locationService An instance of the LocationService used to perform the check.
 * @returns The Express middleware function to be used in routes.
 */
const checkLocationOwnership = (locationService: LocationService) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const locationId = req.params.locationId as string;
      // req.currentUser is set by a preceding authentication middleware (like isAuthenticated)
      const userId = req.currentUser?.id;

      if (!userId) {
        // This should be caught by isAuthenticated, but is a necessary safety check
        const error = new Error('Authentication required for ownership check.') as CustomError;
        error.statusCode = httpStatus.UNAUTHORIZED; // 401
        throw error;
      }

      // Call the non-static instance method on the injected service
      const isOwner = await locationService.checkLocationOwnership(locationId, userId);

      if (!isOwner) {
        const error = new Error('Forbidden. You do not own this location.') as CustomError;
        error.statusCode = httpStatus.FORBIDDEN; // 403
        throw error;
      }

      // Ownership confirmed, proceed
      next();
    } catch (error) {
      next(error);
    }
  };
};

export { checkLocationOwnership, checkMajorInspectionOwnershipForHive };


// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { CustomError } from './errorHandler.js';
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/foobar.js';

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  // console.log('Validation middleware initialized with schemas:', schemas);
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: repositories\implementations\hive-repository.ts
import { Sequelize } from 'sequelize';
import { IHiveRepository } from '../interfaces/i-hive-repository.js';
import { hives } from '../../database/models-ts/hives.js'; //'../ database/models-ts/hives.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Concrete Hive repository.
 *
 * Note: This file provides a pragmatic implementation using Prisma.
 * The exported instance is asserted to IHiveRepository to match your interface
 * even if the exact method signatures differ from this example.
 */
export class HiveRepository implements IHiveRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    const newHive = await hives.create(hiveData);
    return newHive as HiveServiceRetrievedDTO;
  }

  async update(id: string, hiveData: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]> {
    return this.db.transaction(async (t) => {
      const [updatedCount, [updatedHive]] = await hives.update(hiveData, {
        where: { hive_id: id },
        returning: true,
      });
      return [updatedCount, updatedCount > 0 ? [updatedHive as HiveServiceRetrievedDTO] : []];
    });
  }

  async findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null> {
    if (locationId) {
      const hiveWithLocation = await hives.findOne({
        where: {
          hive_id: hiveId,
          location_id: locationId,
        },
      });
      return hiveWithLocation ? (hiveWithLocation as HiveServiceRetrievedDTO) : null;
    } else {
      const hive = await hives.findByPk(hiveId);
      return hive ? (hive as HiveServiceRetrievedDTO) : null;
    }
  }

  async findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const allHives = await hives.findAll({ where: { location_id: locationId } });
    return allHives as HiveServiceRetrievedDTO[];
  }

  async delete(id: string, locationId?: string): Promise<number> {
    const whereCondition = locationId ? { hive_id: id, location_id: locationId } : { hive_id: id };

    const deletedCount: number = await hives.destroy({ where: whereCondition });
    return deletedCount;
  }

  async deleteAll(locationId: string): Promise<number> {
    const deletedCount: number = await hives.destroy({ where: { location_id: locationId } });
    return deletedCount;
  }
}


// filepath: repositories\implementations\location-repository.ts
import { Sequelize } from 'sequelize';
import { ILocationRepository } from '../interfaces/i-location-repository.js';
import { locations } from '../../database/models-ts/locations.js'; // Assuming model is imported like this
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

export class LocationRepository implements ILocationRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    const newLocation = await locations.create(location);
    return newLocation.toJSON() as LocationServiceRetrievedDTO;
  }

  async findById(id: string): Promise<LocationServiceRetrievedDTO | null> {
    const location = await locations.findByPk(id);
    return location ? (location.toJSON() as LocationServiceRetrievedDTO) : null;
  }

  async findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    const allLocations = await locations.findAll({ where: { user_id: userId } });
    return allLocations.map((location) => location.toJSON() as LocationServiceRetrievedDTO);
  }

  async update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedLocations] = await locations.update(location, {
        where: { location_id: id },
        returning: true,
        transaction: t, // Pass the transaction object
      });

      if (updatedCount > 1) {
        // Safety mechanism: If more than one row was somehow affected, trigger rollback.
        throw new Error('Concurrency failure: More than one location record updated.');
      }

      // If successful, commit automatically.
      return [updatedCount, updatedLocations.map((loc) => loc.toJSON() as LocationServiceRetrievedDTO)];
    });
  }

  async delete(id: string): Promise<number> {
    return locations.destroy({ where: { location_id: id } });
  }
}


// filepath: repositories\implementations\user-repository.ts
import { IUserRepository } from '../interfaces/i-user-repository.js';
import { users } from '../../database/models-ts/users.js';
import { sequelizeInstance as database } from '../../database/connect.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export class UserRepository implements IUserRepository {
  private readonly db = database;

  async create(user: UserCreationDTO): Promise<UserRetrievedDTO> {
    const newUser = await users.create(user);
    return newUser.toJSON() as UserRetrievedDTO;
  }

  async readById(id: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findByPk(id);
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readByEmail(email: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findOne({ where: { email } });
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readAll(): Promise<UserRetrievedDTO[]> {
    const allUsers = await users.findAll();
    return allUsers.map((user) => user.toJSON() as UserRetrievedDTO);
  }

  async update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]> {
    const transaction = await this.db.transaction();
    try {
      const [updatedCount, updatedUsers] = await users.update(user, {
        where: { user_id: id },
        returning: true,
        transaction: transaction,
      });

      if (updatedCount > 1) {
        // Rollback if the count is unexpected (the actual fix would be to prevent this query from updating >1 in the first place,
        // but the rollback is the safety net).
        await transaction.rollback();
        throw new Error('Concurrency failure: More than one record updated.');
      }

      // COMMIT if successful
      await transaction.commit();

      return [updatedCount, updatedUsers.map((user) => user.toJSON() as UserRetrievedDTO)];
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  async delete(id: string): Promise<number> {
    const deletedCount = await users.destroy({ where: { user_id: id } });
    return deletedCount;
  }
}


// filepath: repositories\interfaces\i-hive-inspection-repository.ts


// filepath: repositories\interfaces\i-hive-repository.ts
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Interface for the Hive data access layer.
 * Manages CRUD operations for the 'hives' table.
 */
export interface IHiveRepository {
  /**
   * Creates a new hive record.
   * @param hive The data for the new hive, including the location_id.
   * @returns The created hive DTO.
   */
  create(hive: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO>;

  /**
   * Updates an existing hive record.
   * @param id The unique ID of the hive to update.
   * @param hive The partial update data.
   * @returns A tuple: [number of updated rows (should be 1), array of updated hive DTOs].
   */
  update(id: string, hive: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]>;

  /**
   * Retrieves a single hive by its ID.
   * @param hiveId The unique ID of the hive.
   * @param locationId The optional unique ID of the location.
   * @returns The hive DTO or null if not found.
   */
  findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null>;

  /**
   * Retrieves all hives associated with a specific location.
   * @param locationId The ID of the location.
   * @returns An array of hive DTOs.
   */
  findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]>;

  /**
   * Deletes a hive record by its ID.
   * @param hiveId The unique ID of the hive to delete.
   * @param locationId The optional unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  delete(hiveId: string, locationId?: string): Promise<number>;

  /**
   * Deletes a hive record by its ID.
   * @param locationId The unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  deleteAll(locationId: string): Promise<number>;
}


// filepath: repositories\interfaces\i-location-repository.ts
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

/**
 * Interface defining the data access operations for the Location model.
 * All location services will depend on this contract, not a concrete implementation.
 */
export interface ILocationRepository {
  create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO>;

  findById(id: string): Promise<LocationServiceRetrievedDTO | null>;

  findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]>;

  update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]>;

  delete(id: string): Promise<number>;
}


// filepath: repositories\interfaces\i-major-inspection-repository.ts


// filepath: repositories\interfaces\i-user-repository.ts
// import { users } from '../../database/models-ts/users.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export interface IUserRepository {
  create(user: UserCreationDTO): Promise<UserRetrievedDTO>;
  readById(id: string): Promise<UserRetrievedDTO | null>;
  readByEmail(email: string): Promise<UserRetrievedDTO | null>;
  readAll(): Promise<UserRetrievedDTO[]>;
  update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]>;
  delete(id: string): Promise<number>;
}


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router } from 'express';

import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { UserRepository } from '../repositories/implementations/user-repository.js';
import { UserService } from '../services/user-service.js';
//import { RegisterUserDto } from '../types/DTO/per-controller/dtos.js'; // Assuming these DTOs exist
import { RegisterUserIncomingDTO, LoginUserIncomingDTO, UpdateUserIncomingDTO } from '../controllers/dto/auth-controller.dto.js';

import { AuthController } from '../controllers/auth-controller.js';

import { isAuthenticated } from '../middleware/auth.js';

const authRouter = Router();

// --- DI SETUP ---
const userRepository = new UserRepository(); // Concrete implementation
const userService = new UserService(userRepository); // Inject Repository into Service
const authController = new AuthController(userService); // Inject Service into Controller
// --- END DI SETUP ---

const registerSchema = Joi.object<RegisterUserIncomingDTO>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required',
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
});

const loginSchema = Joi.object<LoginUserIncomingDTO>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required',
  }),
});

const updateSchema = Joi.object<UpdateUserIncomingDTO>({
  username: Joi.string().trim().optional(),
  email: Joi.string().email().optional().messages({
    'string.email': 'Email must be a valid email address',
  }),
  password: Joi.string().min(6).optional().messages({
    'string.min': 'Password must be at least 6 characters long',
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',
  validate({ body: registerSchema }), // Apply Joi validation middleware
  authController.register // Call the controller function here
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // Apply Joi validation middleware
  authController.login // Call the controller function here
);

authRouter.get('/me', isAuthenticated, authController.getMe);

authRouter.post(
  '/logout',
  isAuthenticated, // Optional: You might want to ensure only authenticated users can "logout"
  // Or, if you simply want to provide a path to clear client-side token, it can be without auth.
  authController.logout
);

authRouter.put('/me', isAuthenticated, validate({ body: updateSchema }), authController.updateMe);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;


// filepath: routes\hiveInspectionRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { checkMajorInspectionOwnershipForHive as checkMajorInspectionOwnership } from '../middleware/ownership.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
//import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';
import { HiveInspectionController } from '../controllers/hive-inspection-controller.js';

const hiveInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for HiveInspection ---
// const beehiveConfigurationSchema = Joi.object({
//   type: Joi.string().required(),
//   numberOfFrames: Joi.number().integer().min(1).required(),
//   materials: Joi.array().items(Joi.string()).optional(),
//   isInsulated: Joi.boolean().optional(),
// });

const createHiveInspectionSchema = Joi.object({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  // Use the exact snake_case names from your model
  hive_id: Joi.string().uuid().required(),
  inspection_time: Joi.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .required(),
  colony_health_status_id: Joi.number().integer().required(),
  num_chambers: Joi.number().integer().min(1).required(),
  brood_chambers_count: Joi.number().integer().min(1).required(),
  supers_count: Joi.number().integer().min(0).required(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().required(),
  approx_honey_weight_kg: Joi.number().integer().min(0).max(50).optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().min(0).max(10).optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().optional().allow(null),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<hive_inspectionsAttributes>({
  hive_id: Joi.string().trim().optional(),
  inspection_time: Joi.string()
    .pattern(/^([01]\d|2[0-3]):([0-5]\d)$/)
    .optional()
    .messages({
      'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)',
    }),
  colony_health_status_id: Joi.number().integer().optional(),
  num_chambers: Joi.number().integer().min(1).optional(),
  brood_chambers_count: Joi.number().integer().min(1).optional(),
  supers_count: Joi.number().integer().min(0).optional(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().optional(),
  approx_honey_weight_kg: Joi.number().integer().optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const specificHiveInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hiveInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const rootHiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  // Add the locationId to the schema to allow it
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
    body: createHiveInspectionSchema,
  }),
  // (req, res, next) => {
  //   console.log('Validation successful');
  //   next();
  // },
  checkMajorInspectionOwnership, // Verify parent MajorInspection ownership
  HiveInspectionController.createHiveInspection
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
  }),

  checkMajorInspectionOwnership,
  (req, res, next) => {
    console.log('****** GET /  ownership verified *****');
    next();
  },
  HiveInspectionController.getHiveInspectionsByMajorInspectionId
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** GET /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.getHiveInspectionById
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** PUT /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({
    params: specificHiveInspectionParamsSchema,
    body: updateHiveInspectionSchema,
  }),
  checkMajorInspectionOwnership,
  HiveInspectionController.updateHiveInspection
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** DELETE /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.deleteHiveInspection
);

export default hiveInspectionRouter;


// filepath: routes\hiveRoutes.ts
/* define endpoints, joi schemas, and controllers for hive inspections */
import { Router } from 'express';
import Joi from 'joi';

import { HiveController } from '../controllers/hive-controller.js';
import { HiveRepository } from 'repositories/implementations/hive-repository.js';
import { HiveService } from 'services/hive-service.js';
//import { hivesAttributes } from '../database/models-ts/hives.js';
import { isAuthenticated } from '../middleware/auth.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { validate } from '../middleware/validation.js';
import { HiveControllerCreateDTO, HiveControllerCreateStrongDTO, HiveControllerUpdateDTO } from 'controllers/dto/hive-controller.dto.js';

const hiveRouter = Router({ mergeParams: true });
// --- DI SETUP ---
const hiveRepository = new HiveRepository(database); // Concrete implementation
const hiveService = new HiveService(hiveRepository); // Inject Repository into Service
const hiveController = new HiveController(hiveService); // Inject Service into Controller
// --- END DI SETUP ---

const createHivesBodySchema = Joi.object<HiveControllerCreateStrongDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .required(),
  hive_name: Joi.string().min(2).max(50).required(),
  description: Joi.string().min(2).max(200).required(),
  is_active: Joi.boolean().required(),
});

const updateHivesBodySchema = Joi.object<HiveControllerUpdateDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .optional(),
  hive_name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().min(2).max(200).optional(),
  is_active: Joi.boolean().optional(),
});

const createHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const updateHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hive_id: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

//GET /api/v1/locations/:locationId/hives - Get all hives for a specific location.
hiveRouter.get(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching hives...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.getAllHives
);
//POST /api/v1/locations/:locationId/hives - Create a new hive within a specific location.
hiveRouter.post('/', isAuthenticated, validate({ params: createHiveParamSchema, body: createHivesBodySchema }), hiveController.createHive);

//GET /api/v1/locations/:locationId/hives/:hiveId - Get a specific hive.
hiveRouter.get(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.getHiveById
);

//PUT /api/v1/locations/:locationId/hives/:hiveId - Update a specific hive.
hiveRouter.put(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Updating specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema, body: updateHivesBodySchema }),
  hiveController.updateHive
);

//DELETE /api/v1/locations/:locationId/hives/:hiveId - Delete a specific hive.
hiveRouter.delete(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.deleteHive
);
hiveRouter.delete(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting all hives ...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.deleteAllHives
);

export default hiveRouter;


// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { LocationController } from '../controllers/location-controller.js';
import { LocationService } from '../services/location-service.js';
import { LocationRepository } from '../repositories/implementations/location-repository.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { LocationControllerUpdateInputDTO, LocationControllerCreateInputDTO } from '../controllers/dto/location-controller.dto.js';
//import { createLocation, getLocations, getLocationById, updateLocation, deleteLocation, getMapData } from '../controllers/location-controller.js'; // <-- Import the controller functions

//import { locationsAttributes } from '../database/models-ts/locations.js';

import majorInspectionRouter from './majorInspectionRoutes.js';
import hiveRouter from './hiveRoutes.js';
import { checkLocationOwnership } from 'middleware/ownership.js';

const locationRouter = Router();

// --- DI SETUP ---
const locationRepository = new LocationRepository(database); // Concrete implementation
const locationService = new LocationService(locationRepository); // Inject Repository into Service
const locationController = new LocationController(locationService); // Inject Service into Controller
// --- END DI SETUP ---

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<LocationControllerCreateInputDTO>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  notes: Joi.string().trim().max(500).allow(null, ''),
  country: Joi.string().trim().max(100).allow(null, ''),
});

const updateLocationSchema = Joi.object<LocationControllerUpdateInputDTO>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  notes: Joi.string().trim().max(500).allow(null, '').optional(),
  country: Joi.string().trim().max(100).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(), // Validate as UUID
});

// Mount nested major inspection routes
locationRouter.use('/:locationId/major-inspections', isAuthenticated, majorInspectionRouter);
locationRouter.use('/:locationId/hives', isAuthenticated, hiveRouter);

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  locationController.createLocation
);

// GET /api/locations/map - Get map data
locationRouter.get('/map', isAuthenticated, locationController.getMapData);

// GET /api/locations - Get all locations for the authenticated user
locationRouter.get('/', isAuthenticated, locationController.getAllLocations);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  checkLocationOwnership(locationService),
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.getLocationById
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  locationController.updateLocation
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.deleteLocation
);

// // Mount nested major inspection routes
// locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);

export default locationRouter;


// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { NextFunction, Response, Request, Router } from 'express';
import Joi from 'joi';

//import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';

import { createMajorInspection, getMajorInspections, getMajorInspectionById, updateMajorInspection, deleteMajorInspection } from '../controllers/major-inspection-contoller.js';
import { checkLocationOwnership } from '../middleware/ownership.js';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import hiveInspectionRouter from './hiveInspectionRoutes.js';

const majorInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspection_date: Joi.date().iso().required(),
  general_notes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  inspection_date: Joi.date().iso().optional(),
  general_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const loggging = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Logging major inspections requests ...', req.params, req.body);
  next();
};
//majorInspectionRouter.use(loggging);

// Mount nested major inspection routes
// majorInspectionRouter.use('/:majorInspectionId/hive-inspections', (req, res, next) => {
//   next();
// });
majorInspectionRouter.use('/:majorInspectionId/hive-inspections', hiveInspectionRouter);

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/',
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  checkLocationOwnership, // Ensure the location belongs to the user //createMajorInspection
  createMajorInspection
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get('/', checkLocationOwnership, getMajorInspections);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, getMajorInspectionById);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/:majorInspectionId',
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  checkLocationOwnership,
  updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, deleteMajorInspection);

export default majorInspectionRouter;


// filepath: routes\manual-tests\hiveInspections\hiveInspections.http
###
# Hive Inspections API Tests
#
# This file assumes you have already run the `major-inspections.http` tests and have a valid token, hive ID, and major inspection ID.
# The Hive API tests might be useful for getting the hive_id.
#
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@baseUrl = http://localhost:3000/api/v1/locations/{{locationId}}
# @token = <paste_your_token_here>
# @majorInspectionId = <paste_your_major_inspection_id_here>
# @hiveId = <paste_your_hive_id_here> 
# @token =
@majorInspectionId = 3dd79818-4e59-49d7-bb82-a65b0145d87c

@hiveId = ec5ffc71-b700-4837-acdf-4dfa5b1b73e3



### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### get token
@token = {{authenticate.response.body.token}}

###
# Create a new hive inspection for a major inspection.
# @name createHiveInspection
POST {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_id": "bfdd1ef0-0cc1-4886-9ba9-572e60a70ef0",
  "inspection_time": "14:41",
  "colony_health_status_id": 1,
  "num_chambers": 3,
  "brood_chambers_count": 2,
  "supers_count": 1,
  "brood_frames_count": 15,
  "brood_percentage": 79,
  "queen_status_id": 2,
  "approx_honey_weight_kg": 10,
  "drone_comb_frames_count": 2,
  "drone_comb_percentage": 5.0,
  "sugar_feed_added": false,
  "sugar_feed_quantity_kg": null,
  "queen_excluder_present": true,
  "num_varroa_mites_found": 5,
  "varroa_treatment_id": 1,
  "varroa_treatment_dosage": "100ml",
  "raising_new_queen": false,
  "queen_cell_age_days": null,
  "queen_cell_status_id": null,
  "other_notes": "The colony seems strong and healthy. Found a few varroa mites, will continue to monitor."
}

###
# Get all hive inspections for a major inspection.
# @name getHiveInspections
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Authorization: Bearer {{token}}

###
# Get a specific hive inspection.
#
# To run this, first run the `createHiveInspection` request and copy the `hive_inspection_id`.
# @hiveInspectionId = <paste_hive_inspection_id_here>
@hiveInspectionId = {{createHiveInspection.response.body.hive_inspection_id}}
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId`.
PUT {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "brood_percentage": 33,
  "approx_honey_weight_kg": 25,
  "num_chambers": 8,
  "drone_comb_frames_count": 3,  
  "colony_health_status_id": 3,
  "other_notes": "Updated notes: The colony is doing well, but I noticed a few varroa mites."
}

###
# Delete a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\hives\hives.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@hiveId = 01127c49-7230-4405-9ef3-bba06e71a968

// --- Helper Request: Create a Hive (if you need one) ---
// @name createHive
POST {{baseUrl}}/locations/{{locationId}}/hives
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My SIXTH Hive",
  "description": "Newly established hive with a strong queen.",
  "is_active": true
}

###

// --- 1. GET all Hives for a Location ---
// @name getAllHives
GET {{baseUrl}}/locations/{{locationId}}/hives
Authorization: Bearer {{token}}

###

// --- 2. GET a single Hive by ID ---
// @name getHiveById
GET {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

###

// --- 3. Update an existing Hive ---
// @name updateHive
PUT {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My Updated Hive Name",
  "description": "Updated notes after a routine check."
}

###

// --- 4. DELETE a Hive ---
// @name deleteHive
DELETE {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

// filepath: routes\manual-tests\locations\locations.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI


### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

###
# @name createLocation
# Creates a new location.
@token2 = {{authenticate.response.body.token}}
POST {{baseUrl}}/locations
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Apiary 1",
  "address": "123 Main St, Anytown",
  "latitude": 46.0569,
  "longitude": 14.5058,
  "notes": "Main apiary location.",
  "country": "Slovenia"
}

###
# Get all locations for the authenticated user.
# @name getLocations
GET {{baseUrl}}/locations
Authorization: Bearer {{authenticate.response.body.token}}

###
# Get map data for all beehive locations.
# @name getMapData
GET {{baseUrl}}/locations/map
Authorization: Bearer {{token2}}

###
# Get a specific location by ID.
#
# To run this, first run the `createLocation` request and copy the `location_id` from the response.
# @locationId = <paste_location_id_here>
@locationId = {{createLocation.response.body.data.location_id}}
# Use the commented line below if you prefer to set the ID manually
# @locationId =
GET {{baseUrl}}/locations/{{locationId}}
Authorization: Bearer {{token}}

###
# Update a specific location by ID.
#
# To run this, you must first have a valid `locationId` from the `createLocation` request.
PUT {{baseUrl}}/locations/{{locationId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Main Apiary - Updated",
  "notes": "Updated notes for the main apiary."
}

###
# Delete a specific location by ID.
#
# To run this, you must have a valid `locationId` that has not already been deleted.
#DELETE {{baseUrl}}/locations/{{locationId}}
DELETE {{baseUrl}}/locations/2af520b3-c43a-47a8-9372-f1a3e819513b
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\majorInspections\majorInspections.http
###
# Major Inspections API Tests
#
# This file assumes you have already run the `locations.http` tests and have a valid token and location ID.
#
@baseUrl = http://localhost:3000/api/v1
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
# @locationId = <paste_your_location_id_here>

@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8

###
# Create a new major inspection for a specific location.
# @name createMajorInspection
POST {{baseUrl}}/locations/{{locationId}}/major-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "inspection_date": "2024-09-08T10:00:00.000Z",
  "general_notes": "This is temporary test foobar record."
}

###
# Get all major inspections for a specific location.
# @name getMajorInspections
GET {{baseUrl}}/locations/{{locationId}}/major-inspections
Authorization: Bearer {{token}}

###
# Get a specific major inspection by ID.
#
# To run this, first run the `createMajorInspection` request and copy the `major_inspection_id`.
# @majorInspectionId = <paste_major_inspection_id_here>
@majorInspectionId = {{createMajorInspection.response.body.data.major_inspection_id}}
GET {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId`.
PUT {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "general_notes": "Updated notes: Queen seems healthy."
}

###
# Delete a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
#DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/dee8f057-9efb-463b-93da-76ccfad03a54
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\users\user_requests.http
### Check HEALTH Endpoint
# @name checkHealth
GET http://localhost:3000/api/v1/health
Content-Type: application/json    


### Register a New User
###
# @name registerUser
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "TonyClark",
  "email": "tonyclark@gmail.com",
  "password": "password1234"
}

### Register a User with Existing Email (Expected: 409 Conflict)
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "anotheruser",
  "email": "test2@example.com",
  "password": "anotherpassword"
}


### Login with Valid Credentials
# @name loginValidUser
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json
Accept: application/json

{
    "email" : "tonyclark@gmail.com",    
    "password" : "password1234"
}

### Login with Invalid Password (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "tonyclark@gmail.com",
  "password": "password1234"
} 

### Login with Non-Existent Email (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez55@gmail.com",
    "password" : "Cada_73NUN5"
}

### Get Current User (without token - Expected: 401 Unauthorized)
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json

### Get Current User (with valid token)
# Replace {{authToken}} with the token received from a successful login request
@token2 = {{loginValidUser.response.body.token}}
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json
Authorization: Bearer {{token2}}


### Logout User
# This request is mainly for demonstration/logging purposes on the server.
# The real logout happens on the client by deleting the token.
POST http://localhost:3000/api/v1/auth/logout
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later

const startServer = async () => {
  try {
    const testVar: any = 'This should trigger a warning';
    // 1. Connect to the database
    console.log('Attempting to connect to the database...');
    await connectDB();
    console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`âš¡ï¸[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\nðŸ™ˆ-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('âŒ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log('startServer();');
startServer();


// filepath: services\dto\hive-inspection.dto.ts
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

export type HiveInspectionServiceCreateDTO = Omit<hive_inspectionsAttributes, 'hive_inspection_id' | 'created_at' | 'updated_at'>;
export type HiveInspectionServiceUpdateDTO = Partial<HiveInspectionServiceCreateDTO>;
export type HiveInspectionServiceRetrievedDTO = hive_inspectionsAttributes;


// filepath: services\dto\hive-service.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// Input for creating a new hive (omits ID and timestamps)
export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Input for updating a hive (all fields optional, omits foreign key and IDs)
export type HiveServiceUpdateDTO = Partial<HiveServiceCreateDTO>;

// Output/Retrieved DTO for a hive
export type HiveServiceRetrievedDTO = hivesAttributes;


// filepath: services\dto\location-service.dto.ts
import { locationsAttributes } from '../../database/models-ts/locations.js';

// Location domain types - for creating, updating, and retrieving location data
// The service layer uses these DTOs to enforce data shape and decouple from Sequelize's model attributes.

// Data required to create a new location
export type LocationServiceCreateDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;

// Data used to update an existing location (all fields optional)
export type LocationServiceUpdateDTO = Partial<Omit<LocationServiceCreateDTO, 'user_id'>>;

// Data shape of a fully retrieved location record
export type LocationServiceRetrievedDTO = locationsAttributes;


// filepath: services\dto\major-inspection-service.dto.ts
import { major_inspectionsAttributes, major_inspections } from 'database/models-ts/major-inspections.js';

export type MajorInspectionServiceCreateDTO = Omit<major_inspectionsAttributes, 'major_inspection_id' | 'created_at' | 'updated_at'>;
export type MajorInspectionServiceUpdateDTO = Partial<MajorInspectionServiceCreateDTO>;
export type MajorInspectionServiceRetrievedDTO = major_inspectionsAttributes;


// filepath: services\dto\user-service.dto.ts
import { usersAttributes } from '../../database/models-ts/users.js';

// User domain types - for creating, updating, and retrieving user data ... called on the services layer
export type UserCreationDTO = Omit<usersAttributes, 'user_id' | 'created_at' | 'updated_at' | 'google_id' | 'linkedin_id'>;
export type UserUpdateDTO = Partial<UserCreationDTO>;
export type UserRetrievedDTO = Omit<usersAttributes, 'google_id' | 'linkedin_id'>;


// filepath: services\hive-inspection-service.ts
// src/services/hiveInspectionService.ts

import { hive_inspections } from '../database/models-ts/hive_inspections.js';
//import { major_inspections } from 'database/models-ts/major_inspections.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js'; // Importing the type for hive inspection attributes
//import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
//import { HiveInspectionCreationAttributes } from '../database/models-obsolete/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(hiveInspectionData: hive_inspectionsAttributes): Promise<hive_inspectionsAttributes> {
    const newHiveInspection = await hive_inspections.create({ ...hiveInspectionData });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(majorInspectionId: string): Promise<hive_inspectionsAttributes[]> {
    const hiveInspections = await hive_inspections.findAll({ where: { major_inspection_id: majorInspectionId }, order: [['created_at', 'ASC']] });
    return hiveInspections.map((hi) => hi.toJSON());
  }

  public static async getHiveInspectionById(id: string, majorInspectionId: string): Promise<hive_inspectionsAttributes | null> {
    const hiveInspection = await hive_inspections.findOne({ where: { hive_inspection_id: id, major_inspection_id: majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(id: string, majorInspectionId: string, updateData: Partial<hive_inspectionsAttributes>): Promise<hive_inspectionsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await hive_inspections.update(updateData, {
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(id: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await hive_inspections.destroy({
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
    });
    return deletedRows > 0;
  }

  /**
   * Retrieves hive inspections for a specific hive, ensuring both the hive itself
   * and its associated major inspection belong to the given location.
   * This enforces a strong authorization chain and filters results precisely.
   *
   * @param locationId The ID of the location to filter by.
   * @param hiveNumber The ID of the hive to filter by (corresponds to hive_id).
   * @returns A promise that resolves to an array of hive inspection attributes.
   */
  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<hive_inspectionsAttributes[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await hive_inspections.findAll({
      include: [
        {
          // 1. Include the 'majorInspection' association
          // This ensures the hive inspection is linked to a major inspection
          // that belongs to the specified location.
          association: 'majorInspection', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          where: { location_id: locationId }, // Filter major_inspections by their location_id column
          required: true, // Perform an INNER JOIN, meaning the major inspection must exist and match the locationId
        },
        {
          // 2. Include the 'hive' association
          // This ensures the hive inspection is linked to a hive
          // that also belongs to the specified location.
          association: 'hive', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          required: true, // Perform an INNER JOIN, meaning the hive must exist
          where: { location_id: locationId }, // Filter hives by their location_id column
        },
      ],
      where: {
        // 3. Filter the primary hive_inspections by the specific hive_id
        hive_id: hiveNumber,
      },
      order: [['created_at', 'ASC']],
    });
    return hiveInspections.map((hi) => hi.toJSON());
  }
}


// filepath: services\hive-service.ts
// src/services/hiveService.ts

//import { hives, hivesAttributes } from '../database/models-ts/hives.js';
import { IHiveRepository } from '../repositories/interfaces/i-hive-repository.js'; // repositories/interfaces/i-hive-repository.js';
import { HiveInspectionServiceRetrievedDTO } from './dto/hive-inspection.dto.js';
//import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';
//import { locations } from '../database/models-ts/locations.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';

export class HiveService {
  private _hiveRepository: IHiveRepository;

  constructor(private hiveRepository: IHiveRepository) {
    this._hiveRepository = hiveRepository;
  }

  // TODO MODIFY METHODS TO USE REPOSITORY INSTEAD OF DIRECT MODEL ACCESS
  /**
   * Retrieves all hives associated with a specific location, ensuring the location belongs to the user.
   * @param locationId The ID of the location to retrieve hives for.
   * @returns A promise that resolves to an array of hive objects.
   */
  public async getHivesByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const hivesFound: HiveServiceRetrievedDTO[] = await this._hiveRepository.findAllByLocationId(locationId); //  .findAll({

    return hivesFound;
  }

  /**
   * Retrieves a single hive by its ID and location ID, ensuring the location belongs to the user.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to retrieve.
   * @returns A promise that resolves to the hive object or null if not found.
   */
  public async getHiveById(locationId: string, hiveId: string): Promise<HiveServiceRetrievedDTO | null> {
    const hive = await this._hiveRepository.findById(hiveId, locationId); // .findOne({

    return hive ? hive : null;
  }

  /**
   * Creates a new hive for a given location.
   * @param hiveData The data for the new hive.
   * @returns A promise that resolves to the newly created hive object.
   */
  public async createHive(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    console.log('Service Creating hive...', hiveData);

    const newCreatedHive = await this._hiveRepository.create(hiveData);
    return newCreatedHive; //.toJSON();
  }

  /**
   * Updates an existing hive.
   * @param hiveId The ID of the hive to update.
   * @param updateData The data to update.
   * @returns A promise that resolves to the updated hive object or null if not found.
   */
  public async updateHive(hiveId: string, updateData: HiveServiceUpdateDTO): Promise<HiveServiceRetrievedDTO | null> {
    // Check if the hive exists and belongs to the user and location
    const hiveToUpdate = await this._hiveRepository.findById(hiveId);

    if (!hiveToUpdate) {
      return null;
    }

    const [numberOfAffectedRows, affectedRows] = await this._hiveRepository.update(hiveId, updateData);

    if (numberOfAffectedRows === 0) {
      return null;
    }

    return affectedRows[0];
  }

  /**
   * Deletes a hive by its ID and location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to delete.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteHive(locationId: string, hiveId: string): Promise<boolean> {
    console.log('Service (deleteHive) Deleting hive...', locationId, hiveId);

    // if the location is given, the Hive ID must belong to that Location
    const hiveToDelete = await this._hiveRepository.findById(hiveId, locationId);

    if (!hiveToDelete) {
      return false;
    }

    console.log('Service (deleteHive) Found hive to delete:', hiveToDelete);

    const deletedRows = await this.hiveRepository.delete(hiveId, locationId);

    return deletedRows > 0;
  }

  /**
   * Deletes all hives by their location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteAllHives(locationId: string): Promise<boolean> {
    const deletedRows = await this._hiveRepository.deleteAll(locationId);

    return deletedRows > 0;
  }
}


// filepath: services\location-service.ts
import { ILocationRepository } from '../repositories/interfaces/i-location-repository.js';
import { LocationServiceRetrievedDTO, LocationServiceCreateDTO, LocationServiceUpdateDTO } from './dto/location-service.dto.js';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

export class LocationService {
  private readonly locationRepository: ILocationRepository;

  // Dependency Injection: Injecting the repository contract
  constructor(locationRepository: ILocationRepository) {
    this.locationRepository = locationRepository;
  }

  /**
   * Creates a new location entry.
   * @param locationData The data for the new location, including user_id.
   * @returns The created location DTO.
   */
  public async createLocation(locationData: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    // No complex business logic here yet (e.g., uniqueness checks), so delegate directly.
    return this.locationRepository.create(locationData);
  }

  /**
   * Retrieves all locations belonging to a specific user.
   * @param userId The ID of the owner.
   * @returns An array of location DTOs.
   */
  public async getAllLocationsByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    return this.locationRepository.findAllByUserId(userId);
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public async getLocationById(locationId: string): Promise<LocationServiceRetrievedDTO | null> {
    const _loc = await this.locationRepository.findById(locationId);
    return _loc;
  }

  /**
   * Updates an existing location.
   * @param locationId The ID of the location to update.
   * @param updateData The fields to update.
   * @returns The updated location DTO.
   */
  public async updateLocation(locationId: string, updateData: LocationServiceUpdateDTO): Promise<LocationServiceRetrievedDTO> {
    // Check if the location exists before updating
    const existingLocation = await this.locationRepository.findById(locationId);
    if (!existingLocation) {
      const error = new Error('Location not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    const [updatedCount, updatedLocations] = await this.locationRepository.update(locationId, updateData);

    if (updatedCount > 1) {
      // This error indicates a serious issue in the repository or ORM logic
      const error = new Error(`Failed to update location with ID ${locationId}. Concurrency issue suspected.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      // Should not happen after the initial existence check, but is a safety net
      const error = new Error(`Location with ID ${locationId} not found during update.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    // Return the single updated location DTO
    return updatedLocations[0];
  }

  /**
   * Deletes a location.
   * @param locationId The ID of the location to delete.
   * @returns The number of records deleted (should be 1).
   */
  public async deleteLocation(locationId: string): Promise<number> {
    // Optional: Add pre-delete check or business logic here (e.g., cannot delete if hives are present)
    return this.locationRepository.delete(locationId);
  }

  /**
   * Checks if a location is owned by a specific user. Helpful for authorization middleware checks
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns True if the location is owned by the user, false otherwise.
   */
  public async checkLocationOwnership(locationId: string, userId: string): Promise<boolean> {
    const location = await this.locationRepository.findById(locationId);
    return location ? location.user_id === userId : false;
  }
}


// filepath: services\major-inspection-service.ts
// src/services/majorInspectionService.ts

//import { MajorInspection } from '../database/models-obsolete/MajorInspection.js'  ;
import { major_inspections } from '../database/models-ts/major-inspections.js'; // Updated to use the new TypeScript model
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js'; // Importing the type for major inspection attributes
import { locations } from '../database/models-ts/locations.js';
//import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
//import {MajorInspectionCreationAttributes} from '../database/models/MajorInspection'; // Import the creation attributes type
//import { CreateMajorInspectionDto, UpdateHiveInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class MajorInspectionService {
  public static async createMajorInspection(location_id: string, inspectionData: major_inspectionsAttributes): Promise<major_inspectionsAttributes> {
    console.log('Creating major inspection with data:', location_id, inspectionData);
    // Convert inspectionDate string from DTO to a Date object
    const newInspectionDate = new Date(inspectionData.inspection_date);

    // Create the object to be passed to Sequelize.create()
    const inspectionDataForCreation = {
      ...inspectionData,
      //inspection_date: new Date(inspectionData.inspection_date),
      location_id: location_id, // Ensure the location_id is set correctly
    };

    console.log('Inspection data for creation via sequelize:', inspectionDataForCreation);
    const newMajorInspection = await major_inspections.create({
      ...inspectionDataForCreation,
    });

    return newMajorInspection.toJSON();
  }

  public static async getMajorInspectionsByLocationId(locationId: string): Promise<major_inspectionsAttributes[]> {
    const majorInspections = await major_inspections.findAll({
      where: { location_id: locationId },
      order: [['inspection_date', 'DESC']],
    });
    return majorInspections.map((mi) => mi.toJSON());
  }

  public static async getMajorInspectionById(
    // ZAKAJ MI TO 2x klice z razlicnim vrstnim redom argumentov???????????
    userId: string, // Check ownership by userId
    majorInspectionId: string,
    locationId: string
  ): Promise<major_inspectionsAttributes | null> {
    console.log(`Fetching major inspection by ID...\nmajorInspectionId: ${majorInspectionId}\nlocationId: ${locationId}\nuserId: ${userId}`);

    try {
      const majorInspection = await major_inspections.findOne({
        where: { major_inspection_id: majorInspectionId, location_id: locationId },
      });
    } catch (error) {
      console.error('TEST Error fetching major inspection by ID:', error);
    }

    const majorInspection = await major_inspections.findOne({
      where: { major_inspection_id: majorInspectionId, location_id: locationId },
      include: [
        {
          association: 'majorInspection_location', // Make sure this matches your association name in the MajorInspection model

          where: { location_id: locationId, user_id: userId }, // Ensure the location belongs to the user
          required: true,
        },
      ],
    });
    return majorInspection ? majorInspection.toJSON() : null;
  }

  public static async updateMajorInspection(
    locationId: string,
    majorInspectionId: string,
    updateData: major_inspectionsAttributes
    // Partial<MajorInspectionInterface>
  ): Promise<major_inspectionsAttributes | null> {
    console.log('Updating major inspection service..', majorInspectionId, locationId, updateData);
    const [numberOfAffectedRows, affectedRows] = await major_inspections.update(updateData, {
      where: { location_id: locationId, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteMajorInspection(userId: string, locationId: string, majorInspectionId: string): Promise<boolean> {
    console.log('Deleting major inspection service..', majorInspectionId, locationId, userId);
    // Step 1: Find the major inspection ID that matches all criteria
    const majorInspectionToDelete = await major_inspections.findOne({
      attributes: ['major_inspection_id'], // Only select the ID to minimize data transfer
      where: {
        major_inspection_id: majorInspectionId,
      },
      include: [
        {
          model: locations,
          //as: 'location', // Ensure this matches your association alias
          as: 'majorInspection_location',
          attributes: [],
          where: {
            location_id: locationId,
            user_id: userId, // Ensure the location belongs to the user
          },
          required: true, // This acts as an INNER JOIN, ensuring all conditions must be met
        },
      ],
    });

    if (!majorInspectionToDelete) {
      // No matching major inspection found for the given user, location, and majorInspectionId
      return false;
    }

    // Step 2: Delete the identified major inspection
    const deletedRows = await major_inspections.destroy({
      where: {
        major_inspection_id: majorInspectionToDelete.toJSON().major_inspection_id,
      },
    });

    return deletedRows > 0;
  }
}


// filepath: services\user-service.ts
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user creation attributes
import { IUserRepository } from '../repositories/interfaces/i-user-repository.js'; // The contract
import { UserRetrievedDTO, UserCreationDTO, UserUpdateDTO } from './dto/user-service.dto.js'; // The data shapes
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

// This class handles business logic (e.g., uniqueness check, error handling). No direct access to DB, just through repository.
export class UserService {
  private readonly userRepository: IUserRepository;
  constructor(userRepository: IUserRepository) {
    this.userRepository = userRepository;
  }

  public async findUserByEmail(email: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readByEmail(email);
  }

  public async findUserById(id: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readById(id);
  }

  public async createUser(userData: UserCreationDTO): Promise<UserRetrievedDTO> {
    // Check if user already exists (Business Logic)
    const existingUser = await this.userRepository.readByEmail(userData.email);
    if (existingUser) {
      // Throw a specific error that the Controller/ErrorHandler can catch
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = httpStatus.CONFLICT; // 409
      throw error;
    }

    // Delegate the creation to the repository (Data Access)
    return this.userRepository.create(userData);
  }

  public async updateUser(id: string, userData: Partial<UserUpdateDTO>): Promise<UserRetrievedDTO> {
    // Check if user exists
    const existingUser = await this.userRepository.readById(id);
    if (!existingUser) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Delegate the update to the repository (Data Access)
    const [updatedCount, updatedUsers] = await this.userRepository.update(id, userData);

    if (updatedCount > 1) {
      const error = new Error(`Failed to update user with ID ${id}.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      const error = new Error(`User with ID ${id} not found.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    return updatedUsers[0]; // decide for later if you want to return array or single object
  }
}


// filepath: src-summary3.txt
// filepath: .env
# Environment variables for MyHives App
PORT=3000

NODE_ENV=development
API_BASE_URL=http://localhost:3000/api

# Database Configuration
DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=Cada_2068_new # <--- IMPORTANT: Replace with your actual password!
DB_NAME=myhives_db                     # <--- IMPORTANT: Replace with the database name you created!

DATABASE_URL=postgresql://postgres:Cada_2068_new@localhost:5432/myhives_db
JWT_SECRET=my_jwt_super_dupper_secret_key


# Google OAuth Credentials
GOOGLE_CLIENT_ID="your_google_client_id"
GOOGLE_CLIENT_SECRET="your_google_client_secret"

# LinkedIn OAuth Credentials
LINKEDIN_CLIENT_ID="your_linkedin_client_id"
LINKEDIN_CLIENT_SECRET="your_linkedin_client_secret"

# Frontend URL for CORS and OAuth redirects
FRONTEND_URL="http://localhost:5173" # Or your deployed frontend URL


// filepath: appExpressInstance.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import 'reflect-metadata';
import config from './config/index.js';
import errorHandler, { CustomError } from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
import authRoutes from './routes/authRoutes.js';
import locationRoutes from './routes/locationRoutes.js';
//import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
//  import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
// import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();
const apiRouter = express.Router(); // Create a new router instance

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(
  cors({
    origin: config.frontendUrl, // Allow requests from your frontend URL
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true, // Allow cookies to be sent
  })
);

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// Mount your API router on the main app
app.use('/api/v1', apiRouter);

// --- Routes ---
// Basic health check route
apiRouter.get('/health', (req: Request, res: Response) => {
  console.log('ðŸš‘ Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');

// Mount your API routes here
apiRouter.use('/auth', authRoutes);
apiRouter.use('/locations', locationRoutes);

console.log('API routes mounted');
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 404; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;


// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url);

// Get the current directory's path
const __dirname = path.dirname(__filename);

// Load environment variables from .env file
const dotEnvConfigObject = dotenv.config({ path: path.resolve(__dirname, '../../src/.env') });
console.log('dotenv config object:', dotEnvConfigObject);

// Define the IConfig interface
interface IConfig {
  port: number;
  nodeEnv: string;
  databaseUrl: string;
  jwtSecret: string;
  googleClientId: string;
  googleClientSecret: string;
  linkedinClientId: string;
  linkedinClientSecret: string;
  frontendUrl: string; // For CORS and OAuth redirects
}

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port
};

console.log('Config loaded:', config);
console.log('config.jwtSecret:', config.jwtSecret);

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
  console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
}
if (!config.databaseUrl || config.databaseUrl === 'unknown') {
  console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
}
if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
  console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
}

export default config;


// filepath: controllers\auth-controller.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/user-service.js'; // New service

import config from '../config/index.js';
import httpStatus from 'http-status'; // Good practice for error codes

import { LoginUserOutgoingDTO, UserOutgoingDTO, UpdateUserIncomingDTO } from './dto/auth-controller.dto.js';
import { UserCreationDTO, UserUpdateDTO, UserRetrievedDTO } from '../services/dto/user-service.dto.js';

export class AuthController {
  private readonly _userService: UserService;

  constructor(userService: UserService) {
    this._userService = userService;
  }

  public register = async (req: Request, res: Response, next: NextFunction) => {
    console.log('Registering user:', req.body);
    try {
      const { username, email, password } = req.body;

      // Check if user already exists
      const existingUser: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (existingUser) {
        const error = new Error('User with this email already exists.') as CustomError;
        error.statusCode = httpStatus.CONFLICT; // 409
        throw error;
      }

      // Hash password
      const hashedPassword: string = await bcrypt.hash(password, 10); // Salt rounds = 10

      const userDataLoad: UserCreationDTO = { username, email, password_hash: hashedPassword };

      // Create user
      const newUser: UserRetrievedDTO = await this._userService.createUser(userDataLoad);

      // // Generate token (optional, could just return success message)
      // const token = generateToken({ userId: newUser.user_id! });
      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User registered successfully! Please log in.',
        user: {
          id: newUser.user_id!,
          username: newUser.username,
          email: newUser.email,
        },
      };

      res.status(201).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body;

      const user: UserRetrievedDTO | null = await this._userService.findUserByEmail(email);
      if (!user || !user.password_hash) {
        // Check for user existence and if they have a password (for traditional login)
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      // Compare password
      const isMatch: boolean = await bcrypt.compare(password, user.password_hash);
      if (!isMatch) {
        const error = new Error('Invalid credentials.') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      // Generate token
      const token: string = generateToken({ userId: user.user_id! });

      res.cookie('jwtcookie', token, {
        httpOnly: true,
        secure: config.nodeEnv === 'production',
        maxAge: 1000 * 3600 * 24 * 7, // 7 days in milliseconds
      });

      const responseObj: LoginUserOutgoingDTO = {
        success: true,
        message: 'Logged in successfully!',
        token,
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };

  public logout = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // In a stateless JWT system, the server doesn't need to do much for logout.
      // The client simply discards the token.
      // However, it's good practice to send a success message.

      // If using HTTP-only cookies for tokens, you'd clear the cookie here.
      // For example:
      res.clearCookie('jwtcookie'); // Assuming your JWT is in a cookie named 'jwtcookie'

      // You might also want to do some logging for audit purposes
      console.log(`User ${req.currentUser?.id || 'unknown'} logged out.`);

      res.status(200).json({
        success: true,
        message: 'Logged out successfully.',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('getMe called');
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      console.log('Current user ID:', req.currentUser.id);

      const user: UserRetrievedDTO | null = await this._userService.findUserById(req.currentUser.id);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      // Return user data (excluding password)
      const { password_hash: password, ...userData } = user;
      res.status(200).json({ success: true, user: userData });
    } catch (error) {
      next(error);
    }
  };

  public updateMe = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // req.user is set by the `authenticate` middleware
      if (!req.currentUser || !req.currentUser.id) {
        console.error('No currentUser found in request:', req.currentUser);
        const error = new Error('User not authenticated. - no currentUser') as CustomError;
        error.statusCode = 401;
        throw error;
      }

      const userId = req.currentUser!.id;
      const updateData: UpdateUserIncomingDTO = req.body;
      console.log('Update data received:', updateData);

      const readyToUpdate: UserUpdateDTO = { ...updateData, password_hash: updateData.password ? await bcrypt.hash(updateData.password, 10) : undefined };

      const user: UserRetrievedDTO = await this._userService.updateUser(userId, readyToUpdate);
      if (!user) {
        const error = new Error('User not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      console.log('User found:', user);

      const responseObj: UserOutgoingDTO = {
        success: true,
        message: 'User updated successfully!',
        user: {
          id: user.user_id!,
          username: user.username,
          email: user.email,
        },
      };

      res.status(200).json(responseObj);
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\dto\auth-controller.dto.ts
// incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

export interface RegisterUserIncomingDTO {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}
// outgoing DTO for authentication response

export interface UserOutgoingDTO {
  success: boolean;
  message: string;
  user: {
    id: string;
    username: string;
    email: string;
  };
}
// DTO for user update (all fields optional)

export interface UpdateUserIncomingDTO {
  username?: string;
  email?: string;
  password?: string;
}

export type GetMeUserOutgoingDTO = Omit<UserOutgoingDTO, 'pass'>;

// DTO for user login
export type LoginUserOutgoingDTO = UserOutgoingDTO & {
  token: string;
};

export interface LoginUserIncomingDTO {
  email: string;
  password: string;
}


// filepath: controllers\dto\hive-controller.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// these DTO types are used in the HiveRouter files to define the shape of request body data it expects to receive and send out
export type HiveControllerCreateDTO = Omit<hivesAttributes, 'hive_id' | 'location_id' | 'created_at' | 'updated_at'>;
export type HiveControllerUpdateDTO = Partial<HiveControllerCreateDTO>;
export type HiveControllerCreateStrongDTO = Omit<HiveControllerCreateDTO, 'description'> & Required<Pick<HiveControllerCreateDTO, 'description'>>;

// const some: HiveControllerCreateStrongDTO = {
//   hive_name: 'Test Hive',
//   description: 'A test hive description',
//   is_active: true,
// };


// filepath: controllers\dto\location-controller.dto.ts
// DTOs for the Controller Layer (API input/output)

// Incoming DTO for creating a new location (user_id is implicit from the authenticated user)
export interface LocationControllerCreateInputDTO {
  name: string;
  address?: string;
  country?: string;
  latitude?: number;
  longitude?: number;
  notes?: string;
}

// Incoming DTO for updating an existing location (all fields optional)
export type LocationControllerUpdateInputDTO = Partial<LocationControllerCreateInputDTO>;

// Outgoing DTO for a single location response
export interface LocationControllerOutputDTO {
  success: boolean;
  message: string;
  location: {
    id: string;
    userId: string;
    name: string;
    address?: string;
    country?: string;
    latitude?: number;
    longitude?: number;
    description?: string;
    createdAt: string;
    updatedAt: string;
  };
}

// Outgoing DTO for a list of locations
export interface LocationControllerListOutputDTO {
  success: boolean;
  message: string;
  locations: Array<LocationControllerOutputDTO['location']>;
}


// filepath: controllers\hive-controller.ts
import { Request, Response, NextFunction } from 'express';
import { HiveService } from '../services/hive-service.js';
import { CustomError } from '../middleware/errorHandler.js';
import { HiveServiceCreateDTO, HiveServiceRetrievedDTO, HiveServiceUpdateDTO } from 'services/dto/hive-service.dto.js';

export class HiveController {
  private _hiveService: HiveService;

  constructor(hiveService: HiveService) {
    this._hiveService = hiveService;
  }

  // Get all hives
  public getAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hives...', req.params);

      const location_id = req.params.locationId;

      const hives = await this._hiveService.getHivesByLocationId(location_id);

      res.status(200).json({
        success: true,
        message: 'Hives fetched successfully',
        data: hives,
      });
    } catch (error) {
      //res.status(500).json({ error: 'Failed to fetch hives' });
      next(error);
    }
  };

  // Get hive by ID
  public getHiveById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      console.log('Controller : Fetching hive...', req.params);

      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      const hive: HiveServiceRetrievedDTO | null = await this._hiveService.getHiveById(location_id, hive_id);

      if (!hive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({
        success: true,
        message: 'Hive fetched successfully',
        data: hive,
      });
    } catch (error) {
      next(error);
    }
  };

  public createHive = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      console.log('Creating hive...', req.params.locationId, req.body);
      const location_id = req.params.locationId;
      const hiveBodyData = req.body;

      const hiveData: HiveServiceCreateDTO = { ...hiveBodyData, locationId: location_id };

      console.log('Hive data:', hiveData);

      const newHiveCreated = await this._hiveService.createHive(hiveData);

      res.status(201).json(newHiveCreated);
    } catch (error) {
      next(error);
    }
  };

  // Update a hive
  public updateHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;
      const updatedHiveData = req.body;
      const updateHivePayload: HiveServiceUpdateDTO = { ...updatedHiveData, location_id: location_id };

      const updatedHive = await this._hiveService.updateHive(hive_id, updateHivePayload);
      if (!updatedHive) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive updated successfully',
        data: updatedHive,
      });
    } catch (error) {
      next(error);
    }
  };

  // Delete a hive
  public deleteHive = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.locationId;
      const hive_id = req.params.hive_id;

      console.log('Controller : Deleting hive...', req.params);

      const deleted = await this._hiveService.deleteHive(location_id, hive_id);
      if (!deleted) {
        const error = new Error('Hive not found.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Hive deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteAllHives = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const location_id = req.params.location_id;

      const deleted = await this._hiveService.deleteAllHives(location_id);
      if (!deleted) {
        const error = new Error('Hives not deleted.') as CustomError;
        error.statusCode = 404;
        throw error;
      }
      res.json({ message: 'Hives deleted successfully', success: true });
    } catch (error) {
      next(error);
    }
  };
} // end of class HiveController

// export default {
//   getAllHives,
//   getHiveById,
//   createHive,
//   updateHive,
//   deleteHive,
//   deleteAllHives,
// };


// filepath: controllers\hive-inspection-controller.ts
// src/controllers/hiveInspectionController.ts

import { Response, NextFunction } from 'express';
import { CustomRequest } from '../types/DTO/per-controller/custom-request.js';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { MajorInspectionService } from '../services/major-inspection-service.js'; // Needed for ownership check
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

//import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import { UniqueConstraintError } from 'sequelize';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    console.log('Controller: Creating hive inspection');
    try {
      const { majorInspectionId } = req.params;
      //const userId = req.currentUser!.id; // Authenticated user ID

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }
      console.log('Controller: Major inspection ownership verified:', majorInspection);

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: hive_inspectionsAttributes = { ...req.body, major_inspection_id: majorInspectionId }; // Ensure majorInspectionId from param is used
      console.log('Hive inspection data to be created:', hiveData);

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(hiveData);
      console.log('Controller: New hive inspection created on database:', newHiveInspection);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      if (error instanceof UniqueConstraintError) {
        // <-- Check for the specific error
        // A specific hive should only be inspected once per major inspection event
        const _err = new Error('A hive inspection for this hive already exists in this major inspection.') as CustomError;
        _err.statusCode = httpStatus.CONFLICT; // Return 409 Conflict
        next(_err);
      } else {
        next(error);
      }
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const updateData: hive_inspectionsAttributes = req.body; // Joi validation should ensure valid partial data

      console.log('------------------ Controller: Updating hive inspection with data:', updateData);

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      console.log('------------------ Controller: Updated hive inspection:', updatedHiveInspection);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed
      console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspection);
      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('hicMajor inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\location-controller.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/location-service.js'; // Import the service
import { LocationControllerOutputDTO, LocationControllerListOutputDTO, LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from './dto/location-controller.dto.js';
import { LocationServiceCreateDTO, LocationServiceRetrievedDTO, LocationServiceUpdateDTO } from '../services/dto/location-service.dto.js';
import { LocationServiceToControllerMapper } from '../utils/converters/location/service-to-controller.mapper.js';
import { LocationControllerToServiceMapper } from '../utils/converters/location/controller-to-service.mapper.js';
import httpStatus from 'http-status';

export class LocationController {
  private readonly _locationService: LocationService;

  constructor(locationService: LocationService) {
    this._locationService = locationService;
  }

  public createLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const incomingData: LocationControllerCreateInputDTO = req.body; // from controller dto interface definition

      const serviceDataParam: LocationServiceCreateDTO = LocationControllerToServiceMapper.toServiceCreateDTO(incomingData, userId);

      const location: LocationServiceRetrievedDTO = await this._locationService.createLocation(serviceDataParam);

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(location, 'Location created successfully!', true);

      return res.status(httpStatus.CREATED).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getAllLocations = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      // we serve the GET method .... for "/" all locations for that user
      const locations: LocationServiceRetrievedDTO[] = await this._locationService.getAllLocationsByUserId(req.currentUser.id);

      const responseData: LocationControllerListOutputDTO = LocationServiceToControllerMapper.toControllerListOutputDTO(locations, 'Locations retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public getLocationById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const specificLocation: LocationServiceRetrievedDTO | null = await this._locationService.getLocationById(locationId);

      if (!specificLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      const responseData: LocationControllerOutputDTO = LocationServiceToControllerMapper.toControllerOutputDTO(specificLocation, 'Location retrieved successfully!', true);

      return res.status(httpStatus.OK).json(responseData);
    } catch (error) {
      return next(error);
    }
  };

  public updateLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }
      const userId = req.currentUser.id;
      const { locationId } = req.params;

      const updateDataRaw: LocationControllerUpdateInputDTO = req.body;

      const updateDataForService: LocationServiceUpdateDTO = LocationControllerToServiceMapper.toServiceUpdateDTO(updateDataRaw, userId);

      const updatedLocation: LocationServiceRetrievedDTO = await this._locationService.updateLocation(locationId, updateDataForService);

      if (!updatedLocation) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location updated successfully',
        data: updatedLocation,
      });
    } catch (error) {
      next(error);
    }
  };

  public deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.currentUser || !req.currentUser.id) {
        const custErr = new Error('Authentication required.') as CustomError;
        custErr.statusCode = httpStatus.UNAUTHORIZED;
        throw custErr;
      }

      const { locationId } = req.params;
      const deleted: number = await this._locationService.deleteLocation(locationId);

      if (deleted === 0) {
        const error = new Error('Location not found or unauthorized.') as CustomError;
        error.statusCode = 404;
        throw error;
      }

      res.status(200).json({
        success: true,
        message: 'Location deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };

  public getMapData = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // This endpoint retrieves data for the map view.
      // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
      // If it's only for logged-in users, keep authenticate middleware.
      // For showing "all registered beehive locations within a country" with owner email/username,
      // it might require a join query to get hive counts and owner info across all users.
      // For simplicity, let's just return a placeholder or mock data for now.
      // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
      // to aggregate hive counts per location.
      const mockMapData = [
        {
          id: 'loc1',
          latitude: 46.0569, // Ljubljana, Slovenia
          longitude: 14.5058,
          hiveCount: 12,
          ownerUsername: 'SlovenianBeekeeper',
        },
        {
          id: 'loc2',
          latitude: 46.5547, // Maribor, Slovenia
          longitude: 15.6459,
          hiveCount: 8,
          ownerUsername: 'ApiaryExplorer',
        },
      ];

      res.status(200).json({
        success: true,
        data: mockMapData,
      });
    } catch (error) {
      next(error);
    }
  };
}


// filepath: controllers\major-inspection-contoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/major-inspection-service.js';
import { LocationService } from '../services/location-service.js'; // To check location ownership
// import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
// import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';
import { major_inspectionsAttributes } from 'database/models-ts/major-inspections.js';

// // Middleware to ensure location belongs to the authenticated user
// const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Checking location ownership...', req.params, req.body, req.currentUser);
//     const userId = req.currentUser!.id;
//     const { locationId } = req.params;

//     const location = await LocationService.getLocationById(locationId, userId);
//     if (!location) {
//       const error = new Error('Location not found or unauthorized.') as CustomError;
//       error.statusCode = 403; // Forbidden
//       throw error;
//     }
//     next(); // Location is owned by the user, proceed
//   } catch (error) {
//     next(error);
//   }
// };

export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Creating major inspection...ABCD', req.params, req.body);
    const { locationId } = req.params;
    //const inspectionData: Partial<MajorInspectionInterface> = req.body;
    const inspectionData: major_inspectionsAttributes = req.body;

    const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

    res.status(201).json({
      success: true,
      message: 'Major inspection created successfully',
      data: newMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Fetching major inspections...');
    const { locationId } = req.params;

    const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

    res.status(200).json({
      success: true,
      data: majorInspections,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: majorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const updateData: major_inspectionsAttributes = req.body;
    console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);

    const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(locationId, majorInspectionId, updateData);

    if (!updatedMajorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection updated successfully',
      data: updatedMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const deleted = await MajorInspectionService.deleteMajorInspection(userId, locationId, majorInspectionId);

    if (!deleted) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

//export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
â”œâ”€â”€ app.ts // Express app setup, middleware, routes
â”œâ”€â”€ server.ts // Entry point, starts the server
â”œâ”€â”€ config/ // Environment variables, database config
â”‚ â””â”€â”€ index.ts
â”œâ”€â”€ database/ // ORM setup (Sequelize/TypeORM), models, migrations
â”‚ â”œâ”€â”€ index.ts
â”‚ â”œâ”€â”€ models/
â”‚ â”‚ â”œâ”€â”€ User.ts
â”‚ â”‚ â”œâ”€â”€ Location.ts
â”‚ â”‚ â”œâ”€â”€ MajorInspection.ts
â”‚ â”‚ â””â”€â”€ HiveInspection.ts
â”‚ â””â”€â”€ migrations/
â”œâ”€â”€ middleware/ // Custom middleware (auth, validation, error handling)
â”‚ â”œâ”€â”€ auth.ts // JWT verification, authorization checks
â”‚ â”œâ”€â”€ validation.ts // Joi/Zod for input validation
â”‚ â””â”€â”€ errorHandler.ts // Centralized error handling
â”œâ”€â”€ controllers/ // Business logic for each resource
â”‚ â”œâ”€â”€ authController.ts
â”‚ â”œâ”€â”€ locationController.ts
â”‚ â”œâ”€â”€ majorInspectionController.ts
â”‚ â””â”€â”€ hiveInspectionController.ts
â”œâ”€â”€ routes/ // API routes for each resource
â”‚ â”œâ”€â”€ authRoutes.ts
â”‚ â”œâ”€â”€ locationRoutes.ts
â”‚ â”œâ”€â”€ majorInspectionRoutes.ts
â”‚ â””â”€â”€ hiveInspectionRoutes.ts
â”œâ”€â”€ services/ // Database interaction logic (optional, for separation of concerns)
â”‚ â”œâ”€â”€ locationService.ts
â”‚ â””â”€â”€ ...
â”œâ”€â”€ types/ // TypeScript interfaces/types
â”‚ â”œâ”€â”€ express.d.ts // Extend Request for user property
â”‚ â”œâ”€â”€ models.ts
â”‚ â””â”€â”€ auth.ts
â””â”€â”€ utils/ // Utility functions (e.g., password hashing)
â””â”€â”€ jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts
import { Sequelize } from 'sequelize-typescript';
import config from '../config/index.js';
import { users } from './models-ts/users.js'; // To be created
import { locations } from './models-ts/locations.js'; // To be created
import { hive_inspections } from './models-ts/hive_inspections.js';
import { major_inspections } from './models-ts/major-inspections.js';
import { hives } from './models-ts/hives.js'; // To be created
import { associateModels } from './models-ts/associations.js'; // Adjust path if you placed it elsewhere, e.g., './models-obsolete/associations.js'

console.log('Connecting to PostgreSQL database... ', process.env.DATABASE_URL);

const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;
console.log('Database connection string:', databaseUrl);

// Initialize Sequelize with your database connection string<br>
const sequelize = new Sequelize({
  database: DB_NAME,
  username: DB_USER,
  password: DB_PASSWORD,
  host: DB_HOST,
  port: DB_PORT,
  dialect: DB_DIALECT,
  logging: false, // Enable logging to see SQL queries
  models: [users, locations, hive_inspections, major_inspections, hives], // Add all models here
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000,
  },
  // Required for proper PostgreSQL UUID handling
  dialectOptions: {
    useUTC: false,
  },
  timezone: '+00:00', // Set timezone to UTC for consistency
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Set up associations between models
    associateModels();
    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
      console.log('Syncing database models (development mode)...');
      //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
      await sequelize.sync({ alter: false });
      console.log('Database models synchronized.');
    } else {
      // In production, rely on migrations. If you haven't run migrations,
      // you might still want a simple sync without alter.
      // Or remove this line entirely if you strictly use migrations.
      // await sequelize.sync();
      console.log('In production, use database migrations to manage schema changes.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};

export { sequelize as sequelizeInstance };
//export const db = sequelize;


// filepath: database\models-ts\associations.ts
import { users } from './users.js';
import { locations } from './locations.js';
import { major_inspections } from './major-inspections.js';
import { hives } from './hives.js';
import { hive_inspections } from './hive_inspections.js';

export function associateModels() {
  // User to Location (one-to-many)
  users.hasMany(locations, {
    foreignKey: 'user_id',
    as: 'locations',
  });
  locations.belongsTo(users, {
    foreignKey: 'user_id',
    as: 'user',
  });

  // Location to MajorInspection (one-to-many)
  locations.hasMany(major_inspections, {
    foreignKey: 'location_id',
    as: 'locations_majorInspections',
  });
  major_inspections.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'majorInspection_location',
  });

  // Location to Hives (one-to-many)
  locations.hasMany(hives, {
    foreignKey: 'location_id',
    as: 'locations_hives',
  });
  hives.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'hives_location',
  });

  // MajorInspection to HiveInspection (one-to-many)
  major_inspections.hasMany(hive_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'majors_hiveInspections',
  });
  hive_inspections.belongsTo(major_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'hiveInspections_majorInspection',
  });

  // Hive to HiveInspection (one-to-many)
  hives.hasMany(hive_inspections, {
    foreignKey: 'hive_id',
    as: 'hives_hiveInspections',
  });

  hive_inspections.belongsTo(hives, {
    foreignKey: 'hive_id',
    as: 'hiveInspections_hive',
  });
}


// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface hivesAttributes {
  hive_id?: string;
  location_id: string;
  hive_name: string;
  description?: string;
  is_active?: boolean;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hives',
  schema: 'public',
  timestamps: false,
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING(255),
  })
  hive_name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  description?: string;

  @Column({
    allowNull: true,
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('true'),
  })
  is_active?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  //   // --- Associations for Hive Inspections ---
  //   @HasMany(() => hive_inspections, {
  //     foreignKey: 'hive_id', // The foreign key in the 'hive_inspections' table that links back to 'hives'
  //     as: 'hiveInspections', // Alias for when you include hive inspections with a hive
  //   })
  //   hiveInspections?: hive_inspections[]; // Property to hold an array of associated hive inspections
}


// filepath: database\models-ts\hive_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

import { hives } from './hives.js'; // Import hives model
import { major_inspections } from './major-inspections.js'; // Import major_inspections model

export interface hive_inspectionsAttributes {
  hive_inspection_id?: string;
  major_inspection_id: string;
  hive_id: string;
  inspection_time: string;
  colony_health_status_id: number;
  num_chambers: number;
  brood_frames_count?: number;
  brood_percentage?: number; // no longer string
  queen_status_id: number;
  approx_honey_weight_kg?: number;
  drone_comb_frames_count?: number;
  drone_comb_percentage?: number; // no longer string
  sugar_feed_added?: boolean;
  sugar_feed_quantity_kg?: number;
  brood_chambers_count: number;
  supers_count: number;
  queen_excluder_present?: boolean;
  num_varroa_mites_found?: number;
  varroa_treatment_id?: number;
  varroa_treatment_dosage?: string;
  raising_new_queen?: boolean;
  queen_cell_age_days?: number;
  queen_cell_status_id?: number;
  other_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hive_inspections',
  schema: 'public',
  timestamps: false,
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_inspection_id?: string;

  @ForeignKey(() => major_inspections) // Indicates that major_inspection_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  major_inspection_id!: string;

  @ForeignKey(() => hives) // Indicates that hive_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  hive_id!: string;

  //   @BelongsTo(() => hives, {
  //     foreignKey: 'hive_id',
  //     as: 'hive', // Alias for when you include the hive with a hive inspection
  //   })
  //   hive?: hives; // Property to hold the associated hive

  @Column({
    type: DataType.STRING,
  })
  inspection_time!: string;

  @Column({
    type: DataType.INTEGER,
  })
  colony_health_status_id!: number;

  @Column({
    type: DataType.INTEGER,
  })
  num_chambers!: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_percentage?: number;

  @Column({
    type: DataType.INTEGER,
  })
  queen_status_id!: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  approx_honey_weight_kg?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  drone_comb_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(3, 0),
  })
  drone_comb_percentage?: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  sugar_feed_added?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  sugar_feed_quantity_kg?: number;

  @Column({
    type: DataType.INTEGER,
  })
  brood_chambers_count!: number;

  @Column({
    type: DataType.INTEGER,
  })
  supers_count!: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  queen_excluder_present?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  num_varroa_mites_found?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  varroa_treatment_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  varroa_treatment_dosage?: string;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  raising_new_queen?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_age_days?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_status_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  other_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // @BelongsTo(() => major_inspections, {
  //   foreignKey: 'major_inspection_id',
  //   as: 'majorInspection', // This alias is consistent with what you used in HiveInspectionService
  // })
  // majorInspection?: major_inspections; // Property to hold the associated major inspection
}


// filepath: database\models-ts\index.ts
export * from './hives.js';
export * from './users.js';
export * from './locations.js';
export * from './major-inspections.js';
export * from './hive_inspections.js';
export * from './colony_health_statuses.js';
export * from './queen-statuses.js';
export * from './varroa_treatments.js';
export * from './queen-cell-statuses.js';


// filepath: database\models-ts\locations.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { users } from './users.js';
// import { hives } from './hives.js'; // Import hives model
// import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface locationsAttributes {
  location_id?: string;
  user_id: string;
  name: string;
  address?: string;
  latitude?: string;
  longitude?: string;
  country?: string;
  notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'locations',
  schema: 'public',
  timestamps: false,
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  location_id?: string;

  @ForeignKey(() => users)
  @Column({
    type: DataType.UUID,
  })
  user_id!: string;

  @Column({
    type: DataType.STRING(255),
  })
  name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(500),
  })
  address?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  latitude?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  longitude?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(100),
  })
  country?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // Association with users model
  //   @BelongsTo(() => users)
  //   user?: users; // This property would hold the associated user object

  // --- Associations for Hives ---
  //   @HasMany(() => hives, {
  //     foreignKey: 'location_id', // The foreign key in the 'hives' table that links back to 'locations'
  //     as: 'hives', // Alias for when you include hives with a location
  //   })
  //   hives?: hives[]; // Property to hold an array of associated hives

  // --- Associations for Major Inspections ---
  //   @HasMany(() => major_inspections, {
  //     foreignKey: 'location_id', // The foreign key in the 'major_inspections' table that links back to 'locations'
  //     as: 'majorInspections', // Alias for when you include major inspections with a location
  //   })
  //   majorInspections?: major_inspections[]; // Property to hold an array of associated major inspections
}


// filepath: database\models-ts\major-inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';

import { locations } from './locations.js'; // Import locations model
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface major_inspectionsAttributes {
  major_inspection_id?: string;
  location_id: string;
  inspection_date: string;
  general_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'major_inspections',
  schema: 'public',
  timestamps: false,
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  major_inspection_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  // @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  // location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING,
  })
  inspection_date!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  general_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
  // --- Associations for Hive Inspections ---
  @HasMany(() => hive_inspections, {
    foreignKey: 'major_inspection_id', // The foreign key in the 'hive_inspections' table that links back to 'major_inspections'
    as: 'hiveInspections', // Alias for when you include hive inspections with a major inspection
  })
  hiveInspections?: hive_inspections;
  */
}


// filepath: database\models-ts\queen-cell-statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen-statuses.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

export interface queen_statusesAttributes {
  status_id?: number;
  status_name: string;
}

@Table({
  tableName: 'queen_statuses',
  schema: 'public',
  timestamps: false,
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {
  @Column({
    primaryKey: true,
    autoIncrement: true,
    type: DataType.INTEGER,
    defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)"),
  })
  status_id?: number;

  @Column({
    type: DataType.STRING(50),
  })
  status_name!: string;
}


// filepath: database\models-ts\users.ts
import { Model, Table, Column, DataType, Index, Sequelize, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';

export interface usersAttributes {
  user_id?: string;
  username: string;
  password_hash?: string;
  email: string;
  google_id?: string;
  linkedin_id?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'users',
  schema: 'public',
  timestamps: false,
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  user_id?: string;

  @Column({
    type: DataType.STRING(255),
  })
  username!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  password_hash?: string;

  @Column({
    type: DataType.STRING(255),
  })
  email!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  google_id?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  linkedin_id?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
	// Association with locations model
	@HasMany(() => locations, { foreignKey: 'user_id' })
    locations?: locations[]; // This property would hold an array of associated locations
	*/
}


// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: database\myhives_db_script.sql
-- Enable the pgcrypto extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Table for Users
-- Stores user authentication details, supporting traditional, Google, and LinkedIn logins.
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- Storing hashed password for traditional login
    email VARCHAR(255) UNIQUE NOT NULL,
    google_id VARCHAR(255) UNIQUE, -- Google OAuth ID
    linkedin_id VARCHAR(255) UNIQUE, -- LinkedIn OAuth ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index on commonly searched authentication fields
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_google_id ON users(google_id);
CREATE INDEX idx_users_linkedin_id ON users(linkedin_id);


-- Table for Beehive Locations/Stands
-- Stores information about where beekeepers manage their hives.
CREATE TABLE locations (
    location_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE, -- Link to the owner
    name VARCHAR(255) NOT NULL, -- Name of the location (e.g., "Backyard Apiary", "Field A")
    address VARCHAR(500), -- Optional: physical address
    latitude NUMERIC(9,6), -- Latitude for map display
    longitude NUMERIC(9,6), -- Longitude for map display
    country VARCHAR(100), -- Country for potential regional filtering/map views
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_LocationName_User UNIQUE (user_id, name) -- Location names must be unique per user
);

-- Indexes for location data
CREATE INDEX idx_locations_user_id ON locations(user_id);
CREATE INDEX idx_locations_lat_lon ON locations(latitude, longitude);


-- Table for Individual Beehives
-- Represents a specific beehive within a location, allowing tracking of its history.
CREATE TABLE hives (
    hive_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE, -- Link to its physical location
    hive_name VARCHAR(255) NOT NULL, -- Unique name/identifier for the hive within its location (e.g., "Hive 1", "Blue Box")
    description TEXT, -- General description of the hive
    is_active BOOLEAN DEFAULT TRUE, -- Flag if the hive is currently active at this location
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_HiveName_Location UNIQUE (location_id, hive_name) -- Hive names must be unique within a location
);

-- Index for hive data
CREATE INDEX idx_hives_location_id ON hives(location_id);


-- Lookup Table: Colony Health Statuses
-- Predefined options for colony health (e.g., thriving, weak, failing)
CREATE TABLE colony_health_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO colony_health_statuses (status_name) VALUES
('Thriving'),
('Weak'),
('Failing'),
('Unknown');


-- Lookup Table: Queen Statuses
-- Predefined options for queen status (e.g., seen, not seen, laying well)
CREATE TABLE queen_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_statuses (status_name) VALUES
('Seen'),
('Not Seen'),
('Laying Well'),
('Queen Cells Present'),
('Superseded'),
('Absent'),
('Virgin'),
('Unknown');


-- Lookup Table: Varroa Treatments
-- Predefined options for varroa treatments (e.g., Formic acid, Oxalic acid, None)
CREATE TABLE varroa_treatments (
    treatment_id SERIAL PRIMARY KEY,
    treatment_name VARCHAR(100) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO varroa_treatments (treatment_name) VALUES
('Formic Acid'),
('Oxalic Acid'),
('Apivar'),
('Api Life Var'),
('Mite Away Quick Strips'),
('None'),
('Other');


-- Lookup Table: Queen Cell Statuses
-- Predefined options for queen cell status (e.g., open, closed)
CREATE TABLE queen_cell_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_cell_statuses (status_name) VALUES
('Open'),
('Closed'),
('Hatched'),
('Destroyed'),
('Emerging'),
('Unknown');


-- Table for Major Inspections
-- Represents a single visit to a location where one or more hives were inspected.
CREATE TABLE major_inspections (
    major_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE,
    inspection_date DATE NOT NULL,
    general_notes TEXT, -- General notes for the entire location visit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_MajorInspection_LocationDate UNIQUE (location_id, inspection_date)
);

-- Index for major inspections
CREATE INDEX idx_major_inspections_location_date ON major_inspections(location_id, inspection_date);


-- Table for Individual Hive Inspections
-- Detailed records for each specific hive inspection within a major inspection.
CREATE TABLE hive_inspections (
    hive_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    major_inspection_id UUID NOT NULL REFERENCES major_inspections(major_inspection_id) ON DELETE CASCADE,
    hive_id UUID NOT NULL REFERENCES hives(hive_id) ON DELETE CASCADE,
    inspection_time TIME WITHOUT TIME ZONE NOT NULL, -- Hour of inspection specific to this hive
    
    -- Colony Health
    colony_health_status_id INTEGER NOT NULL REFERENCES colony_health_statuses(status_id),
    num_chambers INTEGER NOT NULL, -- Number of hive boxes/chambers
    
    -- Brood details (allowing for either count or percentage, or both)
    brood_frames_count INTEGER, -- Number of frames with brood
    brood_percentage NUMERIC(5,2), -- Percentage of brood (e.g., 75.00 for 75%)
    
    -- Queen Status
    queen_status_id INTEGER NOT NULL REFERENCES queen_statuses(status_id),
    
    -- Honey and Drone Comb
    approx_honey_weight_kg NUMERIC(8,2), -- Approximate amount of honey in kg
    drone_comb_frames_count INTEGER, -- Number of frames with drone comb
    drone_comb_percentage NUMERIC(5,2), -- Percentage of drone comb
    
    -- Feeding and Configuration
    sugar_feed_added BOOLEAN NOT NULL DEFAULT FALSE,
    sugar_feed_quantity_kg NUMERIC(8,2), -- Quantity of sugar feed added in kg
    brood_chambers_count INTEGER NOT NULL,
    supers_count INTEGER NOT NULL,
    queen_excluder_present BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Varroa Mites
    num_varroa_mites_found INTEGER,
    varroa_treatment_id INTEGER REFERENCES varroa_treatments(treatment_id),
    varroa_treatment_dosage VARCHAR(255), -- Dosage/amount (e.g., "5ml", "2 strips")
    
    -- Queen Rearing
    raising_new_queen BOOLEAN NOT NULL DEFAULT FALSE,
    queen_cell_age_days INTEGER, -- Age in days, if known
    queen_cell_status_id INTEGER REFERENCES queen_cell_statuses(status_id),
    
    other_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- A specific hive should only be inspected once per major inspection event
    CONSTRAINT UQ_HiveInspection_MajorHive UNIQUE (major_inspection_id, hive_id)
);

-- Indexes for hive inspections
CREATE INDEX idx_hive_inspections_major_id ON hive_inspections(major_inspection_id);
CREATE INDEX idx_hive_inspections_hive_id ON hive_inspections(hive_id);


-- Function to update the `updated_at` column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to automatically update `updated_at` on row modification
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_locations_updated_at
BEFORE UPDATE ON locations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hives_updated_at
BEFORE UPDATE ON hives
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_major_inspections_updated_at
BEFORE UPDATE ON major_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hive_inspections_updated_at
BEFORE UPDATE ON hive_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Authentication middleware called');
    const authHeader = req.headers.authorization;
    console.log('Token received:', req.headers.authorization);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);
    console.log('Decoded token:', decoded);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.currentUser = { id: decoded.userId }; // Ensure 'user_id' is set for compatibility};

    next();
  } catch (error: any) {
    console.error('Authentication error:', error);
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    console.error(`Error status code: ${err.statusCode}, message: ${err.message}`);
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };


// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error Handler  occurred:', {
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
  });
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;


// filepath: middleware\ownership.ts
import { Request, Response, NextFunction } from 'express';
import { LocationService } from '../services/location-service.js'; // To check location ownership
import { MajorInspectionService } from '../services/major-inspection-service.js';
import httpStatus from 'http-status';
import { CustomError } from '../middleware/errorHandler.js';
import { ParamsDictionary } from 'express-serve-static-core';

interface LocationParams extends ParamsDictionary {
  locationId: string;
}

// Middleware to ensure location belongs to the authenticated user
// Goal is to check if the :majorInspectionId in the URL param belongs to the authenticated user
// This assumes MajorInspectionService has a method to verify ownership without requiring locationId in URL
const checkMajorInspectionOwnershipForHive = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Checking major inspection ownership for hive inspections...', req.params, req.body, req.currentUser);
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    // IMPORTANT: You need to implement this method in your MajorInspectionService.
    // It should fetch the major inspection and ensure its associated location's userId matches the current user.
    //const majorInspectionOwned = await MajorInspectionService.getMajorInspectionByIdAndVerifyUser(
    // console.log(
    //   '\t\t @Ownership/checkMajorInspectionOwnershipForHive Checking major inspection ownership for hive inspections...',
    //   '\nmajorInspectionId:',
    //   majorInspectionId,
    //   '\nlocationId:',
    //   locationId,
    //   '\nuserId:',
    //   userId
    // );

    const majorInspectionOwned = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspectionOwned) {
      const error: CustomError = new Error('oMajor Inspection not found or not owned by user') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Store the fetched object on res.locals for subsequent handlers
    res.locals.majorInspectionOwned = majorInspectionOwned;
    //console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspectionOwned);

    next();
  } catch (error) {
    console.error('%%% Error checking major inspection ownership for hive:', error);
    next(error);
  }
};

/**
 * Middleware factory that accepts an instance of LocationService via Dependency Injection.
 * It returns the actual Express middleware function which checks if the authenticated user
 * owns the resource specified by :locationId.
 *
 * @param locationService An instance of the LocationService used to perform the check.
 * @returns The Express middleware function to be used in routes.
 */
const checkLocationOwnership = (locationService: LocationService) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const locationId = req.params.locationId as string;
      // req.currentUser is set by a preceding authentication middleware (like isAuthenticated)
      const userId = req.currentUser?.id;

      if (!userId) {
        // This should be caught by isAuthenticated, but is a necessary safety check
        const error = new Error('Authentication required for ownership check.') as CustomError;
        error.statusCode = httpStatus.UNAUTHORIZED; // 401
        throw error;
      }

      // Call the non-static instance method on the injected service
      const isOwner = await locationService.checkLocationOwnership(locationId, userId);

      if (!isOwner) {
        const error = new Error('Forbidden. You do not own this location.') as CustomError;
        error.statusCode = httpStatus.FORBIDDEN; // 403
        throw error;
      }

      // Ownership confirmed, proceed
      next();
    } catch (error) {
      next(error);
    }
  };
};

export { checkLocationOwnership, checkMajorInspectionOwnershipForHive };


// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { CustomError } from './errorHandler.js';
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/foobar.js';

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  // console.log('Validation middleware initialized with schemas:', schemas);
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: repositories\implementations\hive-repository.ts
import { Sequelize } from 'sequelize';
import { IHiveRepository } from '../interfaces/i-hive-repository.js';
import { hives } from '../../database/models-ts/hives.js'; //'../ database/models-ts/hives.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Concrete Hive repository.
 *
 * Note: This file provides a pragmatic implementation using Prisma.
 * The exported instance is asserted to IHiveRepository to match your interface
 * even if the exact method signatures differ from this example.
 */
export class HiveRepository implements IHiveRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    const newHive = await hives.create(hiveData);
    return newHive as HiveServiceRetrievedDTO;
  }

  async update(id: string, hiveData: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]> {
    return this.db.transaction(async (t) => {
      const [updatedCount, [updatedHive]] = await hives.update(hiveData, {
        where: { hive_id: id },
        returning: true,
      });
      return [updatedCount, updatedCount > 0 ? [updatedHive as HiveServiceRetrievedDTO] : []];
    });
  }

  async findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null> {
    if (locationId) {
      const hiveWithLocation = await hives.findOne({
        where: {
          hive_id: hiveId,
          location_id: locationId,
        },
      });
      return hiveWithLocation ? (hiveWithLocation as HiveServiceRetrievedDTO) : null;
    } else {
      const hive = await hives.findByPk(hiveId);
      return hive ? (hive as HiveServiceRetrievedDTO) : null;
    }
  }

  async findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const allHives = await hives.findAll({ where: { location_id: locationId } });
    return allHives as HiveServiceRetrievedDTO[];
  }

  async delete(id: string, locationId?: string): Promise<number> {
    const whereCondition = locationId ? { hive_id: id, location_id: locationId } : { hive_id: id };

    const deletedCount: number = await hives.destroy({ where: whereCondition });
    return deletedCount;
  }

  async deleteAll(locationId: string): Promise<number> {
    const deletedCount: number = await hives.destroy({ where: { location_id: locationId } });
    return deletedCount;
  }
}


// filepath: repositories\implementations\location-repository.ts
import { Sequelize } from 'sequelize';
import { ILocationRepository } from '../interfaces/i-location-repository.js';
import { locations } from '../../database/models-ts/locations.js'; // Assuming model is imported like this
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

export class LocationRepository implements ILocationRepository {
  private readonly db: Sequelize; // Dependency for Sequelize instance (for transactions)

  constructor(db: Sequelize) {
    this.db = db;
  }

  async create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    const newLocation = await locations.create(location);
    return newLocation.toJSON() as LocationServiceRetrievedDTO;
  }

  async findById(id: string): Promise<LocationServiceRetrievedDTO | null> {
    const location = await locations.findByPk(id);
    return location ? (location.toJSON() as LocationServiceRetrievedDTO) : null;
  }

  async findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    const allLocations = await locations.findAll({ where: { user_id: userId } });
    return allLocations.map((location) => location.toJSON() as LocationServiceRetrievedDTO);
  }

  async update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]> {
    // We use the managed transaction pattern for safety, guaranteeing rollback if necessary.
    return this.db.transaction(async (t) => {
      const [updatedCount, updatedLocations] = await locations.update(location, {
        where: { location_id: id },
        returning: true,
        transaction: t, // Pass the transaction object
      });

      if (updatedCount > 1) {
        // Safety mechanism: If more than one row was somehow affected, trigger rollback.
        throw new Error('Concurrency failure: More than one location record updated.');
      }

      // If successful, commit automatically.
      return [updatedCount, updatedLocations.map((loc) => loc.toJSON() as LocationServiceRetrievedDTO)];
    });
  }

  async delete(id: string): Promise<number> {
    return locations.destroy({ where: { location_id: id } });
  }
}


// filepath: repositories\implementations\user-repository.ts
import { IUserRepository } from '../interfaces/i-user-repository.js';
import { users } from '../../database/models-ts/users.js';
import { sequelizeInstance as database } from '../../database/connect.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export class UserRepository implements IUserRepository {
  private readonly db = database;

  async create(user: UserCreationDTO): Promise<UserRetrievedDTO> {
    const newUser = await users.create(user);
    return newUser.toJSON() as UserRetrievedDTO;
  }

  async readById(id: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findByPk(id);
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readByEmail(email: string): Promise<UserRetrievedDTO | null> {
    const user = await users.findOne({ where: { email } });
    return user ? (user.toJSON() as UserRetrievedDTO) : null;
  }

  async readAll(): Promise<UserRetrievedDTO[]> {
    const allUsers = await users.findAll();
    return allUsers.map((user) => user.toJSON() as UserRetrievedDTO);
  }

  async update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]> {
    const transaction = await this.db.transaction();
    try {
      const [updatedCount, updatedUsers] = await users.update(user, {
        where: { user_id: id },
        returning: true,
        transaction: transaction,
      });

      if (updatedCount > 1) {
        // Rollback if the count is unexpected (the actual fix would be to prevent this query from updating >1 in the first place,
        // but the rollback is the safety net).
        await transaction.rollback();
        throw new Error('Concurrency failure: More than one record updated.');
      }

      // COMMIT if successful
      await transaction.commit();

      return [updatedCount, updatedUsers.map((user) => user.toJSON() as UserRetrievedDTO)];
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }

  async delete(id: string): Promise<number> {
    const deletedCount = await users.destroy({ where: { user_id: id } });
    return deletedCount;
  }
}


// filepath: repositories\interfaces\i-hive-inspection-repository.ts


// filepath: repositories\interfaces\i-hive-repository.ts
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from 'services/dto/hive-service.dto.js';

/**
 * Interface for the Hive data access layer.
 * Manages CRUD operations for the 'hives' table.
 */
export interface IHiveRepository {
  /**
   * Creates a new hive record.
   * @param hive The data for the new hive, including the location_id.
   * @returns The created hive DTO.
   */
  create(hive: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO>;

  /**
   * Updates an existing hive record.
   * @param id The unique ID of the hive to update.
   * @param hive The partial update data.
   * @returns A tuple: [number of updated rows (should be 1), array of updated hive DTOs].
   */
  update(id: string, hive: HiveServiceUpdateDTO): Promise<[number, HiveServiceRetrievedDTO[]]>;

  /**
   * Retrieves a single hive by its ID.
   * @param hiveId The unique ID of the hive.
   * @param locationId The optional unique ID of the location.
   * @returns The hive DTO or null if not found.
   */
  findById(hiveId: string, locationId?: string): Promise<HiveServiceRetrievedDTO | null>;

  /**
   * Retrieves all hives associated with a specific location.
   * @param locationId The ID of the location.
   * @returns An array of hive DTOs.
   */
  findAllByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]>;

  /**
   * Deletes a hive record by its ID.
   * @param hiveId The unique ID of the hive to delete.
   * @param locationId The optional unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  delete(hiveId: string, locationId?: string): Promise<number>;

  /**
   * Deletes a hive record by its ID.
   * @param locationId The unique ID of the location.
   * @returns The number of records deleted (should be 1 or 0).
   */
  deleteAll(locationId: string): Promise<number>;
}


// filepath: repositories\interfaces\i-location-repository.ts
import { LocationServiceCreateDTO, LocationServiceUpdateDTO, LocationServiceRetrievedDTO } from '../../services/dto/location-service.dto.js';

/**
 * Interface defining the data access operations for the Location model.
 * All location services will depend on this contract, not a concrete implementation.
 */
export interface ILocationRepository {
  create(location: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO>;

  findById(id: string): Promise<LocationServiceRetrievedDTO | null>;

  findAllByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]>;

  update(id: string, location: LocationServiceUpdateDTO): Promise<[number, LocationServiceRetrievedDTO[]]>;

  delete(id: string): Promise<number>;
}


// filepath: repositories\interfaces\i-major-inspection-repository.ts


// filepath: repositories\interfaces\i-user-repository.ts
// import { users } from '../../database/models-ts/users.js';
import { UserRetrievedDTO, UserUpdateDTO, UserCreationDTO } from '../../services/dto/user-service.dto.js';

export interface IUserRepository {
  create(user: UserCreationDTO): Promise<UserRetrievedDTO>;
  readById(id: string): Promise<UserRetrievedDTO | null>;
  readByEmail(email: string): Promise<UserRetrievedDTO | null>;
  readAll(): Promise<UserRetrievedDTO[]>;
  update(id: string, user: UserUpdateDTO): Promise<[number, UserRetrievedDTO[]]>;
  delete(id: string): Promise<number>;
}


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router } from 'express';

import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { UserRepository } from '../repositories/implementations/user-repository.js';
import { UserService } from '../services/user-service.js';
//import { RegisterUserDto } from '../types/DTO/per-controller/dtos.js'; // Assuming these DTOs exist
import { RegisterUserIncomingDTO, LoginUserIncomingDTO, UpdateUserIncomingDTO } from '../controllers/dto/auth-controller.dto.js';

import { AuthController } from '../controllers/auth-controller.js';

import { isAuthenticated } from '../middleware/auth.js';

const authRouter = Router();

// --- DI SETUP ---
const userRepository = new UserRepository(); // Concrete implementation
const userService = new UserService(userRepository); // Inject Repository into Service
const authController = new AuthController(userService); // Inject Service into Controller
// --- END DI SETUP ---

const registerSchema = Joi.object<RegisterUserIncomingDTO>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required',
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
});

const loginSchema = Joi.object<LoginUserIncomingDTO>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required',
  }),
});

const updateSchema = Joi.object<UpdateUserIncomingDTO>({
  username: Joi.string().trim().optional(),
  email: Joi.string().email().optional().messages({
    'string.email': 'Email must be a valid email address',
  }),
  password: Joi.string().min(6).optional().messages({
    'string.min': 'Password must be at least 6 characters long',
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',
  validate({ body: registerSchema }), // Apply Joi validation middleware
  authController.register // Call the controller function here
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // Apply Joi validation middleware
  authController.login // Call the controller function here
);

authRouter.get('/me', isAuthenticated, authController.getMe);

authRouter.post(
  '/logout',
  isAuthenticated, // Optional: You might want to ensure only authenticated users can "logout"
  // Or, if you simply want to provide a path to clear client-side token, it can be without auth.
  authController.logout
);

authRouter.put('/me', isAuthenticated, validate({ body: updateSchema }), authController.updateMe);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;


// filepath: routes\hiveInspectionRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hive-inspection-service.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { checkMajorInspectionOwnershipForHive as checkMajorInspectionOwnership } from '../middleware/ownership.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
//import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';
import { HiveInspectionController } from '../controllers/hive-inspection-controller.js';

const hiveInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for HiveInspection ---
// const beehiveConfigurationSchema = Joi.object({
//   type: Joi.string().required(),
//   numberOfFrames: Joi.number().integer().min(1).required(),
//   materials: Joi.array().items(Joi.string()).optional(),
//   isInsulated: Joi.boolean().optional(),
// });

const createHiveInspectionSchema = Joi.object({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  // Use the exact snake_case names from your model
  hive_id: Joi.string().uuid().required(),
  inspection_time: Joi.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .required(),
  colony_health_status_id: Joi.number().integer().required(),
  num_chambers: Joi.number().integer().min(1).required(),
  brood_chambers_count: Joi.number().integer().min(1).required(),
  supers_count: Joi.number().integer().min(0).required(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().required(),
  approx_honey_weight_kg: Joi.number().integer().min(0).max(50).optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().min(0).max(10).optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().optional().allow(null),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<hive_inspectionsAttributes>({
  hive_id: Joi.string().trim().optional(),
  inspection_time: Joi.string()
    .pattern(/^([01]\d|2[0-3]):([0-5]\d)$/)
    .optional()
    .messages({
      'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)',
    }),
  colony_health_status_id: Joi.number().integer().optional(),
  num_chambers: Joi.number().integer().min(1).optional(),
  brood_chambers_count: Joi.number().integer().min(1).optional(),
  supers_count: Joi.number().integer().min(0).optional(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().optional(),
  approx_honey_weight_kg: Joi.number().integer().optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const specificHiveInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hiveInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const rootHiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  // Add the locationId to the schema to allow it
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
    body: createHiveInspectionSchema,
  }),
  // (req, res, next) => {
  //   console.log('Validation successful');
  //   next();
  // },
  checkMajorInspectionOwnership, // Verify parent MajorInspection ownership
  HiveInspectionController.createHiveInspection
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
  }),

  checkMajorInspectionOwnership,
  (req, res, next) => {
    console.log('****** GET /  ownership verified *****');
    next();
  },
  HiveInspectionController.getHiveInspectionsByMajorInspectionId
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** GET /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.getHiveInspectionById
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** PUT /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({
    params: specificHiveInspectionParamsSchema,
    body: updateHiveInspectionSchema,
  }),
  checkMajorInspectionOwnership,
  HiveInspectionController.updateHiveInspection
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** DELETE /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.deleteHiveInspection
);

export default hiveInspectionRouter;


// filepath: routes\hiveRoutes.ts
/* define endpoints, joi schemas, and controllers for hive inspections */
import { Router } from 'express';
import Joi from 'joi';

import { HiveController } from '../controllers/hive-controller.js';
import { HiveRepository } from 'repositories/implementations/hive-repository.js';
import { HiveService } from 'services/hive-service.js';
//import { hivesAttributes } from '../database/models-ts/hives.js';
import { isAuthenticated } from '../middleware/auth.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { validate } from '../middleware/validation.js';
import { HiveControllerCreateDTO, HiveControllerCreateStrongDTO, HiveControllerUpdateDTO } from 'controllers/dto/hive-controller.dto.js';

const hiveRouter = Router({ mergeParams: true });
// --- DI SETUP ---
const hiveRepository = new HiveRepository(database); // Concrete implementation
const hiveService = new HiveService(hiveRepository); // Inject Repository into Service
const hiveController = new HiveController(hiveService); // Inject Service into Controller
// --- END DI SETUP ---

const createHivesBodySchema = Joi.object<HiveControllerCreateStrongDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .required(),
  hive_name: Joi.string().min(2).max(50).required(),
  description: Joi.string().min(2).max(200).required(),
  is_active: Joi.boolean().required(),
});

const updateHivesBodySchema = Joi.object<HiveControllerUpdateDTO>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .optional(),
  hive_name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().min(2).max(200).optional(),
  is_active: Joi.boolean().optional(),
});

const createHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const updateHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hive_id: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

//GET /api/v1/locations/:locationId/hives - Get all hives for a specific location.
hiveRouter.get(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching hives...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.getAllHives
);
//POST /api/v1/locations/:locationId/hives - Create a new hive within a specific location.
hiveRouter.post('/', isAuthenticated, validate({ params: createHiveParamSchema, body: createHivesBodySchema }), hiveController.createHive);

//GET /api/v1/locations/:locationId/hives/:hiveId - Get a specific hive.
hiveRouter.get(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.getHiveById
);

//PUT /api/v1/locations/:locationId/hives/:hiveId - Update a specific hive.
hiveRouter.put(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Updating specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema, body: updateHivesBodySchema }),
  hiveController.updateHive
);

//DELETE /api/v1/locations/:locationId/hives/:hiveId - Delete a specific hive.
hiveRouter.delete(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveController.deleteHive
);
hiveRouter.delete(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting all hives ...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveController.deleteAllHives
);

export default hiveRouter;


// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { LocationController } from '../controllers/location-controller.js';
import { LocationService } from '../services/location-service.js';
import { LocationRepository } from '../repositories/implementations/location-repository.js';
import { sequelizeInstance as database } from '../database/connect.js';
import { LocationControllerUpdateInputDTO, LocationControllerCreateInputDTO } from '../controllers/dto/location-controller.dto.js';
//import { createLocation, getLocations, getLocationById, updateLocation, deleteLocation, getMapData } from '../controllers/location-controller.js'; // <-- Import the controller functions

//import { locationsAttributes } from '../database/models-ts/locations.js';

import majorInspectionRouter from './majorInspectionRoutes.js';
import hiveRouter from './hiveRoutes.js';
import { checkLocationOwnership } from 'middleware/ownership.js';

const locationRouter = Router();

// --- DI SETUP ---
const locationRepository = new LocationRepository(database); // Concrete implementation
const locationService = new LocationService(locationRepository); // Inject Repository into Service
const locationController = new LocationController(locationService); // Inject Service into Controller
// --- END DI SETUP ---

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<LocationControllerCreateInputDTO>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  notes: Joi.string().trim().max(500).allow(null, ''),
  country: Joi.string().trim().max(100).allow(null, ''),
});

const updateLocationSchema = Joi.object<LocationControllerUpdateInputDTO>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  notes: Joi.string().trim().max(500).allow(null, '').optional(),
  country: Joi.string().trim().max(100).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(), // Validate as UUID
});

// Mount nested major inspection routes
locationRouter.use('/:locationId/major-inspections', isAuthenticated, majorInspectionRouter);
locationRouter.use('/:locationId/hives', isAuthenticated, hiveRouter);

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  locationController.createLocation
);

// GET /api/locations/map - Get map data
locationRouter.get('/map', isAuthenticated, locationController.getMapData);

// GET /api/locations - Get all locations for the authenticated user
locationRouter.get('/', isAuthenticated, locationController.getAllLocations);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  checkLocationOwnership(locationService),
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.getLocationById
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  locationController.updateLocation
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  locationController.deleteLocation
);

// // Mount nested major inspection routes
// locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);

export default locationRouter;


// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { NextFunction, Response, Request, Router } from 'express';
import Joi from 'joi';

//import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';

import { createMajorInspection, getMajorInspections, getMajorInspectionById, updateMajorInspection, deleteMajorInspection } from '../controllers/major-inspection-contoller.js';
import { checkLocationOwnership } from '../middleware/ownership.js';
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js';
import hiveInspectionRouter from './hiveInspectionRoutes.js';

const majorInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspection_date: Joi.date().iso().required(),
  general_notes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  inspection_date: Joi.date().iso().optional(),
  general_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const loggging = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Logging major inspections requests ...', req.params, req.body);
  next();
};
//majorInspectionRouter.use(loggging);

// Mount nested major inspection routes
// majorInspectionRouter.use('/:majorInspectionId/hive-inspections', (req, res, next) => {
//   next();
// });
majorInspectionRouter.use('/:majorInspectionId/hive-inspections', hiveInspectionRouter);

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/',
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  checkLocationOwnership, // Ensure the location belongs to the user //createMajorInspection
  createMajorInspection
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get('/', checkLocationOwnership, getMajorInspections);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, getMajorInspectionById);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/:majorInspectionId',
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  checkLocationOwnership,
  updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete('/:majorInspectionId', validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, deleteMajorInspection);

export default majorInspectionRouter;


// filepath: routes\manual-tests\hiveInspections\hiveInspections.http
###
# Hive Inspections API Tests
#
# This file assumes you have already run the `major-inspections.http` tests and have a valid token, hive ID, and major inspection ID.
# The Hive API tests might be useful for getting the hive_id.
#
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@baseUrl = http://localhost:3000/api/v1/locations/{{locationId}}
# @token = <paste_your_token_here>
# @majorInspectionId = <paste_your_major_inspection_id_here>
# @hiveId = <paste_your_hive_id_here> 
# @token =
@majorInspectionId = 3dd79818-4e59-49d7-bb82-a65b0145d87c

@hiveId = ec5ffc71-b700-4837-acdf-4dfa5b1b73e3



### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### get token
@token = {{authenticate.response.body.token}}

###
# Create a new hive inspection for a major inspection.
# @name createHiveInspection
POST {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_id": "bfdd1ef0-0cc1-4886-9ba9-572e60a70ef0",
  "inspection_time": "14:41",
  "colony_health_status_id": 1,
  "num_chambers": 3,
  "brood_chambers_count": 2,
  "supers_count": 1,
  "brood_frames_count": 15,
  "brood_percentage": 79,
  "queen_status_id": 2,
  "approx_honey_weight_kg": 10,
  "drone_comb_frames_count": 2,
  "drone_comb_percentage": 5.0,
  "sugar_feed_added": false,
  "sugar_feed_quantity_kg": null,
  "queen_excluder_present": true,
  "num_varroa_mites_found": 5,
  "varroa_treatment_id": 1,
  "varroa_treatment_dosage": "100ml",
  "raising_new_queen": false,
  "queen_cell_age_days": null,
  "queen_cell_status_id": null,
  "other_notes": "The colony seems strong and healthy. Found a few varroa mites, will continue to monitor."
}

###
# Get all hive inspections for a major inspection.
# @name getHiveInspections
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Authorization: Bearer {{token}}

###
# Get a specific hive inspection.
#
# To run this, first run the `createHiveInspection` request and copy the `hive_inspection_id`.
# @hiveInspectionId = <paste_hive_inspection_id_here>
@hiveInspectionId = {{createHiveInspection.response.body.hive_inspection_id}}
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId`.
PUT {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "brood_percentage": 33,
  "approx_honey_weight_kg": 25,
  "num_chambers": 8,
  "drone_comb_frames_count": 3,  
  "colony_health_status_id": 3,
  "other_notes": "Updated notes: The colony is doing well, but I noticed a few varroa mites."
}

###
# Delete a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\hives\hives.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@hiveId = 01127c49-7230-4405-9ef3-bba06e71a968

// --- Helper Request: Create a Hive (if you need one) ---
// @name createHive
POST {{baseUrl}}/locations/{{locationId}}/hives
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My SIXTH Hive",
  "description": "Newly established hive with a strong queen.",
  "is_active": true
}

###

// --- 1. GET all Hives for a Location ---
// @name getAllHives
GET {{baseUrl}}/locations/{{locationId}}/hives
Authorization: Bearer {{token}}

###

// --- 2. GET a single Hive by ID ---
// @name getHiveById
GET {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

###

// --- 3. Update an existing Hive ---
// @name updateHive
PUT {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My Updated Hive Name",
  "description": "Updated notes after a routine check."
}

###

// --- 4. DELETE a Hive ---
// @name deleteHive
DELETE {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

// filepath: routes\manual-tests\locations\locations.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI


### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

###
# @name createLocation
# Creates a new location.
@token2 = {{authenticate.response.body.token}}
POST {{baseUrl}}/locations
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Apiary 1",
  "address": "123 Main St, Anytown",
  "latitude": 46.0569,
  "longitude": 14.5058,
  "notes": "Main apiary location.",
  "country": "Slovenia"
}

###
# Get all locations for the authenticated user.
# @name getLocations
GET {{baseUrl}}/locations
Authorization: Bearer {{authenticate.response.body.token}}

###
# Get map data for all beehive locations.
# @name getMapData
GET {{baseUrl}}/locations/map
Authorization: Bearer {{token2}}

###
# Get a specific location by ID.
#
# To run this, first run the `createLocation` request and copy the `location_id` from the response.
# @locationId = <paste_location_id_here>
@locationId = {{createLocation.response.body.data.location_id}}
# Use the commented line below if you prefer to set the ID manually
# @locationId =
GET {{baseUrl}}/locations/{{locationId}}
Authorization: Bearer {{token}}

###
# Update a specific location by ID.
#
# To run this, you must first have a valid `locationId` from the `createLocation` request.
PUT {{baseUrl}}/locations/{{locationId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Main Apiary - Updated",
  "notes": "Updated notes for the main apiary."
}

###
# Delete a specific location by ID.
#
# To run this, you must have a valid `locationId` that has not already been deleted.
#DELETE {{baseUrl}}/locations/{{locationId}}
DELETE {{baseUrl}}/locations/2af520b3-c43a-47a8-9372-f1a3e819513b
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\majorInspections\majorInspections.http
###
# Major Inspections API Tests
#
# This file assumes you have already run the `locations.http` tests and have a valid token and location ID.
#
@baseUrl = http://localhost:3000/api/v1
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
# @locationId = <paste_your_location_id_here>

@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8

###
# Create a new major inspection for a specific location.
# @name createMajorInspection
POST {{baseUrl}}/locations/{{locationId}}/major-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "inspection_date": "2024-09-08T10:00:00.000Z",
  "general_notes": "This is temporary test foobar record."
}

###
# Get all major inspections for a specific location.
# @name getMajorInspections
GET {{baseUrl}}/locations/{{locationId}}/major-inspections
Authorization: Bearer {{token}}

###
# Get a specific major inspection by ID.
#
# To run this, first run the `createMajorInspection` request and copy the `major_inspection_id`.
# @majorInspectionId = <paste_major_inspection_id_here>
@majorInspectionId = {{createMajorInspection.response.body.data.major_inspection_id}}
GET {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId`.
PUT {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "general_notes": "Updated notes: Queen seems healthy."
}

###
# Delete a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
#DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/dee8f057-9efb-463b-93da-76ccfad03a54
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\users\user_requests.http
### Check HEALTH Endpoint
# @name checkHealth
GET http://localhost:3000/api/v1/health
Content-Type: application/json    


### Register a New User
###
# @name registerUser
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "TonyClark",
  "email": "tonyclark@gmail.com",
  "password": "password1234"
}

### Register a User with Existing Email (Expected: 409 Conflict)
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "anotheruser",
  "email": "test2@example.com",
  "password": "anotherpassword"
}


### Login with Valid Credentials
# @name loginValidUser
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json
Accept: application/json

{
    "email" : "tonyclark@gmail.com",    
    "password" : "password1234"
}

### Login with Invalid Password (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "tonyclark@gmail.com",
  "password": "password1234"
} 

### Login with Non-Existent Email (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez55@gmail.com",
    "password" : "Cada_73NUN5"
}

### Get Current User (without token - Expected: 401 Unauthorized)
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json

### Get Current User (with valid token)
# Replace {{authToken}} with the token received from a successful login request
@token2 = {{loginValidUser.response.body.token}}
GET http://localhost:3000/api/v1/auth/me
Content-Type: application/json
Authorization: Bearer {{token2}}


### Logout User
# This request is mainly for demonstration/logging purposes on the server.
# The real logout happens on the client by deleting the token.
POST http://localhost:3000/api/v1/auth/logout
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later

const startServer = async () => {
  try {
    const testVar: any = 'This should trigger a warning';
    // 1. Connect to the database
    console.log('Attempting to connect to the database...');
    await connectDB();
    console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`âš¡ï¸[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\nðŸ™ˆ-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('âŒ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log('startServer();');
startServer();


// filepath: services\dto\hive-inspection.dto.ts
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

export type HiveInspectionServiceCreateDTO = Omit<hive_inspectionsAttributes, 'hive_inspection_id' | 'created_at' | 'updated_at'>;
export type HiveInspectionServiceUpdateDTO = Partial<HiveInspectionServiceCreateDTO>;
export type HiveInspectionServiceRetrievedDTO = hive_inspectionsAttributes;


// filepath: services\dto\hive-service.dto.ts
import { hivesAttributes } from 'database/models-ts/hives.js';

// Input for creating a new hive (omits ID and timestamps)
export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Input for updating a hive (all fields optional, omits foreign key and IDs)
export type HiveServiceUpdateDTO = Partial<HiveServiceCreateDTO>;

// Output/Retrieved DTO for a hive
export type HiveServiceRetrievedDTO = hivesAttributes;


// filepath: services\dto\location-service.dto.ts
import { locationsAttributes } from '../../database/models-ts/locations.js';

// Location domain types - for creating, updating, and retrieving location data
// The service layer uses these DTOs to enforce data shape and decouple from Sequelize's model attributes.

// Data required to create a new location
export type LocationServiceCreateDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;

// Data used to update an existing location (all fields optional)
export type LocationServiceUpdateDTO = Partial<Omit<LocationServiceCreateDTO, 'user_id'>>;

// Data shape of a fully retrieved location record
export type LocationServiceRetrievedDTO = locationsAttributes;


// filepath: services\dto\major-inspection-service.dto.ts
import { major_inspectionsAttributes, major_inspections } from 'database/models-ts/major-inspections.js';

export type MajorInspectionServiceCreateDTO = Omit<major_inspectionsAttributes, 'major_inspection_id' | 'created_at' | 'updated_at'>;
export type MajorInspectionServiceUpdateDTO = Partial<MajorInspectionServiceCreateDTO>;
export type MajorInspectionServiceRetrievedDTO = major_inspectionsAttributes;


// filepath: services\dto\user-service.dto.ts
import { usersAttributes } from '../../database/models-ts/users.js';

// User domain types - for creating, updating, and retrieving user data ... called on the services layer
export type UserCreationDTO = Omit<usersAttributes, 'user_id' | 'created_at' | 'updated_at' | 'google_id' | 'linkedin_id'>;
export type UserUpdateDTO = Partial<UserCreationDTO>;
export type UserRetrievedDTO = Omit<usersAttributes, 'google_id' | 'linkedin_id'>;


// filepath: services\hive-inspection-service.ts
// src/services/hiveInspectionService.ts

import { hive_inspections } from '../database/models-ts/hive_inspections.js';
//import { major_inspections } from 'database/models-ts/major_inspections.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js'; // Importing the type for hive inspection attributes
//import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
//import { HiveInspectionCreationAttributes } from '../database/models-obsolete/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(hiveInspectionData: hive_inspectionsAttributes): Promise<hive_inspectionsAttributes> {
    const newHiveInspection = await hive_inspections.create({ ...hiveInspectionData });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(majorInspectionId: string): Promise<hive_inspectionsAttributes[]> {
    const hiveInspections = await hive_inspections.findAll({ where: { major_inspection_id: majorInspectionId }, order: [['created_at', 'ASC']] });
    return hiveInspections.map((hi) => hi.toJSON());
  }

  public static async getHiveInspectionById(id: string, majorInspectionId: string): Promise<hive_inspectionsAttributes | null> {
    const hiveInspection = await hive_inspections.findOne({ where: { hive_inspection_id: id, major_inspection_id: majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(id: string, majorInspectionId: string, updateData: Partial<hive_inspectionsAttributes>): Promise<hive_inspectionsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await hive_inspections.update(updateData, {
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(id: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await hive_inspections.destroy({
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
    });
    return deletedRows > 0;
  }

  /**
   * Retrieves hive inspections for a specific hive, ensuring both the hive itself
   * and its associated major inspection belong to the given location.
   * This enforces a strong authorization chain and filters results precisely.
   *
   * @param locationId The ID of the location to filter by.
   * @param hiveNumber The ID of the hive to filter by (corresponds to hive_id).
   * @returns A promise that resolves to an array of hive inspection attributes.
   */
  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<hive_inspectionsAttributes[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await hive_inspections.findAll({
      include: [
        {
          // 1. Include the 'majorInspection' association
          // This ensures the hive inspection is linked to a major inspection
          // that belongs to the specified location.
          association: 'majorInspection', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          where: { location_id: locationId }, // Filter major_inspections by their location_id column
          required: true, // Perform an INNER JOIN, meaning the major inspection must exist and match the locationId
        },
        {
          // 2. Include the 'hive' association
          // This ensures the hive inspection is linked to a hive
          // that also belongs to the specified location.
          association: 'hive', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          required: true, // Perform an INNER JOIN, meaning the hive must exist
          where: { location_id: locationId }, // Filter hives by their location_id column
        },
      ],
      where: {
        // 3. Filter the primary hive_inspections by the specific hive_id
        hive_id: hiveNumber,
      },
      order: [['created_at', 'ASC']],
    });
    return hiveInspections.map((hi) => hi.toJSON());
  }
}


// filepath: services\hive-service.ts
// src/services/hiveService.ts

//import { hives, hivesAttributes } from '../database/models-ts/hives.js';
import { IHiveRepository } from '../repositories/interfaces/i-hive-repository.js'; // repositories/interfaces/i-hive-repository.js';
import { HiveInspectionServiceRetrievedDTO } from './dto/hive-inspection.dto.js';
//import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';
//import { locations } from '../database/models-ts/locations.js';
import { HiveServiceCreateDTO, HiveServiceUpdateDTO, HiveServiceRetrievedDTO } from './dto/hive-service.dto.js';

export class HiveService {
  private _hiveRepository: IHiveRepository;

  constructor(private hiveRepository: IHiveRepository) {
    this._hiveRepository = hiveRepository;
  }

  // TODO MODIFY METHODS TO USE REPOSITORY INSTEAD OF DIRECT MODEL ACCESS
  /**
   * Retrieves all hives associated with a specific location, ensuring the location belongs to the user.
   * @param locationId The ID of the location to retrieve hives for.
   * @returns A promise that resolves to an array of hive objects.
   */
  public async getHivesByLocationId(locationId: string): Promise<HiveServiceRetrievedDTO[]> {
    const hivesFound: HiveServiceRetrievedDTO[] = await this._hiveRepository.findAllByLocationId(locationId); //  .findAll({

    return hivesFound;
  }

  /**
   * Retrieves a single hive by its ID and location ID, ensuring the location belongs to the user.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to retrieve.
   * @returns A promise that resolves to the hive object or null if not found.
   */
  public async getHiveById(locationId: string, hiveId: string): Promise<HiveServiceRetrievedDTO | null> {
    const hive = await this._hiveRepository.findById(hiveId, locationId); // .findOne({

    return hive ? hive : null;
  }

  /**
   * Creates a new hive for a given location.
   * @param hiveData The data for the new hive.
   * @returns A promise that resolves to the newly created hive object.
   */
  public async createHive(hiveData: HiveServiceCreateDTO): Promise<HiveServiceRetrievedDTO> {
    console.log('Service Creating hive...', hiveData);

    const newCreatedHive = await this._hiveRepository.create(hiveData);
    return newCreatedHive; //.toJSON();
  }

  /**
   * Updates an existing hive.
   * @param hiveId The ID of the hive to update.
   * @param updateData The data to update.
   * @returns A promise that resolves to the updated hive object or null if not found.
   */
  public async updateHive(hiveId: string, updateData: HiveServiceUpdateDTO): Promise<HiveServiceRetrievedDTO | null> {
    // Check if the hive exists and belongs to the user and location
    const hiveToUpdate = await this._hiveRepository.findById(hiveId);

    if (!hiveToUpdate) {
      return null;
    }

    const [numberOfAffectedRows, affectedRows] = await this._hiveRepository.update(hiveId, updateData);

    if (numberOfAffectedRows === 0) {
      return null;
    }

    return affectedRows[0];
  }

  /**
   * Deletes a hive by its ID and location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to delete.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteHive(locationId: string, hiveId: string): Promise<boolean> {
    console.log('Service (deleteHive) Deleting hive...', locationId, hiveId);

    // if the location is given, the Hive ID must belong to that Location
    const hiveToDelete = await this._hiveRepository.findById(hiveId, locationId);

    if (!hiveToDelete) {
      return false;
    }

    console.log('Service (deleteHive) Found hive to delete:', hiveToDelete);

    const deletedRows = await this.hiveRepository.delete(hiveId, locationId);

    return deletedRows > 0;
  }

  /**
   * Deletes all hives by their location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public async deleteAllHives(locationId: string): Promise<boolean> {
    const deletedRows = await this._hiveRepository.deleteAll(locationId);

    return deletedRows > 0;
  }
}


// filepath: services\location-service.ts
import { ILocationRepository } from '../repositories/interfaces/i-location-repository.js';
import { LocationServiceRetrievedDTO, LocationServiceCreateDTO, LocationServiceUpdateDTO } from './dto/location-service.dto.js';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

export class LocationService {
  private readonly locationRepository: ILocationRepository;

  // Dependency Injection: Injecting the repository contract
  constructor(locationRepository: ILocationRepository) {
    this.locationRepository = locationRepository;
  }

  /**
   * Creates a new location entry.
   * @param locationData The data for the new location, including user_id.
   * @returns The created location DTO.
   */
  public async createLocation(locationData: LocationServiceCreateDTO): Promise<LocationServiceRetrievedDTO> {
    // No complex business logic here yet (e.g., uniqueness checks), so delegate directly.
    return this.locationRepository.create(locationData);
  }

  /**
   * Retrieves all locations belonging to a specific user.
   * @param userId The ID of the owner.
   * @returns An array of location DTOs.
   */
  public async getAllLocationsByUserId(userId: string): Promise<LocationServiceRetrievedDTO[]> {
    return this.locationRepository.findAllByUserId(userId);
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public async getLocationById(locationId: string): Promise<LocationServiceRetrievedDTO | null> {
    const _loc = await this.locationRepository.findById(locationId);
    return _loc;
  }

  /**
   * Updates an existing location.
   * @param locationId The ID of the location to update.
   * @param updateData The fields to update.
   * @returns The updated location DTO.
   */
  public async updateLocation(locationId: string, updateData: LocationServiceUpdateDTO): Promise<LocationServiceRetrievedDTO> {
    // Check if the location exists before updating
    const existingLocation = await this.locationRepository.findById(locationId);
    if (!existingLocation) {
      const error = new Error('Location not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    const [updatedCount, updatedLocations] = await this.locationRepository.update(locationId, updateData);

    if (updatedCount > 1) {
      // This error indicates a serious issue in the repository or ORM logic
      const error = new Error(`Failed to update location with ID ${locationId}. Concurrency issue suspected.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      // Should not happen after the initial existence check, but is a safety net
      const error = new Error(`Location with ID ${locationId} not found during update.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    // Return the single updated location DTO
    return updatedLocations[0];
  }

  /**
   * Deletes a location.
   * @param locationId The ID of the location to delete.
   * @returns The number of records deleted (should be 1).
   */
  public async deleteLocation(locationId: string): Promise<number> {
    // Optional: Add pre-delete check or business logic here (e.g., cannot delete if hives are present)
    return this.locationRepository.delete(locationId);
  }

  /**
   * Checks if a location is owned by a specific user. Helpful for authorization middleware checks
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns True if the location is owned by the user, false otherwise.
   */
  public async checkLocationOwnership(locationId: string, userId: string): Promise<boolean> {
    const location = await this.locationRepository.findById(locationId);
    return location ? location.user_id === userId : false;
  }
}


// filepath: services\major-inspection-service.ts
// src/services/majorInspectionService.ts

//import { MajorInspection } from '../database/models-obsolete/MajorInspection.js'  ;
import { major_inspections } from '../database/models-ts/major-inspections.js'; // Updated to use the new TypeScript model
import { major_inspectionsAttributes } from '../database/models-ts/major-inspections.js'; // Importing the type for major inspection attributes
import { locations } from '../database/models-ts/locations.js';
//import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
//import {MajorInspectionCreationAttributes} from '../database/models/MajorInspection'; // Import the creation attributes type
//import { CreateMajorInspectionDto, UpdateHiveInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class MajorInspectionService {
  public static async createMajorInspection(location_id: string, inspectionData: major_inspectionsAttributes): Promise<major_inspectionsAttributes> {
    console.log('Creating major inspection with data:', location_id, inspectionData);
    // Convert inspectionDate string from DTO to a Date object
    const newInspectionDate = new Date(inspectionData.inspection_date);

    // Create the object to be passed to Sequelize.create()
    const inspectionDataForCreation = {
      ...inspectionData,
      //inspection_date: new Date(inspectionData.inspection_date),
      location_id: location_id, // Ensure the location_id is set correctly
    };

    console.log('Inspection data for creation via sequelize:', inspectionDataForCreation);
    const newMajorInspection = await major_inspections.create({
      ...inspectionDataForCreation,
    });

    return newMajorInspection.toJSON();
  }

  public static async getMajorInspectionsByLocationId(locationId: string): Promise<major_inspectionsAttributes[]> {
    const majorInspections = await major_inspections.findAll({
      where: { location_id: locationId },
      order: [['inspection_date', 'DESC']],
    });
    return majorInspections.map((mi) => mi.toJSON());
  }

  public static async getMajorInspectionById(
    // ZAKAJ MI TO 2x klice z razlicnim vrstnim redom argumentov???????????
    userId: string, // Check ownership by userId
    majorInspectionId: string,
    locationId: string
  ): Promise<major_inspectionsAttributes | null> {
    console.log(`Fetching major inspection by ID...\nmajorInspectionId: ${majorInspectionId}\nlocationId: ${locationId}\nuserId: ${userId}`);

    try {
      const majorInspection = await major_inspections.findOne({
        where: { major_inspection_id: majorInspectionId, location_id: locationId },
      });
    } catch (error) {
      console.error('TEST Error fetching major inspection by ID:', error);
    }

    const majorInspection = await major_inspections.findOne({
      where: { major_inspection_id: majorInspectionId, location_id: locationId },
      include: [
        {
          association: 'majorInspection_location', // Make sure this matches your association name in the MajorInspection model

          where: { location_id: locationId, user_id: userId }, // Ensure the location belongs to the user
          required: true,
        },
      ],
    });
    return majorInspection ? majorInspection.toJSON() : null;
  }

  public static async updateMajorInspection(
    locationId: string,
    majorInspectionId: string,
    updateData: major_inspectionsAttributes
    // Partial<MajorInspectionInterface>
  ): Promise<major_inspectionsAttributes | null> {
    console.log('Updating major inspection service..', majorInspectionId, locationId, updateData);
    const [numberOfAffectedRows, affectedRows] = await major_inspections.update(updateData, {
      where: { location_id: locationId, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteMajorInspection(userId: string, locationId: string, majorInspectionId: string): Promise<boolean> {
    console.log('Deleting major inspection service..', majorInspectionId, locationId, userId);
    // Step 1: Find the major inspection ID that matches all criteria
    const majorInspectionToDelete = await major_inspections.findOne({
      attributes: ['major_inspection_id'], // Only select the ID to minimize data transfer
      where: {
        major_inspection_id: majorInspectionId,
      },
      include: [
        {
          model: locations,
          //as: 'location', // Ensure this matches your association alias
          as: 'majorInspection_location',
          attributes: [],
          where: {
            location_id: locationId,
            user_id: userId, // Ensure the location belongs to the user
          },
          required: true, // This acts as an INNER JOIN, ensuring all conditions must be met
        },
      ],
    });

    if (!majorInspectionToDelete) {
      // No matching major inspection found for the given user, location, and majorInspectionId
      return false;
    }

    // Step 2: Delete the identified major inspection
    const deletedRows = await major_inspections.destroy({
      where: {
        major_inspection_id: majorInspectionToDelete.toJSON().major_inspection_id,
      },
    });

    return deletedRows > 0;
  }
}


// filepath: services\user-service.ts
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user creation attributes
import { IUserRepository } from '../repositories/interfaces/i-user-repository.js'; // The contract
import { UserRetrievedDTO, UserCreationDTO, UserUpdateDTO } from './dto/user-service.dto.js'; // The data shapes
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

// This class handles business logic (e.g., uniqueness check, error handling). No direct access to DB, just through repository.
export class UserService {
  private readonly userRepository: IUserRepository;
  constructor(userRepository: IUserRepository) {
    this.userRepository = userRepository;
  }

  public async findUserByEmail(email: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readByEmail(email);
  }

  public async findUserById(id: string): Promise<UserRetrievedDTO | null> {
    return this.userRepository.readById(id);
  }

  public async createUser(userData: UserCreationDTO): Promise<UserRetrievedDTO> {
    // Check if user already exists (Business Logic)
    const existingUser = await this.userRepository.readByEmail(userData.email);
    if (existingUser) {
      // Throw a specific error that the Controller/ErrorHandler can catch
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = httpStatus.CONFLICT; // 409
      throw error;
    }

    // Delegate the creation to the repository (Data Access)
    return this.userRepository.create(userData);
  }

  public async updateUser(id: string, userData: Partial<UserUpdateDTO>): Promise<UserRetrievedDTO> {
    // Check if user exists
    const existingUser = await this.userRepository.readById(id);
    if (!existingUser) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = httpStatus.NOT_FOUND; // 404
      throw error;
    }

    // Delegate the update to the repository (Data Access)
    const [updatedCount, updatedUsers] = await this.userRepository.update(id, userData);

    if (updatedCount > 1) {
      const error = new Error(`Failed to update user with ID ${id}.`) as CustomError;
      error.statusCode = httpStatus.INTERNAL_SERVER_ERROR;
      throw error;
    }
    if (updatedCount === 0) {
      const error = new Error(`User with ID ${id} not found.`) as CustomError;
      error.statusCode = httpStatus.NOT_FOUND;
      throw error;
    }

    return updatedUsers[0]; // decide for later if you want to return array or single object
  }
}


// filepath: summarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary3.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach((file) => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();


// filepath: types\DTO\per-controller\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
//import { User as UserInterface } from './models.js'; // Assuming your User interface is here
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user attributes
import { usersAttributes } from 'database/models-ts/users.js';

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<usersAttributes, 'password_hash'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  // user?: AuthenticatedUser; // The authenticated user's details
}


// filepath: types\DTO\per-controller\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from '../../foobar.js';

// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto {
  // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.


// filepath: types\DTO\per-controller\location-dto.ts
import { locationsAttributes } from '../../../database/models-ts/locations.js';

// Location domain types
export type LocationCreationDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;
export type LocationUpdateDTO = Partial<Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>>;
export type LocationRetrievedDTO = Omit<locationsAttributes, ''>;


// filepath: types\DTO\per-controller\response-types\locationControlDTOs.ts
// DTO for creating a Location

export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}
// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)

export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}

// DTO for retrieving a Location
export interface LocationRetrievedDto {
  location_id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null;
}


// filepath: types\DTO\per-controller\response-types\userControlDTOs.ts
// // incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

// export interface RegisterUserIncomingDTO {
//   username: string;
//   email: string;
//   password: string; // Password is required for direct registration
// }
// // outgoing DTO for authentication response

// export interface RegisterUserOutgoingDTO {
//   success: boolean;
//   message: string;
//   user: {
//     id: string;
//     username: string;
//     email: string;
//   };
// }
// // DTO for user update (all fields optional)

// export interface UpdateUserIncomingDTO {
//   username?: string;
//   email?: string;
//   password?: string;
// }

// export type GetMeUserOutgoingDTO = Omit<RegisterUserOutgoingDTO, 'pass'>;

// // DTO for user login
// export type LoginUserOutgoingDTO = RegisterUserOutgoingDTO & {
//   token: string;
// };

// export interface LoginUserIncomingDTO {
//   email: string;
//   password: string;
// }


// filepath: types\DTO\per-controller\user-dto.ts
//import { hivesAttributes } from '../../../database/models-ts/hives.js';
import { major_inspectionsAttributes } from '../../../database/models-ts/major-inspections.js';
import { hive_inspectionsAttributes } from '../../../database/models-ts/hive_inspections.js';

// Hive domain types
//export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Major Inspection domain types
export type MajorInspectionDTO = Omit<major_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;

// Hive Inspection domain types
export type HiveInspectionDTO = Omit<hive_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;


// filepath: types\express.d.ts
import { usersAttributes } from '../database/models-ts/users.js';

declare global {
  namespace Express {
    // Define the shape of the authenticated user object that will be attached to req.user.
    // This interface merges your usersAttributes with the Express.User expectation of an 'id' property.
    interface DedicatedUser {
      id: string; // The required 'id' property, which will be populated by usersAttributes.user_id
    }

    // Extend the Request interface to correctly type the 'user' property.
    interface Request {
      currentUser?: DedicatedUser; // Use the newly defined 'User' interface for req.user
    }
  }
}


// filepath: types\foobar.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    created_at: Date;
    updated_at: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: types\jest.d.ts
// src/types/jest.d.ts
import '@types/jest';


// filepath: utils\converters\location\controller-to-service.mapper.ts
import { LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from '../../../controllers/dto/location-controller.dto.js'; //'../../../src/controlcontroller/location-controller-create-input.dto';
import { LocationServiceCreateDTO, LocationServiceUpdateDTO } from '../../../services/dto/location-service.dto.js';

export class LocationControllerToServiceMapper {
  // Helper to parse numbers safely
  private static parseNumber(value: any): number | null {
    const parsed = Number(value);
    return isNaN(parsed) ? null : parsed;
  }

  // Map controller input DTO to service input DTO
  static toServiceCreateDTO(controllerDTO: LocationControllerCreateInputDTO, userId: string): LocationServiceCreateDTO {
    return {
      user_id: userId,
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }

  static toServiceUpdateDTO(controllerDTO: LocationControllerUpdateInputDTO, userId: string): LocationServiceUpdateDTO {
    return {
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }
}


// filepath: utils\converters\location\service-to-controller.mapper.ts
import { LocationServiceRetrievedDTO } from '../../../services/dto/location-service.dto.js';
import { LocationControllerOutputDTO, LocationControllerListOutputDTO } from '../../../controllers/dto/location-controller.dto.js';

export class LocationServiceToControllerMapper {
  private static parseNumber(value: string | number | undefined): number | undefined {
    if (value === undefined || value === null) return undefined;
    const n = typeof value === 'string' ? parseFloat(value) : value;
    return Number.isNaN(Number(n)) ? undefined : Number(n);
  }

  // Map service retrieved DTO to controller output DTO
  static toControllerOutputDTO(serviceDTO: LocationServiceRetrievedDTO, msq: string, success: boolean = true): LocationControllerOutputDTO {
    return {
      success: success,
      message: msq,
      location: {
        id: serviceDTO.location_id ?? '',
        userId: serviceDTO.user_id,
        name: serviceDTO.name,
        address: serviceDTO.address,
        latitude: this.parseNumber(serviceDTO.latitude),
        longitude: this.parseNumber(serviceDTO.longitude),
        description: serviceDTO.notes,
        createdAt: serviceDTO.created_at ? String(serviceDTO.created_at) : new Date().toISOString(),
        updatedAt: serviceDTO.updated_at ? String(serviceDTO.updated_at) : new Date().toISOString(),
      },
    };
  }

  // Map service list retrieved DTO to controller list output DTO
  static toControllerListOutputDTO(serviceDTOs: LocationServiceRetrievedDTO[], msq: string, success: boolean = true): LocationControllerListOutputDTO {
    return {
      success: success,
      message: msq ?? 'Locations retrieved successfully!',
      locations: serviceDTOs.map((dto) => this.toControllerOutputDTO(dto, msq, success).location),
    };
  }
}


// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '192h', // Token expires in 8 days
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};




// filepath: summarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary3.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach((file) => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();


// filepath: types\DTO\per-controller\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
//import { User as UserInterface } from './models.js'; // Assuming your User interface is here
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user attributes
import { usersAttributes } from 'database/models-ts/users.js';

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<usersAttributes, 'password_hash'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  // user?: AuthenticatedUser; // The authenticated user's details
}


// filepath: types\DTO\per-controller\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from '../../foobar.js';

// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto {
  // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.


// filepath: types\DTO\per-controller\location-dto.ts
import { locationsAttributes } from '../../../database/models-ts/locations.js';

// Location domain types
export type LocationCreationDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;
export type LocationUpdateDTO = Partial<Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>>;
export type LocationRetrievedDTO = Omit<locationsAttributes, ''>;


// filepath: types\DTO\per-controller\response-types\locationControlDTOs.ts
// DTO for creating a Location

export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}
// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)

export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}

// DTO for retrieving a Location
export interface LocationRetrievedDto {
  location_id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null;
}


// filepath: types\DTO\per-controller\response-types\userControlDTOs.ts
// // incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

// export interface RegisterUserIncomingDTO {
//   username: string;
//   email: string;
//   password: string; // Password is required for direct registration
// }
// // outgoing DTO for authentication response

// export interface RegisterUserOutgoingDTO {
//   success: boolean;
//   message: string;
//   user: {
//     id: string;
//     username: string;
//     email: string;
//   };
// }
// // DTO for user update (all fields optional)

// export interface UpdateUserIncomingDTO {
//   username?: string;
//   email?: string;
//   password?: string;
// }

// export type GetMeUserOutgoingDTO = Omit<RegisterUserOutgoingDTO, 'pass'>;

// // DTO for user login
// export type LoginUserOutgoingDTO = RegisterUserOutgoingDTO & {
//   token: string;
// };

// export interface LoginUserIncomingDTO {
//   email: string;
//   password: string;
// }


// filepath: types\DTO\per-controller\user-dto.ts
//import { hivesAttributes } from '../../../database/models-ts/hives.js';
import { major_inspectionsAttributes } from '../../../database/models-ts/major-inspections.js';
import { hive_inspectionsAttributes } from '../../../database/models-ts/hive_inspections.js';

// Hive domain types
//export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Major Inspection domain types
export type MajorInspectionDTO = Omit<major_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;

// Hive Inspection domain types
export type HiveInspectionDTO = Omit<hive_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;


// filepath: types\express.d.ts
import { usersAttributes } from '../database/models-ts/users.js';

declare global {
  namespace Express {
    // Define the shape of the authenticated user object that will be attached to req.user.
    // This interface merges your usersAttributes with the Express.User expectation of an 'id' property.
    interface DedicatedUser {
      id: string; // The required 'id' property, which will be populated by usersAttributes.user_id
    }

    // Extend the Request interface to correctly type the 'user' property.
    interface Request {
      currentUser?: DedicatedUser; // Use the newly defined 'User' interface for req.user
    }
  }
}


// filepath: types\foobar.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    created_at: Date;
    updated_at: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: types\jest.d.ts
// src/types/jest.d.ts
import '@types/jest';


// filepath: utils\converters\location\controller-to-service.mapper.ts
import { LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from '../../../controllers/dto/location-controller.dto.js'; //'../../../src/controlcontroller/location-controller-create-input.dto';
import { LocationServiceCreateDTO, LocationServiceUpdateDTO } from '../../../services/dto/location-service.dto.js';

export class LocationControllerToServiceMapper {
  // Helper to parse numbers safely
  private static parseNumber(value: any): number | null {
    const parsed = Number(value);
    return isNaN(parsed) ? null : parsed;
  }

  // Map controller input DTO to service input DTO
  static toServiceCreateDTO(controllerDTO: LocationControllerCreateInputDTO, userId: string): LocationServiceCreateDTO {
    return {
      user_id: userId,
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }

  static toServiceUpdateDTO(controllerDTO: LocationControllerUpdateInputDTO, userId: string): LocationServiceUpdateDTO {
    return {
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }
}


// filepath: utils\converters\location\service-to-controller.mapper.ts
import { LocationServiceRetrievedDTO } from '../../../services/dto/location-service.dto.js';
import { LocationControllerOutputDTO, LocationControllerListOutputDTO } from '../../../controllers/dto/location-controller.dto.js';

export class LocationServiceToControllerMapper {
  private static parseNumber(value: string | number | undefined): number | undefined {
    if (value === undefined || value === null) return undefined;
    const n = typeof value === 'string' ? parseFloat(value) : value;
    return Number.isNaN(Number(n)) ? undefined : Number(n);
  }

  // Map service retrieved DTO to controller output DTO
  static toControllerOutputDTO(serviceDTO: LocationServiceRetrievedDTO, msq: string, success: boolean = true): LocationControllerOutputDTO {
    return {
      success: success,
      message: msq,
      location: {
        id: serviceDTO.location_id ?? '',
        userId: serviceDTO.user_id,
        name: serviceDTO.name,
        address: serviceDTO.address,
        latitude: this.parseNumber(serviceDTO.latitude),
        longitude: this.parseNumber(serviceDTO.longitude),
        description: serviceDTO.notes,
        createdAt: serviceDTO.created_at ? String(serviceDTO.created_at) : new Date().toISOString(),
        updatedAt: serviceDTO.updated_at ? String(serviceDTO.updated_at) : new Date().toISOString(),
      },
    };
  }

  // Map service list retrieved DTO to controller list output DTO
  static toControllerListOutputDTO(serviceDTOs: LocationServiceRetrievedDTO[], msq: string, success: boolean = true): LocationControllerListOutputDTO {
    return {
      success: success,
      message: msq ?? 'Locations retrieved successfully!',
      locations: serviceDTOs.map((dto) => this.toControllerOutputDTO(dto, msq, success).location),
    };
  }
}


// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '192h', // Token expires in 8 days
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};




// filepath: summarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary3.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach((file) => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();


// filepath: types\DTO\per-controller\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
//import { User as UserInterface } from './models.js'; // Assuming your User interface is here
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user attributes
import { usersAttributes } from 'database/models-ts/users.js';

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<usersAttributes, 'password_hash'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  // user?: AuthenticatedUser; // The authenticated user's details
}


// filepath: types\DTO\per-controller\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from '../../foobar.js';

// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto {
  // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.


// filepath: types\DTO\per-controller\location-dto.ts
import { locationsAttributes } from '../../../database/models-ts/locations.js';

// Location domain types
export type LocationCreationDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;
export type LocationUpdateDTO = Partial<Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>>;
export type LocationRetrievedDTO = Omit<locationsAttributes, ''>;


// filepath: types\DTO\per-controller\response-types\locationControlDTOs.ts
// DTO for creating a Location

export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}
// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)

export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}

// DTO for retrieving a Location
export interface LocationRetrievedDto {
  location_id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null;
}


// filepath: types\DTO\per-controller\response-types\userControlDTOs.ts
// // incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

// export interface RegisterUserIncomingDTO {
//   username: string;
//   email: string;
//   password: string; // Password is required for direct registration
// }
// // outgoing DTO for authentication response

// export interface RegisterUserOutgoingDTO {
//   success: boolean;
//   message: string;
//   user: {
//     id: string;
//     username: string;
//     email: string;
//   };
// }
// // DTO for user update (all fields optional)

// export interface UpdateUserIncomingDTO {
//   username?: string;
//   email?: string;
//   password?: string;
// }

// export type GetMeUserOutgoingDTO = Omit<RegisterUserOutgoingDTO, 'pass'>;

// // DTO for user login
// export type LoginUserOutgoingDTO = RegisterUserOutgoingDTO & {
//   token: string;
// };

// export interface LoginUserIncomingDTO {
//   email: string;
//   password: string;
// }


// filepath: types\DTO\per-controller\user-dto.ts
//import { hivesAttributes } from '../../../database/models-ts/hives.js';
import { major_inspectionsAttributes } from '../../../database/models-ts/major-inspections.js';
import { hive_inspectionsAttributes } from '../../../database/models-ts/hive_inspections.js';

// Hive domain types
//export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Major Inspection domain types
export type MajorInspectionDTO = Omit<major_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;

// Hive Inspection domain types
export type HiveInspectionDTO = Omit<hive_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;


// filepath: types\express.d.ts
import { usersAttributes } from '../database/models-ts/users.js';

declare global {
  namespace Express {
    // Define the shape of the authenticated user object that will be attached to req.user.
    // This interface merges your usersAttributes with the Express.User expectation of an 'id' property.
    interface DedicatedUser {
      id: string; // The required 'id' property, which will be populated by usersAttributes.user_id
    }

    // Extend the Request interface to correctly type the 'user' property.
    interface Request {
      currentUser?: DedicatedUser; // Use the newly defined 'User' interface for req.user
    }
  }
}


// filepath: types\foobar.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    created_at: Date;
    updated_at: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: types\jest.d.ts
// src/types/jest.d.ts
import '@types/jest';


// filepath: utils\converters\location\controller-to-service.mapper.ts
import { LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from '../../../controllers/dto/location-controller.dto.js'; //'../../../src/controlcontroller/location-controller-create-input.dto';
import { LocationServiceCreateDTO, LocationServiceUpdateDTO } from '../../../services/dto/location-service.dto.js';

export class LocationControllerToServiceMapper {
  // Helper to parse numbers safely
  private static parseNumber(value: any): number | null {
    const parsed = Number(value);
    return isNaN(parsed) ? null : parsed;
  }

  // Map controller input DTO to service input DTO
  static toServiceCreateDTO(controllerDTO: LocationControllerCreateInputDTO, userId: string): LocationServiceCreateDTO {
    return {
      user_id: userId,
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }

  static toServiceUpdateDTO(controllerDTO: LocationControllerUpdateInputDTO, userId: string): LocationServiceUpdateDTO {
    return {
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }
}


// filepath: utils\converters\location\service-to-controller.mapper.ts
import { LocationServiceRetrievedDTO } from '../../../services/dto/location-service.dto.js';
import { LocationControllerOutputDTO, LocationControllerListOutputDTO } from '../../../controllers/dto/location-controller.dto.js';

export class LocationServiceToControllerMapper {
  private static parseNumber(value: string | number | undefined): number | undefined {
    if (value === undefined || value === null) return undefined;
    const n = typeof value === 'string' ? parseFloat(value) : value;
    return Number.isNaN(Number(n)) ? undefined : Number(n);
  }

  // Map service retrieved DTO to controller output DTO
  static toControllerOutputDTO(serviceDTO: LocationServiceRetrievedDTO, msq: string, success: boolean = true): LocationControllerOutputDTO {
    return {
      success: success,
      message: msq,
      location: {
        id: serviceDTO.location_id ?? '',
        userId: serviceDTO.user_id,
        name: serviceDTO.name,
        address: serviceDTO.address,
        latitude: this.parseNumber(serviceDTO.latitude),
        longitude: this.parseNumber(serviceDTO.longitude),
        description: serviceDTO.notes,
        createdAt: serviceDTO.created_at ? String(serviceDTO.created_at) : new Date().toISOString(),
        updatedAt: serviceDTO.updated_at ? String(serviceDTO.updated_at) : new Date().toISOString(),
      },
    };
  }

  // Map service list retrieved DTO to controller list output DTO
  static toControllerListOutputDTO(serviceDTOs: LocationServiceRetrievedDTO[], msq: string, success: boolean = true): LocationControllerListOutputDTO {
    return {
      success: success,
      message: msq ?? 'Locations retrieved successfully!',
      locations: serviceDTOs.map((dto) => this.toControllerOutputDTO(dto, msq, success).location),
    };
  }
}


// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '192h', // Token expires in 8 days
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};




// filepath: summarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary3.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach((file) => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();


// filepath: types\DTO\per-controller\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
//import { User as UserInterface } from './models.js'; // Assuming your User interface is here
//import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user attributes
import { usersAttributes } from 'database/models-ts/users.js';

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<usersAttributes, 'password_hash'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  // user?: AuthenticatedUser; // The authenticated user's details
}


// filepath: types\DTO\per-controller\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from '../../foobar.js';

// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto {
  // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.


// filepath: types\DTO\per-controller\location-dto.ts
import { locationsAttributes } from '../../../database/models-ts/locations.js';

// Location domain types
export type LocationCreationDTO = Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>;
export type LocationUpdateDTO = Partial<Omit<locationsAttributes, 'location_id' | 'created_at' | 'updated_at'>>;
export type LocationRetrievedDTO = Omit<locationsAttributes, ''>;


// filepath: types\DTO\per-controller\response-types\locationControlDTOs.ts
// DTO for creating a Location

export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}
// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)

export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}

// DTO for retrieving a Location
export interface LocationRetrievedDto {
  location_id: string;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null;
}


// filepath: types\DTO\per-controller\response-types\userControlDTOs.ts
// // incoming DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)

// export interface RegisterUserIncomingDTO {
//   username: string;
//   email: string;
//   password: string; // Password is required for direct registration
// }
// // outgoing DTO for authentication response

// export interface RegisterUserOutgoingDTO {
//   success: boolean;
//   message: string;
//   user: {
//     id: string;
//     username: string;
//     email: string;
//   };
// }
// // DTO for user update (all fields optional)

// export interface UpdateUserIncomingDTO {
//   username?: string;
//   email?: string;
//   password?: string;
// }

// export type GetMeUserOutgoingDTO = Omit<RegisterUserOutgoingDTO, 'pass'>;

// // DTO for user login
// export type LoginUserOutgoingDTO = RegisterUserOutgoingDTO & {
//   token: string;
// };

// export interface LoginUserIncomingDTO {
//   email: string;
//   password: string;
// }


// filepath: types\DTO\per-controller\user-dto.ts
//import { hivesAttributes } from '../../../database/models-ts/hives.js';
import { major_inspectionsAttributes } from '../../../database/models-ts/major-inspections.js';
import { hive_inspectionsAttributes } from '../../../database/models-ts/hive_inspections.js';

// Hive domain types
//export type HiveServiceCreateDTO = Omit<hivesAttributes, 'hive_id' | 'created_at' | 'updated_at'>;

// Major Inspection domain types
export type MajorInspectionDTO = Omit<major_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;

// Hive Inspection domain types
export type HiveInspectionDTO = Omit<hive_inspectionsAttributes, 'inspection_id' | 'created_at' | 'updated_at'>;


// filepath: types\express.d.ts
import { usersAttributes } from '../database/models-ts/users.js';

declare global {
  namespace Express {
    // Define the shape of the authenticated user object that will be attached to req.user.
    // This interface merges your usersAttributes with the Express.User expectation of an 'id' property.
    interface DedicatedUser {
      id: string; // The required 'id' property, which will be populated by usersAttributes.user_id
    }

    // Extend the Request interface to correctly type the 'user' property.
    interface Request {
      currentUser?: DedicatedUser; // Use the newly defined 'User' interface for req.user
    }
  }
}


// filepath: types\foobar.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    created_at: Date;
    updated_at: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: types\jest.d.ts
// src/types/jest.d.ts
import '@types/jest';


// filepath: utils\converters\location\controller-to-service.mapper.ts
import { LocationControllerCreateInputDTO, LocationControllerUpdateInputDTO } from '../../../controllers/dto/location-controller.dto.js'; //'../../../src/controlcontroller/location-controller-create-input.dto';
import { LocationServiceCreateDTO, LocationServiceUpdateDTO } from '../../../services/dto/location-service.dto.js';

export class LocationControllerToServiceMapper {
  // Helper to parse numbers safely
  private static parseNumber(value: any): number | null {
    const parsed = Number(value);
    return isNaN(parsed) ? null : parsed;
  }

  // Map controller input DTO to service input DTO
  static toServiceCreateDTO(controllerDTO: LocationControllerCreateInputDTO, userId: string): LocationServiceCreateDTO {
    return {
      user_id: userId,
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }

  static toServiceUpdateDTO(controllerDTO: LocationControllerUpdateInputDTO, userId: string): LocationServiceUpdateDTO {
    return {
      name: controllerDTO.name,
      address: controllerDTO.address,
      latitude: controllerDTO.latitude?.toString(),
      longitude: controllerDTO.longitude?.toString(),
      country: controllerDTO.country,
      notes: controllerDTO.notes,
    };
  }
}


// filepath: utils\converters\location\service-to-controller.mapper.ts
import { LocationServiceRetrievedDTO } from '../../../services/dto/location-service.dto.js';
import { LocationControllerOutputDTO, LocationControllerListOutputDTO } from '../../../controllers/dto/location-controller.dto.js';

export class LocationServiceToControllerMapper {
  private static parseNumber(value: string | number | undefined): number | undefined {
    if (value === undefined || value === null) return undefined;
    const n = typeof value === 'string' ? parseFloat(value) : value;
    return Number.isNaN(Number(n)) ? undefined : Number(n);
  }

  // Map service retrieved DTO to controller output DTO
  static toControllerOutputDTO(serviceDTO: LocationServiceRetrievedDTO, msq: string, success: boolean = true): LocationControllerOutputDTO {
    return {
      success: success,
      message: msq,
      location: {
        id: serviceDTO.location_id ?? '',
        userId: serviceDTO.user_id,
        name: serviceDTO.name,
        address: serviceDTO.address,
        latitude: this.parseNumber(serviceDTO.latitude),
        longitude: this.parseNumber(serviceDTO.longitude),
        description: serviceDTO.notes,
        createdAt: serviceDTO.created_at ? String(serviceDTO.created_at) : new Date().toISOString(),
        updatedAt: serviceDTO.updated_at ? String(serviceDTO.updated_at) : new Date().toISOString(),
      },
    };
  }

  // Map service list retrieved DTO to controller list output DTO
  static toControllerListOutputDTO(serviceDTOs: LocationServiceRetrievedDTO[], msq: string, success: boolean = true): LocationControllerListOutputDTO {
    return {
      success: success,
      message: msq ?? 'Locations retrieved successfully!',
      locations: serviceDTOs.map((dto) => this.toControllerOutputDTO(dto, msq, success).location),
    };
  }
}


// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '192h', // Token expires in 8 days
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};


