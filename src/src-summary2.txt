// filepath: .env
# Environment variables for MyHives App
PORT=3000

NODE_ENV=development
API_BASE_URL=http://localhost:3000/api

# Database Configuration
DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=Cada_2068_new # <--- IMPORTANT: Replace with your actual password!
DB_NAME=myhives_db                     # <--- IMPORTANT: Replace with the database name you created!

DATABASE_URL=postgresql://postgres:Cada_2068_new@localhost:5432/myhives_db
JWT_SECRET=my_jwt_super_dupper_secret_key


# Google OAuth Credentials
GOOGLE_CLIENT_ID="your_google_client_id"
GOOGLE_CLIENT_SECRET="your_google_client_secret"

# LinkedIn OAuth Credentials
LINKEDIN_CLIENT_ID="your_linkedin_client_id"
LINKEDIN_CLIENT_SECRET="your_linkedin_client_secret"

# Frontend URL for CORS and OAuth redirects
FRONTEND_URL="http://localhost:5173" # Or your deployed frontend URL


// filepath: appExpressInstance.ts
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import 'reflect-metadata';
import config from './config/index.js';
import errorHandler, { CustomError } from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
import authRoutes from './routes/authRoutes.js';
import locationRoutes from './routes/locationRoutes.js';
//import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
//  import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
// import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();
const apiRouter = express.Router(); // Create a new router instance

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(
  cors({
    origin: config.frontendUrl, // Allow requests from your frontend URL
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    credentials: true, // Allow cookies to be sent
  })
);

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// Mount your API router on the main app
app.use('/api/v1', apiRouter);

// --- Routes ---
// Basic health check route
apiRouter.get('/health', (req: Request, res: Response) => {
  console.log('🚑 Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');

// Mount your API routes here
apiRouter.use('/auth', authRoutes);

// For nested routes, you might pass sequelize instances or use controllers directly
//app.use('/locations/:locationId/major-inspections', majorInspectionRoutes);
// apiRouter.use(
//   '/locations/:locationId/major-inspections',
//   (req, res, next) => {
//     console.log('*** Mounting major inspection routes for location:');
//     next();
//   },
//   majorInspectionRoutes
// );
// app.use('/api/v1/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections', hiveInspectionRoutes);
apiRouter.use('/locations', locationRoutes);

console.log('API routes mounted');
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 404; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;


// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url);

// Get the current directory's path
const __dirname = path.dirname(__filename);

// Load environment variables from .env file
const dotEnvConfigObject = dotenv.config({ path: path.resolve(__dirname, '../../src/.env') });
console.log('dotenv config object:', dotEnvConfigObject);

// Define the IConfig interface
interface IConfig {
  port: number;
  nodeEnv: string;
  databaseUrl: string;
  jwtSecret: string;
  googleClientId: string;
  googleClientSecret: string;
  linkedinClientId: string;
  linkedinClientSecret: string;
  frontendUrl: string; // For CORS and OAuth redirects
}

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port
};

console.log('Config loaded:', config);
console.log('config.jwtSecret:', config.jwtSecret);

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
  console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
}
if (!config.databaseUrl || config.databaseUrl === 'unknown') {
  console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
}
if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
  console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
}

export default config;


// filepath: controllers\authController.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/userService.js'; // New service
import config from '../config/index.js';

export const register = async (req: Request, res: Response, next: NextFunction) => {
  console.log('Registering user:', req.body);
  try {
    const { username, email, password } = req.body;

    // Check if user already exists
    const existingUser = await UserService.findUserByEmail(email);
    if (existingUser) {
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = 409; // Conflict
      throw error;
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds = 10

    // Create user
    const newUser = await UserService.createUser({
      username,
      email,
      password_hash: hashedPassword,
    });

    // // Generate token (optional, could just return success message)
    // const token = generateToken({ userId: newUser.user_id! });

    res.status(201).json({
      success: true,
      message: 'User registered successfully! Please log in.',
      user: {
        id: newUser.user_id,
        username: newUser.username,
        email: newUser.email,
      },
    });
  } catch (error) {
    next(error);
  }
};

export const login = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { email, password } = req.body;

    const user = await UserService.findUserByEmail(email);
    if (!user || !user.password_hash) {
      // Check for user existence and if they have a password (for traditional login)
      const error = new Error('Invalid credentials.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    // Compare password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      const error = new Error('Invalid credentials.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    // Generate token
    const token = generateToken({ userId: user.user_id! });

    res.cookie('jwtcookie', token, {
      httpOnly: true,
      secure: config.nodeEnv === 'production',
      maxAge: 1000 * 3600 * 24 * 7, // 7 days in milliseconds
    });

    res.status(200).json({
      success: true,
      message: 'Logged in successfully!',
      token,
      user: {
        id: user.user_id,
        username: user.username,
        email: user.email,
      },
    });
  } catch (error) {
    next(error);
  }
};

export const logout = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // In a stateless JWT system, the server doesn't need to do much for logout.
    // The client simply discards the token.
    // However, it's good practice to send a success message.

    // If using HTTP-only cookies for tokens, you'd clear the cookie here.
    // For example:
    res.clearCookie('jwtcookie'); // Assuming your JWT is in a cookie named 'jwtcookie'

    // You might also want to do some logging for audit purposes
    console.log(`User ${req.currentUser?.id || 'unknown'} logged out.`);

    res.status(200).json({
      success: true,
      message: 'Logged out successfully.',
    });
  } catch (error) {
    next(error);
  }
};

export const getMe = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('getMe called');
    // req.user is set by the `authenticate` middleware
    if (!req.currentUser || !req.currentUser.id) {
      console.error('No currentUser found in request:', req.currentUser);
      const error = new Error('User not authenticated. - no currentUser') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    console.log('Current user ID:', req.currentUser.id);

    const user = await UserService.findUserById(req.currentUser.id);
    if (!user) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    console.log('User found:', user);

    // Return user data (excluding password)
    const { password_hash: password, ...userData } = user;
    res.status(200).json({ success: true, user: userData });
  } catch (error) {
    next(error);
  }
};

// --- OAuth Callbacks (simplified for illustration) ---
// In a real app, these would interact with Passport.js for robust OAuth strategies.
// For now, they're just placeholders to demonstrate the concept.

export const googleCallback = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // This part would typically be handled by Passport.js
    // For demo: assume Passport.js has successfully authenticated and added user info to req.user or req.account
    // Example: const { id: googleId, email, displayName } = req.user as any;
    // For now, let's mock it or rely on a successful Passport setup adding it to req.user

    // If Passport.js has successfully authenticated, req.user will contain the user data.
    // If not, this simple controller won't work correctly.
    // Assuming req.user contains the authenticated user from Passport.js or a mock:
    if (!req.currentUser || !req.currentUser.id) {
      const error = new Error('Google authentication failed.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    // For a real app, you'd use a more robust OAuth flow (e.g., Passport.js)
    // and extract user info from the OAuth provider's response.
    // For this example, let's simulate. In a real Passport.js setup,
    // the 'done' callback in your strategy would populate req.user.
    // We'd then create/find the user in our DB and generate a token.
    // This is a simplified direct token generation after (hypothetical) successful auth.

    // A real Google strategy would call done(null, userObject) if successful.
    // Then req.user would be populated.
    // We're skipping the Passport setup here for brevity.
    const authenticatedUser = await UserService.findUserById(req.currentUser.id); // Assuming req.user.id is populated by passport
    if (!authenticatedUser) {
      const error = new Error('User not found after Google authentication.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    const token = generateToken({ userId: authenticatedUser.user_id! });

    // Redirect to frontend with token (or send token directly, depending on frontend flow)
    // In a real scenario, you'd use a redirect to your frontend with the token
    // e.g., res.redirect(`${config.frontendUrl}/auth/callback?token=${token}`);
    res.status(200).json({ success: true, message: 'Google login successful', token });
  } catch (error) {
    next(error);
  }
};

export const linkedinCallback = async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.currentUser || !req.currentUser.id) {
      const error = new Error('LinkedIn authentication failed.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    const authenticatedUser = await UserService.findUserById(req.currentUser.id);
    if (!authenticatedUser) {
      const error = new Error('User not found after LinkedIn authentication.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    const token = generateToken({ userId: authenticatedUser.user_id! });
    res.status(200).json({ success: true, message: 'LinkedIn login successful', token });
  } catch (error) {
    next(error);
  }
};


// filepath: controllers\hiveController.ts
import { Request, Response, NextFunction } from 'express';
import { HiveService } from '../services/hiveService.js';
import { CustomError } from '../middleware/errorHandler.js';
import { hivesAttributes } from '../database/models-ts/hives.js';

// Get all hives
export const getAllHives = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Controller : Fetching hives...', req.params);

    const location_id = req.params.locationId;
    const hives = await HiveService.getHivesByLocationId(location_id);

    res.status(200).json({
      success: true,
      message: 'Hives fetched successfully',
      data: hives,
    });
  } catch (error) {
    //res.status(500).json({ error: 'Failed to fetch hives' });
    next(error);
  }
};

// Get hive by ID
const getHiveById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Controller : Fetching hive...', req.params);

    const location_id = req.params.locationId;
    const hive_id = req.params.hive_id;

    const hive = await HiveService.getHiveById(location_id, hive_id);

    if (!hive) {
      const error = new Error('Hive not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }
    res.status(200).json({
      success: true,
      message: 'Hive fetched successfully',
      data: hive,
    });
  } catch (error) {
    next(error);
  }
};

// Create a new hive
const createHive = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Creating hive...', req.params.locationId, req.body);
    const location_id = req.params.locationId;
    const hiveData = req.body;

    console.log('Hive data:', hiveData);

    const newHive = await HiveService.createHive(location_id, hiveData);

    res.status(201).json(newHive);
  } catch (error) {
    next(error);
  }
};

// Update a hive
const updateHive = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const location_id = req.params.locationId;
    const hive_id = req.params.hive_id;
    const updatedHiveData = req.body;

    const updatedHive = await HiveService.updateHive(location_id, hive_id, updatedHiveData);
    if (!updatedHive) {
      const error = new Error('Hive not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Hive updated successfully',
      data: updatedHive,
    });
  } catch (error) {
    next(error);
  }
};

// Delete a hive
const deleteHive = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const location_id = req.params.locationId;
    const hive_id = req.params.hive_id;

    console.log('Controller : Deleting hive...', req.params);

    const deleted = await HiveService.deleteHive(location_id, hive_id);
    if (!deleted) {
      const error = new Error('Hive not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Hive deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

// Delete all hives
const deleteAllHives = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const location_id = req.params.location_id;

    const deleted = await HiveService.deleteAllHives(location_id);
    if (!deleted) {
      const error = new Error('Hives not deleted.') as CustomError;
      error.statusCode = 404;
      throw error;
    }
    res.json({ message: 'Hives deleted successfully', success: true });
  } catch (error) {
    next(error);
  }
};

export default {
  getAllHives,
  getHiveById,
  createHive,
  updateHive,
  deleteHive,
  deleteAllHives,
};


// filepath: controllers\hiveInspectionController.ts
// src/controllers/hiveInspectionController.ts

import { Response, NextFunction } from 'express';
import { CustomRequest } from '../types/custom-request.js';
import { HiveInspectionService } from '../services/hiveInspectionService.js';
import { MajorInspectionService } from '../services/majorInspectionService.js'; // Needed for ownership check
import { hive_inspectionsAttributes } from 'database/models-ts/hive_inspections.js';

//import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';
import { major_inspectionsAttributes } from '../database/models-ts/major_inspections.js';
import { UniqueConstraintError } from 'sequelize';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    console.log('Controller: Creating hive inspection');
    try {
      const { majorInspectionId } = req.params;
      //const userId = req.currentUser!.id; // Authenticated user ID

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }
      console.log('Controller: Major inspection ownership verified:', majorInspection);

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: hive_inspectionsAttributes = { ...req.body, major_inspection_id: majorInspectionId }; // Ensure majorInspectionId from param is used
      console.log('Hive inspection data to be created:', hiveData);

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(hiveData);
      console.log('Controller: New hive inspection created on database:', newHiveInspection);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      if (error instanceof UniqueConstraintError) {
        // <-- Check for the specific error
        // A specific hive should only be inspected once per major inspection event
        const _err = new Error('A hive inspection for this hive already exists in this major inspection.') as CustomError;
        _err.statusCode = httpStatus.CONFLICT; // Return 409 Conflict
        next(_err);
      } else {
        next(error);
      }
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      //const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed

      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.FORBIDDEN;
        throw _err;
      }

      const updateData: hive_inspectionsAttributes = req.body; // Joi validation should ensure valid partial data

      console.log('------------------ Controller: Updating hive inspection with data:', updateData);

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      console.log('------------------ Controller: Updated hive inspection:', updatedHiveInspection);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.currentUser!.id;

      // Access the object directly from res.locals, no new DB query needed
      console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspection);
      const majorInspection = res.locals.majorInspectionOwned as major_inspectionsAttributes;
      if (!majorInspection) {
        const _err = new Error('hicMajor inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\locationController.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/locationService.js'; // Import the service
import { locationsAttributes } from 'database/models-ts/locations.js';
//import { Location as LocationInterface } from '../types/models.js'; // Import the interface
// import { Location as LocationInterface } from '../types/models'; // No longer needed for this specific line
//import { CreateLocationDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export const createLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.currentUser!.id; // Authenticate middleware ensures req.user.id exists
    const locationData: locationsAttributes = req.body;

    const newLocation = await LocationService.createLocation(userId, locationData);

    res.status(201).json({
      success: true,
      message: 'Location created successfully',
      data: newLocation,
    });
  } catch (error) {
    next(error);
  }
};

export const getLocations = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.currentUser!.id;

    const locations = await LocationService.getLocationsByUserId(userId);

    res.status(200).json({
      success: true,
      data: locations,
    });
  } catch (error) {
    next(error);
  }
};

export const getLocationById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.currentUser!.id;
    const { locationId } = req.params;

    const location = await LocationService.getLocationById(locationId, userId);

    if (!location) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: location,
    });
  } catch (error) {
    next(error);
  }
};

export const updateLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.currentUser!.id;
    const { locationId } = req.params;
    const updateData: Partial<locationsAttributes> = req.body;

    const updatedLocation = await LocationService.updateLocation(locationId, userId, updateData);

    if (!updatedLocation) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Location updated successfully',
      data: updatedLocation,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.currentUser!.id;
    const { locationId } = req.params;

    const deleted = await LocationService.deleteLocation(locationId, userId);

    if (!deleted) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Location deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

export const getMapData = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // This endpoint retrieves data for the map view.
    // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
    // If it's only for logged-in users, keep authenticate middleware.
    // For showing "all registered beehive locations within a country" with owner email/username,
    // it might require a join query to get hive counts and owner info across all users.

    // For simplicity, let's just return a placeholder or mock data for now.
    // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
    // to aggregate hive counts per location.
    const mockMapData = [
      {
        id: 'loc1',
        latitude: 46.0569, // Ljubljana, Slovenia
        longitude: 14.5058,
        hiveCount: 12,
        ownerUsername: 'SlovenianBeekeeper',
      },
      {
        id: 'loc2',
        latitude: 46.5547, // Maribor, Slovenia
        longitude: 15.6459,
        hiveCount: 8,
        ownerUsername: 'ApiaryExplorer',
      },
    ];

    res.status(200).json({
      success: true,
      data: mockMapData,
    });
  } catch (error) {
    next(error);
  }
};


// filepath: controllers\majorInspectionContoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/majorInspectionService.js';
import { LocationService } from '../services/locationService.js'; // To check location ownership
// import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
// import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';
import { major_inspectionsAttributes } from 'database/models-ts/major_inspections.js';

// // Middleware to ensure location belongs to the authenticated user
// const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     console.log('Checking location ownership...', req.params, req.body, req.currentUser);
//     const userId = req.currentUser!.id;
//     const { locationId } = req.params;

//     const location = await LocationService.getLocationById(locationId, userId);
//     if (!location) {
//       const error = new Error('Location not found or unauthorized.') as CustomError;
//       error.statusCode = 403; // Forbidden
//       throw error;
//     }
//     next(); // Location is owned by the user, proceed
//   } catch (error) {
//     next(error);
//   }
// };

export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Creating major inspection...ABCD', req.params, req.body);
    const { locationId } = req.params;
    //const inspectionData: Partial<MajorInspectionInterface> = req.body;
    const inspectionData: major_inspectionsAttributes = req.body;

    const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

    res.status(201).json({
      success: true,
      message: 'Major inspection created successfully',
      data: newMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Fetching major inspections...');
    const { locationId } = req.params;

    const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

    res.status(200).json({
      success: true,
      data: majorInspections,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const majorInspection = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: majorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const updateData: major_inspectionsAttributes = req.body;
    console.log('Updating major inspection controller...', majorInspectionId, locationId, updateData);

    const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(locationId, majorInspectionId, updateData);

    if (!updatedMajorInspection) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection updated successfully',
      data: updatedMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    const deleted = await MajorInspectionService.deleteMajorInspection(userId, locationId, majorInspectionId);

    if (!deleted) {
      const error = new Error('cMajor inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

//export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
├── app.ts // Express app setup, middleware, routes
├── server.ts // Entry point, starts the server
├── config/ // Environment variables, database config
│ └── index.ts
├── database/ // ORM setup (Sequelize/TypeORM), models, migrations
│ ├── index.ts
│ ├── models/
│ │ ├── User.ts
│ │ ├── Location.ts
│ │ ├── MajorInspection.ts
│ │ └── HiveInspection.ts
│ └── migrations/
├── middleware/ // Custom middleware (auth, validation, error handling)
│ ├── auth.ts // JWT verification, authorization checks
│ ├── validation.ts // Joi/Zod for input validation
│ └── errorHandler.ts // Centralized error handling
├── controllers/ // Business logic for each resource
│ ├── authController.ts
│ ├── locationController.ts
│ ├── majorInspectionController.ts
│ └── hiveInspectionController.ts
├── routes/ // API routes for each resource
│ ├── authRoutes.ts
│ ├── locationRoutes.ts
│ ├── majorInspectionRoutes.ts
│ └── hiveInspectionRoutes.ts
├── services/ // Database interaction logic (optional, for separation of concerns)
│ ├── locationService.ts
│ └── ...
├── types/ // TypeScript interfaces/types
│ ├── express.d.ts // Extend Request for user property
│ ├── models.ts
│ └── auth.ts
└── utils/ // Utility functions (e.g., password hashing)
└── jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts
import { Sequelize } from 'sequelize-typescript';
import config from '../config/index.js';
//import { associateModels } from './models-obsolete/associations.js'; // obsolete associations
//import { User } from './models-obsolete/User.js'; // To be created
import { users } from './models-ts/users.js'; // To be created
import { locations } from './models-ts/locations.js'; // To be created
import { hive_inspections } from './models-ts/hive_inspections.js';
import { major_inspections } from './models-ts/major_inspections.js';
import { hives } from './models-ts/hives.js'; // To be created
import { associateModels } from './models-ts/associations.js'; // Adjust path if you placed it elsewhere, e.g., './models-obsolete/associations.js'

// import { Location } from './models-obsolete/Location.js'; // To be created
// import { MajorInspection } from './models-obsolete/MajorInspection.js'; // To be created
// import { HiveInspection } from './models-obsolete/HiveInspection.js'; // To be created

console.log('Connecting to PostgreSQL database... ', process.env.DATABASE_URL);

const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;
console.log('Database connection string:', databaseUrl);

// Initialize Sequelize with your database connection string
export const sequelize = new Sequelize(databaseUrl, {
  dialect: 'postgres', // Specify PostgreSQL dialect
  //logging: config.nodeEnv === 'development' ? console.log : false, // Log SQL queries in dev mode
  logging: false,
  dialectOptions: {
    // You might need these options for production deployments like Heroku or Render
    // ssl: {
    //   require: true,
    //   rejectUnauthorized: false, // For self-signed certificates or services like Heroku
    // },
  },
  define: {
    timestamps: false, // Automatically add createdAt and updatedAt fields
    underscored: true, // Use snake_case for column names (e.g., created_at)
  },
  models: [users, locations, hive_inspections, major_inspections, hives], // Register your models
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Set up associations between models
    associateModels();
    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
      console.log('Syncing database models (development mode)...');
      //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
      await sequelize.sync({ alter: false });
      console.log('Database models synchronized.');
    } else {
      // In production, rely on migrations. If you haven't run migrations,
      // you might still want a simple sync without alter.
      // Or remove this line entirely if you strictly use migrations.
      // await sequelize.sync();
      console.log('In production, use database migrations to manage schema changes.');
    }
  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};


// filepath: database\models-ts\associations.ts
import { users } from './users.js';
import { locations } from './locations.js';
import { major_inspections } from './major_inspections.js';
import { hives } from './hives.js';
import { hive_inspections } from './hive_inspections.js';

export function associateModels() {
  // User to Location (one-to-many)
  users.hasMany(locations, {
    foreignKey: 'user_id',
    as: 'locations',
  });
  locations.belongsTo(users, {
    foreignKey: 'user_id',
    as: 'user',
  });

  // Location to MajorInspection (one-to-many)
  locations.hasMany(major_inspections, {
    foreignKey: 'location_id',
    as: 'locations_majorInspections',
  });
  major_inspections.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'majorInspection_location',
  });

  // Location to Hives (one-to-many)
  locations.hasMany(hives, {
    foreignKey: 'location_id',
    as: 'locations_hives',
  });
  hives.belongsTo(locations, {
    foreignKey: 'location_id',
    as: 'hives_location',
  });

  // MajorInspection to HiveInspection (one-to-many)
  major_inspections.hasMany(hive_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'majors_hiveInspections',
  });
  hive_inspections.belongsTo(major_inspections, {
    foreignKey: 'major_inspection_id',
    as: 'hiveInspections_majorInspection',
  });

  // Hive to HiveInspection (one-to-many)
  hives.hasMany(hive_inspections, {
    foreignKey: 'hive_id',
    as: 'hives_hiveInspections',
  });

  hive_inspections.belongsTo(hives, {
    foreignKey: 'hive_id',
    as: 'hiveInspections_hive',
  });
}


// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface hivesAttributes {
  hive_id?: string;
  location_id: string;
  hive_name: string;
  description?: string;
  is_active?: boolean;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hives',
  schema: 'public',
  timestamps: false,
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING(255),
  })
  hive_name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  description?: string;

  @Column({
    allowNull: true,
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('true'),
  })
  is_active?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  //   // --- Associations for Hive Inspections ---
  //   @HasMany(() => hive_inspections, {
  //     foreignKey: 'hive_id', // The foreign key in the 'hive_inspections' table that links back to 'hives'
  //     as: 'hiveInspections', // Alias for when you include hive inspections with a hive
  //   })
  //   hiveInspections?: hive_inspections[]; // Property to hold an array of associated hive inspections
}


// filepath: database\models-ts\hive_inspections – kopija.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface hive_inspectionsAttributes {
    hive_inspection_id?: string;
    major_inspection_id: string;
    hive_id: string;
    inspection_time: string;
    colony_health_status_id: number;
    num_chambers: number;
    brood_frames_count?: number;
    brood_percentage?: string;
    queen_status_id: number;
    approx_honey_weight_kg?: string;
    drone_comb_frames_count?: number;
    drone_comb_percentage?: string;
    sugar_feed_added?: boolean;
    sugar_feed_quantity_kg?: string;
    brood_chambers_count: number;
    supers_count: number;
    queen_excluder_present?: boolean;
    num_varroa_mites_found?: number;
    varroa_treatment_id?: number;
    varroa_treatment_dosage?: string;
    raising_new_queen?: boolean;
    queen_cell_age_days?: number;
    queen_cell_status_id?: number;
    other_notes?: string;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "hive_inspections",
	schema: "public",
	timestamps: false 
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	hive_inspection_id?: string;

    @Column({
    	type: DataType.UUID 
    })
    	major_inspection_id!: string;

    @Column({
    	type: DataType.UUID 
    })
    	hive_id!: string;

    @Column({
    	type: DataType.STRING 
    })
    	inspection_time!: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	colony_health_status_id!: number;

    @Column({
    	type: DataType.INTEGER 
    })
    	num_chambers!: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	brood_frames_count?: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(5,2) 
    })
    	brood_percentage?: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	queen_status_id!: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(8,2) 
    })
    	approx_honey_weight_kg?: string;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	drone_comb_frames_count?: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(5,2) 
    })
    	drone_comb_percentage?: string;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	sugar_feed_added?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(8,2) 
    })
    	sugar_feed_quantity_kg?: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	brood_chambers_count!: number;

    @Column({
    	type: DataType.INTEGER 
    })
    	supers_count!: number;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	queen_excluder_present?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	num_varroa_mites_found?: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	varroa_treatment_id?: number;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(255) 
    })
    	varroa_treatment_dosage?: string;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	raising_new_queen?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	queen_cell_age_days?: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	queen_cell_status_id?: number;

    @Column({
    	allowNull: true,
    	type: DataType.STRING 
    })
    	other_notes?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\hive_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey } from 'sequelize-typescript';

import { hives } from './hives.js'; // Import hives model
import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface hive_inspectionsAttributes {
  hive_inspection_id?: string;
  major_inspection_id: string;
  hive_id: string;
  inspection_time: string;
  colony_health_status_id: number;
  num_chambers: number;
  brood_frames_count?: number;
  brood_percentage?: number; // no longer string
  queen_status_id: number;
  approx_honey_weight_kg?: number;
  drone_comb_frames_count?: number;
  drone_comb_percentage?: number; // no longer string
  sugar_feed_added?: boolean;
  sugar_feed_quantity_kg?: number;
  brood_chambers_count: number;
  supers_count: number;
  queen_excluder_present?: boolean;
  num_varroa_mites_found?: number;
  varroa_treatment_id?: number;
  varroa_treatment_dosage?: string;
  raising_new_queen?: boolean;
  queen_cell_age_days?: number;
  queen_cell_status_id?: number;
  other_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'hive_inspections',
  schema: 'public',
  timestamps: false,
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  hive_inspection_id?: string;

  @ForeignKey(() => major_inspections) // Indicates that major_inspection_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  major_inspection_id!: string;

  @ForeignKey(() => hives) // Indicates that hive_id is a foreign key
  @Column({
    type: DataType.UUID,
  })
  hive_id!: string;

  //   @BelongsTo(() => hives, {
  //     foreignKey: 'hive_id',
  //     as: 'hive', // Alias for when you include the hive with a hive inspection
  //   })
  //   hive?: hives; // Property to hold the associated hive

  @Column({
    type: DataType.STRING,
  })
  inspection_time!: string;

  @Column({
    type: DataType.INTEGER,
  })
  colony_health_status_id!: number;

  @Column({
    type: DataType.INTEGER,
  })
  num_chambers!: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  brood_percentage?: number;

  @Column({
    type: DataType.INTEGER,
  })
  queen_status_id!: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  approx_honey_weight_kg?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  drone_comb_frames_count?: number;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(3, 0),
  })
  drone_comb_percentage?: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  sugar_feed_added?: boolean;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(8, 2),
  })
  sugar_feed_quantity_kg?: number;

  @Column({
    type: DataType.INTEGER,
  })
  brood_chambers_count!: number;

  @Column({
    type: DataType.INTEGER,
  })
  supers_count!: number;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  queen_excluder_present?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  num_varroa_mites_found?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  varroa_treatment_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  varroa_treatment_dosage?: string;

  @Column({
    type: DataType.BOOLEAN,
    defaultValue: Sequelize.literal('false'),
  })
  raising_new_queen?: boolean;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_age_days?: number;

  @Column({
    allowNull: true,
    type: DataType.INTEGER,
  })
  queen_cell_status_id?: number;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  other_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // @BelongsTo(() => major_inspections, {
  //   foreignKey: 'major_inspection_id',
  //   as: 'majorInspection', // This alias is consistent with what you used in HiveInspectionService
  // })
  // majorInspection?: major_inspections; // Property to hold the associated major inspection
}


// filepath: database\models-ts\index.ts
export * from "./hives.js";
export * from "./users.js";
export * from "./locations.js";
export * from "./major_inspections.js";
export * from "./hive_inspections.js";
export * from "./colony_health_statuses.js";
export * from "./queen_statuses.js";
export * from "./varroa_treatments.js";
export * from "./queen_cell_statuses.js";

// filepath: database\models-ts\locations.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';
import { users } from './users.js';
// import { hives } from './hives.js'; // Import hives model
// import { major_inspections } from './major_inspections.js'; // Import major_inspections model

export interface locationsAttributes {
  location_id?: string;
  user_id: string;
  name: string;
  address?: string;
  latitude?: string;
  longitude?: string;
  country?: string;
  notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'locations',
  schema: 'public',
  timestamps: false,
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  location_id?: string;

  @ForeignKey(() => users)
  @Column({
    type: DataType.UUID,
  })
  user_id!: string;

  @Column({
    type: DataType.STRING(255),
  })
  name!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(500),
  })
  address?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  latitude?: string;

  @Column({
    allowNull: true,
    type: DataType.DECIMAL(9, 6),
  })
  longitude?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(100),
  })
  country?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  // Association with users model
  //   @BelongsTo(() => users)
  //   user?: users; // This property would hold the associated user object

  // --- Associations for Hives ---
  //   @HasMany(() => hives, {
  //     foreignKey: 'location_id', // The foreign key in the 'hives' table that links back to 'locations'
  //     as: 'hives', // Alias for when you include hives with a location
  //   })
  //   hives?: hives[]; // Property to hold an array of associated hives

  // --- Associations for Major Inspections ---
  //   @HasMany(() => major_inspections, {
  //     foreignKey: 'location_id', // The foreign key in the 'major_inspections' table that links back to 'locations'
  //     as: 'majorInspections', // Alias for when you include major inspections with a location
  //   })
  //   majorInspections?: major_inspections[]; // Property to hold an array of associated major inspections
}


// filepath: database\models-ts\major_inspections.ts
import { Model, Table, Column, DataType, Index, Sequelize, ForeignKey, BelongsTo, HasMany } from 'sequelize-typescript';

import { locations } from './locations.js'; // Import locations model
import { hive_inspections } from './hive_inspections.js'; // Import hive_inspections model

export interface major_inspectionsAttributes {
  major_inspection_id?: string;
  location_id: string;
  inspection_date: string;
  general_notes?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'major_inspections',
  schema: 'public',
  timestamps: false,
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  major_inspection_id?: string;

  @ForeignKey(() => locations) // Indicates that location_id is a foreign key referencing the locations model
  @Column({
    type: DataType.UUID,
  })
  location_id!: string;

  // @BelongsTo(() => locations) // This establishes the BelongsTo relationship with locations
  // location?: locations; // Property to hold the associated location

  @Column({
    type: DataType.STRING,
  })
  inspection_date!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING,
  })
  general_notes?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
  // --- Associations for Hive Inspections ---
  @HasMany(() => hive_inspections, {
    foreignKey: 'major_inspection_id', // The foreign key in the 'hive_inspections' table that links back to 'major_inspections'
    as: 'hiveInspections', // Alias for when you include hive inspections with a major inspection
  })
  hiveInspections?: hive_inspections;
  */
}


// filepath: database\models-ts\queen_cell_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\users.ts
import { Model, Table, Column, DataType, Index, Sequelize, HasMany } from 'sequelize-typescript';
import { locations } from './locations.js';

export interface usersAttributes {
  user_id?: string;
  username: string;
  password_hash?: string;
  email: string;
  google_id?: string;
  linkedin_id?: string;
  created_at?: Date;
  updated_at?: Date;
}

@Table({
  tableName: 'users',
  schema: 'public',
  timestamps: false,
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {
  @Column({
    primaryKey: true,
    type: DataType.UUID,
    defaultValue: Sequelize.literal('gen_random_uuid()'),
  })
  user_id?: string;

  @Column({
    type: DataType.STRING(255),
  })
  username!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  password_hash?: string;

  @Column({
    type: DataType.STRING(255),
  })
  email!: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  google_id?: string;

  @Column({
    allowNull: true,
    type: DataType.STRING(255),
  })
  linkedin_id?: string;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  created_at?: Date;

  @Column({
    allowNull: true,
    type: DataType.DATE,
    defaultValue: Sequelize.literal('CURRENT_TIMESTAMP'),
  })
  updated_at?: Date;

  /*
	// Association with locations model
	@HasMany(() => locations, { foreignKey: 'user_id' })
    locations?: locations[]; // This property would hold an array of associated locations
	*/
}


// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: database\myhives_db_script.sql
-- Enable the pgcrypto extension for gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Table for Users
-- Stores user authentication details, supporting traditional, Google, and LinkedIn logins.
CREATE TABLE users (
    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- Storing hashed password for traditional login
    email VARCHAR(255) UNIQUE NOT NULL,
    google_id VARCHAR(255) UNIQUE, -- Google OAuth ID
    linkedin_id VARCHAR(255) UNIQUE, -- LinkedIn OAuth ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index on commonly searched authentication fields
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_google_id ON users(google_id);
CREATE INDEX idx_users_linkedin_id ON users(linkedin_id);


-- Table for Beehive Locations/Stands
-- Stores information about where beekeepers manage their hives.
CREATE TABLE locations (
    location_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE, -- Link to the owner
    name VARCHAR(255) NOT NULL, -- Name of the location (e.g., "Backyard Apiary", "Field A")
    address VARCHAR(500), -- Optional: physical address
    latitude NUMERIC(9,6), -- Latitude for map display
    longitude NUMERIC(9,6), -- Longitude for map display
    country VARCHAR(100), -- Country for potential regional filtering/map views
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_LocationName_User UNIQUE (user_id, name) -- Location names must be unique per user
);

-- Indexes for location data
CREATE INDEX idx_locations_user_id ON locations(user_id);
CREATE INDEX idx_locations_lat_lon ON locations(latitude, longitude);


-- Table for Individual Beehives
-- Represents a specific beehive within a location, allowing tracking of its history.
CREATE TABLE hives (
    hive_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE, -- Link to its physical location
    hive_name VARCHAR(255) NOT NULL, -- Unique name/identifier for the hive within its location (e.g., "Hive 1", "Blue Box")
    description TEXT, -- General description of the hive
    is_active BOOLEAN DEFAULT TRUE, -- Flag if the hive is currently active at this location
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_HiveName_Location UNIQUE (location_id, hive_name) -- Hive names must be unique within a location
);

-- Index for hive data
CREATE INDEX idx_hives_location_id ON hives(location_id);


-- Lookup Table: Colony Health Statuses
-- Predefined options for colony health (e.g., thriving, weak, failing)
CREATE TABLE colony_health_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO colony_health_statuses (status_name) VALUES
('Thriving'),
('Weak'),
('Failing'),
('Unknown');


-- Lookup Table: Queen Statuses
-- Predefined options for queen status (e.g., seen, not seen, laying well)
CREATE TABLE queen_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_statuses (status_name) VALUES
('Seen'),
('Not Seen'),
('Laying Well'),
('Queen Cells Present'),
('Superseded'),
('Absent'),
('Virgin'),
('Unknown');


-- Lookup Table: Varroa Treatments
-- Predefined options for varroa treatments (e.g., Formic acid, Oxalic acid, None)
CREATE TABLE varroa_treatments (
    treatment_id SERIAL PRIMARY KEY,
    treatment_name VARCHAR(100) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO varroa_treatments (treatment_name) VALUES
('Formic Acid'),
('Oxalic Acid'),
('Apivar'),
('Api Life Var'),
('Mite Away Quick Strips'),
('None'),
('Other');


-- Lookup Table: Queen Cell Statuses
-- Predefined options for queen cell status (e.g., open, closed)
CREATE TABLE queen_cell_statuses (
    status_id SERIAL PRIMARY KEY,
    status_name VARCHAR(50) UNIQUE NOT NULL
);

-- Populate lookup table
INSERT INTO queen_cell_statuses (status_name) VALUES
('Open'),
('Closed'),
('Hatched'),
('Destroyed'),
('Emerging'),
('Unknown');


-- Table for Major Inspections
-- Represents a single visit to a location where one or more hives were inspected.
CREATE TABLE major_inspections (
    major_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    location_id UUID NOT NULL REFERENCES locations(location_id) ON DELETE CASCADE,
    inspection_date DATE NOT NULL,
    general_notes TEXT, -- General notes for the entire location visit
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT UQ_MajorInspection_LocationDate UNIQUE (location_id, inspection_date)
);

-- Index for major inspections
CREATE INDEX idx_major_inspections_location_date ON major_inspections(location_id, inspection_date);


-- Table for Individual Hive Inspections
-- Detailed records for each specific hive inspection within a major inspection.
CREATE TABLE hive_inspections (
    hive_inspection_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    major_inspection_id UUID NOT NULL REFERENCES major_inspections(major_inspection_id) ON DELETE CASCADE,
    hive_id UUID NOT NULL REFERENCES hives(hive_id) ON DELETE CASCADE,
    inspection_time TIME WITHOUT TIME ZONE NOT NULL, -- Hour of inspection specific to this hive
    
    -- Colony Health
    colony_health_status_id INTEGER NOT NULL REFERENCES colony_health_statuses(status_id),
    num_chambers INTEGER NOT NULL, -- Number of hive boxes/chambers
    
    -- Brood details (allowing for either count or percentage, or both)
    brood_frames_count INTEGER, -- Number of frames with brood
    brood_percentage NUMERIC(5,2), -- Percentage of brood (e.g., 75.00 for 75%)
    
    -- Queen Status
    queen_status_id INTEGER NOT NULL REFERENCES queen_statuses(status_id),
    
    -- Honey and Drone Comb
    approx_honey_weight_kg NUMERIC(8,2), -- Approximate amount of honey in kg
    drone_comb_frames_count INTEGER, -- Number of frames with drone comb
    drone_comb_percentage NUMERIC(5,2), -- Percentage of drone comb
    
    -- Feeding and Configuration
    sugar_feed_added BOOLEAN NOT NULL DEFAULT FALSE,
    sugar_feed_quantity_kg NUMERIC(8,2), -- Quantity of sugar feed added in kg
    brood_chambers_count INTEGER NOT NULL,
    supers_count INTEGER NOT NULL,
    queen_excluder_present BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Varroa Mites
    num_varroa_mites_found INTEGER,
    varroa_treatment_id INTEGER REFERENCES varroa_treatments(treatment_id),
    varroa_treatment_dosage VARCHAR(255), -- Dosage/amount (e.g., "5ml", "2 strips")
    
    -- Queen Rearing
    raising_new_queen BOOLEAN NOT NULL DEFAULT FALSE,
    queen_cell_age_days INTEGER, -- Age in days, if known
    queen_cell_status_id INTEGER REFERENCES queen_cell_statuses(status_id),
    
    other_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    -- A specific hive should only be inspected once per major inspection event
    CONSTRAINT UQ_HiveInspection_MajorHive UNIQUE (major_inspection_id, hive_id)
);

-- Indexes for hive inspections
CREATE INDEX idx_hive_inspections_major_id ON hive_inspections(major_inspection_id);
CREATE INDEX idx_hive_inspections_hive_id ON hive_inspections(hive_id);


-- Function to update the `updated_at` column automatically
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers to automatically update `updated_at` on row modification
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_locations_updated_at
BEFORE UPDATE ON locations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hives_updated_at
BEFORE UPDATE ON hives
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_major_inspections_updated_at
BEFORE UPDATE ON major_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_hive_inspections_updated_at
BEFORE UPDATE ON hive_inspections
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    console.log('Authentication middleware called');
    const authHeader = req.headers.authorization;
    console.log('Token received:', req.headers.authorization);

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);
    console.log('Decoded token:', decoded);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.currentUser = { id: decoded.userId }; // Ensure 'user_id' is set for compatibility};

    next();
  } catch (error: any) {
    console.error('Authentication error:', error);
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    console.error(`Error status code: ${err.statusCode}, message: ${err.message}`);
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };


// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  console.error('Error Handler  occurred:', {
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
  });
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;


// filepath: middleware\ownership.ts
import { Request, Response, NextFunction } from 'express';
import { LocationService } from '../services/locationService.js'; // To check location ownership
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/majorInspectionService.js';

// Middleware to ensure location belongs to the authenticated user
const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
  //console.log('Checking location ownership...', req.params, req.body, req.currentUser);
  try {
    const userId = req.currentUser!.id;
    const { locationId } = req.params;

    const location = await LocationService.getLocationById(locationId, userId);
    if (!location) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 403; // Forbidden
      throw error;
    }
    next(); // Location is owned by the user, proceed
  } catch (error) {
    next(error);
  }
};

// Middleware to check if the :majorInspectionId in the URL param belongs to the authenticated user
// This assumes MajorInspectionService has a method to verify ownership without requiring locationId in URL
const checkMajorInspectionOwnershipForHive = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Checking major inspection ownership for hive inspections...', req.params, req.body, req.currentUser);
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.currentUser!.id;

    // IMPORTANT: You need to implement this method in your MajorInspectionService.
    // It should fetch the major inspection and ensure its associated location's userId matches the current user.
    //const majorInspectionOwned = await MajorInspectionService.getMajorInspectionByIdAndVerifyUser(
    // console.log(
    //   '\t\t @Ownership/checkMajorInspectionOwnershipForHive Checking major inspection ownership for hive inspections...',
    //   '\nmajorInspectionId:',
    //   majorInspectionId,
    //   '\nlocationId:',
    //   locationId,
    //   '\nuserId:',
    //   userId
    // );

    const majorInspectionOwned = await MajorInspectionService.getMajorInspectionById(userId, majorInspectionId, locationId);

    if (!majorInspectionOwned) {
      const error: CustomError = new Error('oMajor Inspection not found or not owned by user') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    // Store the fetched object on res.locals for subsequent handlers
    res.locals.majorInspectionOwned = majorInspectionOwned;
    //console.log('%%% Major Inspection ownership verified for hive:', res.locals.majorInspectionOwned);

    next();
  } catch (error) {
    console.error('%%% Error checking major inspection ownership for hive:', error);
    next(error);
  }
};

export { checkLocationOwnership, checkMajorInspectionOwnershipForHive };


// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { CustomError } from './errorHandler.js';
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  // console.log('Validation middleware initialized with schemas:', schemas);
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(error.details.map((d) => d.message).join(', ')) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router } from 'express';

import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { RegisterUserDto, LoginUserDto } from '../types/dtos.js'; // Assuming these DTOs exist
//import { CustomError } from '../middleware/errorHandler.js'; // Use CustomError
import { login, register, getMe, logout } from '../controllers/authController.js'; // Import your auth controller

import { isAuthenticated } from '../middleware/auth.js';
//import { getMajorInspectionById } from 'controllers/majorInspectionContoller.js';

const authRouter = Router();

const registerSchema = Joi.object<RegisterUserDto>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required',
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required',
  }),
});

const loginSchema = Joi.object<LoginUserDto>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required',
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required',
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',

  validate({ body: registerSchema }), // Apply Joi validation middleware
  register // Call the controller function here
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // Apply Joi validation middleware
  login // Call the controller function here
);

authRouter.get('/me', isAuthenticated, getMe);

authRouter.post(
  '/logout',
  isAuthenticated, // Optional: You might want to ensure only authenticated users can "logout"
  // Or, if you simply want to provide a path to clear client-side token, it can be without auth.
  logout
);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;


// filepath: routes\hiveInspectionRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hiveInspectionService.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { checkMajorInspectionOwnershipForHive as checkMajorInspectionOwnership } from '../middleware/ownership.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
//import { ColonyHealthStatus, QueenStatus, TreatmentApplied, QueenCellStatus } from '../types/models.js';
import { HiveInspectionController } from '../controllers/hiveInspectionController.js';

const hiveInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for HiveInspection ---
// const beehiveConfigurationSchema = Joi.object({
//   type: Joi.string().required(),
//   numberOfFrames: Joi.number().integer().min(1).required(),
//   materials: Joi.array().items(Joi.string()).optional(),
//   isInsulated: Joi.boolean().optional(),
// });

const createHiveInspectionSchema = Joi.object({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  // Use the exact snake_case names from your model
  hive_id: Joi.string().uuid().required(),
  inspection_time: Joi.string()
    .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/)
    .required(),
  colony_health_status_id: Joi.number().integer().required(),
  num_chambers: Joi.number().integer().min(1).required(),
  brood_chambers_count: Joi.number().integer().min(1).required(),
  supers_count: Joi.number().integer().min(0).required(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().required(),
  approx_honey_weight_kg: Joi.number().integer().min(0).max(50).optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().min(0).max(10).optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().optional().allow(null),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<hive_inspectionsAttributes>({
  hive_id: Joi.string().trim().optional(),
  inspection_time: Joi.string()
    .pattern(/^([01]\d|2[0-3]):([0-5]\d)$/)
    .optional()
    .messages({
      'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)',
    }),
  colony_health_status_id: Joi.number().integer().optional(),
  num_chambers: Joi.number().integer().min(1).optional(),
  brood_chambers_count: Joi.number().integer().min(1).optional(),
  supers_count: Joi.number().integer().min(0).optional(),
  brood_frames_count: Joi.number().integer().min(0).optional().allow(null),
  brood_percentage: Joi.number().integer().min(0).max(100).optional().allow(null),
  queen_status_id: Joi.number().integer().optional(),
  approx_honey_weight_kg: Joi.number().integer().optional().allow(null),
  drone_comb_frames_count: Joi.number().integer().min(0).max(10).optional().allow(null),
  drone_comb_percentage: Joi.number().min(0).max(100).optional().allow(null),
  sugar_feed_added: Joi.boolean().optional().allow(null),
  sugar_feed_quantity_kg: Joi.number().integer().optional().allow(null),
  queen_excluder_present: Joi.boolean().optional().allow(null),
  num_varroa_mites_found: Joi.number().integer().min(0).optional().allow(null),
  varroa_treatment_id: Joi.number().integer().optional().allow(null),
  varroa_treatment_dosage: Joi.string().allow(null, '').optional(),
  raising_new_queen: Joi.boolean().optional().allow(null),
  queen_cell_age_days: Joi.number().integer().min(0).optional().allow(null),
  queen_cell_status_id: Joi.number().integer().optional().allow(null),
  other_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const specificHiveInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hiveInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const rootHiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  // Add the locationId to the schema to allow it
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
    body: createHiveInspectionSchema,
  }),
  // (req, res, next) => {
  //   console.log('Validation successful');
  //   next();
  // },
  checkMajorInspectionOwnership, // Verify parent MajorInspection ownership
  HiveInspectionController.createHiveInspection
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/',
  isAuthenticated,
  validate({
    params: rootHiveInspectionParamsSchema,
  }),

  checkMajorInspectionOwnership,
  (req, res, next) => {
    console.log('****** GET /  ownership verified *****');
    next();
  },
  HiveInspectionController.getHiveInspectionsByMajorInspectionId
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** GET /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.getHiveInspectionById
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** PUT /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({
    params: specificHiveInspectionParamsSchema,
    body: updateHiveInspectionSchema,
  }),
  checkMajorInspectionOwnership,
  HiveInspectionController.updateHiveInspection
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/:hiveInspectionId',
  // (req, res, next) => {
  //   console.log('****** DELETE /:hiveInspectionId  *****');
  //   next();
  // },
  isAuthenticated,
  validate({ params: specificHiveInspectionParamsSchema }),
  checkMajorInspectionOwnership,
  HiveInspectionController.deleteHiveInspection
);

export default hiveInspectionRouter;


// filepath: routes\hiveRoutes.ts
/* define endpoints, joi schemas, and controllers for hive inspections */
import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';

import hiveControler from '../controllers/hiveController.js';
import { hivesAttributes } from '../database/models-ts/hives.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { CustomError } from '../middleware/errorHandler.js';

const hiveRouter = Router({ mergeParams: true });

const createHivesBodySchema = Joi.object<hivesAttributes>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .required(),
  hive_name: Joi.string().min(2).max(50).required(),
  description: Joi.string().min(2).max(200).required(),
  is_active: Joi.boolean().required(),
});

const updateHivesBodySchema = Joi.object<hivesAttributes>({
  // locationId: Joi.string()
  //   .guid({ version: ['uuidv4'] })
  //   .optional(),
  hive_name: Joi.string().min(2).max(50).optional(),
  description: Joi.string().min(2).max(200).optional(),
  is_active: Joi.boolean().optional(),
});

const createHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const updateHiveParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  hive_id: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

//GET /api/v1/locations/:locationId/hives - Get all hives for a specific location.
hiveRouter.get(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching hives...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveControler.getAllHives
);
//POST /api/v1/locations/:locationId/hives - Create a new hive within a specific location.
hiveRouter.post('/', isAuthenticated, validate({ params: createHiveParamSchema, body: createHivesBodySchema }), hiveControler.createHive);

//GET /api/v1/locations/:locationId/hives/:hiveId - Get a specific hive.
hiveRouter.get(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Fetching specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveControler.getHiveById
);

//PUT /api/v1/locations/:locationId/hives/:hiveId - Update a specific hive.
hiveRouter.put(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Updating specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema, body: updateHivesBodySchema }),
  hiveControler.updateHive
);

//DELETE /api/v1/locations/:locationId/hives/:hiveId - Delete a specific hive.
hiveRouter.delete(
  '/:hive_id',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting specific hive ...', req.params);
    next();
  },
  validate({ params: updateHiveParamSchema }),
  hiveControler.deleteHive
);
hiveRouter.delete(
  '/',
  isAuthenticated,
  (req, res, next) => {
    console.log('Router : Deleting all hives ...', req.params);
    next();
  },
  validate({ params: createHiveParamSchema }),
  hiveControler.deleteAllHives
);

export default hiveRouter;


// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { createLocation, getLocations, getLocationById, updateLocation, deleteLocation, getMapData } from '../controllers/locationController.js'; // <-- Import the controller functions

import { locationsAttributes } from '../database/models-ts/locations.js';

import majorInspectionRouter from './majorInspectionRoutes.js';
import hiveRouter from './hiveRoutes.js';

const locationRouter = Router();

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<locationsAttributes>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  notes: Joi.string().trim().max(500).allow(null, ''),
  country: Joi.string().trim().max(100).allow(null, ''),
});

const updateLocationSchema = Joi.object<locationsAttributes>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  notes: Joi.string().trim().max(500).allow(null, '').optional(),
  country: Joi.string().trim().max(100).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(), // Validate as UUID
});

// Mount nested major inspection routes
locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);
locationRouter.use('/:locationId/hives', hiveRouter);

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  createLocation
);

// GET /api/locations/map - Get map data
locationRouter.get('/map', isAuthenticated, getMapData);

// GET /api/locations - Get all locations for the authenticated user
locationRouter.get(
  '/',
  isAuthenticated,
  getLocations // <-- Correctly use the controller function
);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  getLocationById
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  updateLocation
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  deleteLocation
);

// // Mount nested major inspection routes
// locationRouter.use('/:locationId/major-inspections', majorInspectionRouter);

export default locationRouter;


// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { NextFunction, Response, Request, Router } from 'express';
import Joi from 'joi';

import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';

import { createMajorInspection, getMajorInspections, getMajorInspectionById, updateMajorInspection, deleteMajorInspection } from '../controllers/majorInspectionContoller.js';
import { checkLocationOwnership } from '../middleware/ownership.js';
import { major_inspectionsAttributes } from '../database/models-ts/major_inspections.js';
import hiveInspectionRouter from './hiveInspectionRoutes.js';

const majorInspectionRouter = Router({ mergeParams: true });

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspection_date: Joi.date().iso().required(),
  general_notes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<major_inspectionsAttributes>({
  inspection_date: Joi.date().iso().optional(),
  general_notes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

const loggging = async (req: Request, res: Response, next: NextFunction) => {
  // console.log('Logging major inspections requests ...', req.params, req.body);
  next();
};

majorInspectionRouter.use(loggging);

// Mount nested major inspection routes
// majorInspectionRouter.use('/:majorInspectionId/hive-inspections', (req, res, next) => {
//   next();
// });
majorInspectionRouter.use('/:majorInspectionId/hive-inspections', hiveInspectionRouter);

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/',
  isAuthenticated,
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  checkLocationOwnership, // Ensure the location belongs to the user //createMajorInspection
  createMajorInspection
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get('/', isAuthenticated, checkLocationOwnership, getMajorInspections);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get('/:majorInspectionId', isAuthenticated, validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, getMajorInspectionById);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/:majorInspectionId',
  isAuthenticated,
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  checkLocationOwnership,
  updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete('/:majorInspectionId', isAuthenticated, validate({ params: majorInspectionParamsSchema }), checkLocationOwnership, deleteMajorInspection);

export default majorInspectionRouter;


// filepath: routes\manual-tests\hiveInspections\hiveInspections.http
###
# Hive Inspections API Tests
#
# This file assumes you have already run the `major-inspections.http` tests and have a valid token, hive ID, and major inspection ID.
# The Hive API tests might be useful for getting the hive_id.
#
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@baseUrl = http://localhost:3000/api/v1/locations/{{locationId}}
# @token = <paste_your_token_here>
# @majorInspectionId = <paste_your_major_inspection_id_here>
# @hiveId = <paste_your_hive_id_here> 
# @token =
@majorInspectionId = 3dd79818-4e59-49d7-bb82-a65b0145d87c

@hiveId = ec5ffc71-b700-4837-acdf-4dfa5b1b73e3



### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### get token
@token = {{authenticate.response.body.token}}

###
# Create a new hive inspection for a major inspection.
# @name createHiveInspection
POST {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_id": "bfdd1ef0-0cc1-4886-9ba9-572e60a70ef0",
  "inspection_time": "14:41",
  "colony_health_status_id": 1,
  "num_chambers": 3,
  "brood_chambers_count": 2,
  "supers_count": 1,
  "brood_frames_count": 15,
  "brood_percentage": 79,
  "queen_status_id": 2,
  "approx_honey_weight_kg": 10,
  "drone_comb_frames_count": 2,
  "drone_comb_percentage": 5.0,
  "sugar_feed_added": false,
  "sugar_feed_quantity_kg": null,
  "queen_excluder_present": true,
  "num_varroa_mites_found": 5,
  "varroa_treatment_id": 1,
  "varroa_treatment_dosage": "100ml",
  "raising_new_queen": false,
  "queen_cell_age_days": null,
  "queen_cell_status_id": null,
  "other_notes": "The colony seems strong and healthy. Found a few varroa mites, will continue to monitor."
}

###
# Get all hive inspections for a major inspection.
# @name getHiveInspections
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections
Authorization: Bearer {{token}}

###
# Get a specific hive inspection.
#
# To run this, first run the `createHiveInspection` request and copy the `hive_inspection_id`.
# @hiveInspectionId = <paste_hive_inspection_id_here>
@hiveInspectionId = {{createHiveInspection.response.body.hive_inspection_id}}
GET {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId`.
PUT {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "brood_percentage": 33,
  "approx_honey_weight_kg": 25,
  "num_chambers": 8,
  "drone_comb_frames_count": 3,  
  "colony_health_status_id": 3,
  "other_notes": "Updated notes: The colony is doing well, but I noticed a few varroa mites."
}

###
# Delete a specific hive inspection.
#
# To run this, you must have a valid `hiveInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/major-inspections/{{majorInspectionId}}/hive-inspections/{{hiveInspectionId}}
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\hives\hives.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8
@hiveId = 01127c49-7230-4405-9ef3-bba06e71a968

// --- Helper Request: Create a Hive (if you need one) ---
// @name createHive
POST {{baseUrl}}/locations/{{locationId}}/hives
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My SIXTH Hive",
  "description": "Newly established hive with a strong queen.",
  "is_active": true
}

###

// --- 1. GET all Hives for a Location ---
// @name getAllHives
GET {{baseUrl}}/locations/{{locationId}}/hives
Authorization: Bearer {{token}}

###

// --- 2. GET a single Hive by ID ---
// @name getHiveById
GET {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

###

// --- 3. Update an existing Hive ---
// @name updateHive
PUT {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "hive_name": "My Updated Hive Name",
  "description": "Updated notes after a routine check."
}

###

// --- 4. DELETE a Hive ---
// @name deleteHive
DELETE {{baseUrl}}/locations/{{locationId}}/hives/{{hiveId}}
Authorization: Bearer {{token}}

// filepath: routes\manual-tests\locations\locations.http
@baseUrl = http://localhost:3000/api/v1

// Replace these with your actual values
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI


### Login with Valid Credentials
# @name authenticate
# This request authenticates a user and retrieves a JWT token.
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

###
# @name createLocation
# Creates a new location.
@token2 = {{authenticate.response.body.token}}
POST {{baseUrl}}/locations
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Apiary 1",
  "address": "123 Main St, Anytown",
  "latitude": 46.0569,
  "longitude": 14.5058,
  "notes": "Main apiary location.",
  "country": "Slovenia"
}

###
# Get all locations for the authenticated user.
# @name getLocations
GET {{baseUrl}}/locations
Authorization: Bearer {{authenticate.response.body.token}}

###
# Get map data for all beehive locations.
# @name getMapData
GET {{baseUrl}}/locations/map
Authorization: Bearer {{token2}}

###
# Get a specific location by ID.
#
# To run this, first run the `createLocation` request and copy the `location_id` from the response.
# @locationId = <paste_location_id_here>
@locationId = {{createLocation.response.body.data.location_id}}
# Use the commented line below if you prefer to set the ID manually
# @locationId =
GET {{baseUrl}}/locations/{{locationId}}
Authorization: Bearer {{token}}

###
# Update a specific location by ID.
#
# To run this, you must first have a valid `locationId` from the `createLocation` request.
PUT {{baseUrl}}/locations/{{locationId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "name": "Main Apiary - Updated",
  "notes": "Updated notes for the main apiary."
}

###
# Delete a specific location by ID.
#
# To run this, you must have a valid `locationId` that has not already been deleted.
#DELETE {{baseUrl}}/locations/{{locationId}}
DELETE {{baseUrl}}/locations/2af520b3-c43a-47a8-9372-f1a3e819513b
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\majorInspections\majorInspections.http
###
# Major Inspections API Tests
#
# This file assumes you have already run the `locations.http` tests and have a valid token and location ID.
#
@baseUrl = http://localhost:3000/api/v1
@token = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMTJmNGQwNy0xMWM2LTRhY2QtYTI3OS0zMDc4ZDE5ZDlmYTYiLCJpYXQiOjE3NTcyNzYzNzcsImV4cCI6MTc1Nzk2NzU3N30.YRIF5gNsfsR8E9FYCa0OrpRypbp13PxX5avt_lu5cgI
# @locationId = <paste_your_location_id_here>

@locationId = a7bf2913-9609-400c-a8c9-10d9c8c302a8

###
# Create a new major inspection for a specific location.
# @name createMajorInspection
POST {{baseUrl}}/locations/{{locationId}}/major-inspections
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "inspection_date": "2024-09-08T10:00:00.000Z",
  "general_notes": "This is temporary test foobar record."
}

###
# Get all major inspections for a specific location.
# @name getMajorInspections
GET {{baseUrl}}/locations/{{locationId}}/major-inspections
Authorization: Bearer {{token}}

###
# Get a specific major inspection by ID.
#
# To run this, first run the `createMajorInspection` request and copy the `major_inspection_id`.
# @majorInspectionId = <paste_major_inspection_id_here>
@majorInspectionId = {{createMajorInspection.response.body.data.major_inspection_id}}
GET {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Authorization: Bearer {{token}}

###
# Update a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId`.
PUT {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
Content-Type: application/json
Authorization: Bearer {{token}}

{
  "general_notes": "Updated notes: Queen seems healthy."
}

###
# Delete a specific major inspection.
#
# To run this, you must have a valid `majorInspectionId` that has not already been deleted.
DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/{{majorInspectionId}}
#DELETE {{baseUrl}}/locations/{{locationId}}/major-inspections/dee8f057-9efb-463b-93da-76ccfad03a54
Authorization: Bearer {{token}}


// filepath: routes\manual-tests\users\user_requests.http
### Register a New User
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "testuser",
  "email": "test@example.com",
  "password": "password123"
}

### Register a User with Existing Email (Expected: 409 Conflict)
POST http://localhost:3000/api/v1/auth/register
Content-Type: application/json

{
  "username": "anotheruser",
  "email": "test2@example.com",
  "password": "anotherpassword"
}

### Login with Valid Credentials
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez5@gmail.com",    
    "password" : "Cada_73NUN5"
}

### Login with Invalid Password (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "wrongpassword"
}

### Login with Non-Existent Email (Expected: 401 Unauthorized)
POST http://localhost:3000/api/v1/auth/login
Content-Type: application/json

{
    "email" : "joseperez55@gmail.com",
    "password" : "Cada_73NUN5"
}

### Get Current User (without token - Expected: 401 Unauthorized)
GET http://localhost:3000/api/v1/auth/me
Accept: application/json

### Get Current User (with valid token)
# Replace {{authToken}} with the token received from a successful login request
GET http://localhost:3000/api/v1/auth/me
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY

### Logout User
# This request is mainly for demonstration/logging purposes on the server.
# The real logout happens on the client by deleting the token.
POST http://localhost:3000/api/v1/auth/logout
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIwOTk5NjA5OC02MjE2LTRmYWYtODJjOS04MWFjMjE5MjlhMjEiLCJpYXQiOjE3NTI4NjUzOTQsImV4cCI6MTc1Mjg2NTUxNH0._q91sc2cqtMDBMu4qRmjnUpbrR05Lc1fuEcxWC4j3OY


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later

const startServer = async () => {
  try {
    // 1. Connect to the database
    console.log('Attempting to connect to the database...');
    await connectDB();
    console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`⚡️[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\n🙈-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('❌ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log('startServer();');
startServer();


// filepath: services\hiveInspectionService.ts
// src/services/hiveInspectionService.ts

import { hive_inspections } from '../database/models-ts/hive_inspections.js';
//import { major_inspections } from 'database/models-ts/major_inspections.js';
import { hive_inspectionsAttributes } from '../database/models-ts/hive_inspections.js'; // Importing the type for hive inspection attributes
//import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
//import { HiveInspectionCreationAttributes } from '../database/models-obsolete/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(hiveInspectionData: hive_inspectionsAttributes): Promise<hive_inspectionsAttributes> {
    const newHiveInspection = await hive_inspections.create({ ...hiveInspectionData });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(majorInspectionId: string): Promise<hive_inspectionsAttributes[]> {
    const hiveInspections = await hive_inspections.findAll({ where: { major_inspection_id: majorInspectionId }, order: [['created_at', 'ASC']] });
    return hiveInspections.map((hi) => hi.toJSON());
  }

  public static async getHiveInspectionById(id: string, majorInspectionId: string): Promise<hive_inspectionsAttributes | null> {
    const hiveInspection = await hive_inspections.findOne({ where: { hive_inspection_id: id, major_inspection_id: majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(id: string, majorInspectionId: string, updateData: Partial<hive_inspectionsAttributes>): Promise<hive_inspectionsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await hive_inspections.update(updateData, {
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(id: string, majorInspectionId: string): Promise<boolean> {
    const deletedRows = await hive_inspections.destroy({
      where: { hive_inspection_id: id, major_inspection_id: majorInspectionId },
    });
    return deletedRows > 0;
  }

  /**
   * Retrieves hive inspections for a specific hive, ensuring both the hive itself
   * and its associated major inspection belong to the given location.
   * This enforces a strong authorization chain and filters results precisely.
   *
   * @param locationId The ID of the location to filter by.
   * @param hiveNumber The ID of the hive to filter by (corresponds to hive_id).
   * @returns A promise that resolves to an array of hive inspection attributes.
   */
  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<hive_inspectionsAttributes[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await hive_inspections.findAll({
      include: [
        {
          // 1. Include the 'majorInspection' association
          // This ensures the hive inspection is linked to a major inspection
          // that belongs to the specified location.
          association: 'majorInspection', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          where: { location_id: locationId }, // Filter major_inspections by their location_id column
          required: true, // Perform an INNER JOIN, meaning the major inspection must exist and match the locationId
        },
        {
          // 2. Include the 'hive' association
          // This ensures the hive inspection is linked to a hive
          // that also belongs to the specified location.
          association: 'hive', // This alias must be defined in your hive_inspections model's BelongsTo decorator
          required: true, // Perform an INNER JOIN, meaning the hive must exist
          where: { location_id: locationId }, // Filter hives by their location_id column
        },
      ],
      where: {
        // 3. Filter the primary hive_inspections by the specific hive_id
        hive_id: hiveNumber,
      },
      order: [['created_at', 'ASC']],
    });
    return hiveInspections.map((hi) => hi.toJSON());
  }
}


// filepath: services\hiveService.ts
// src/services/hiveService.ts

import { hives, hivesAttributes } from '../database/models-ts/hives.js';
import { locations } from '../database/models-ts/locations.js';

export class HiveService {
  /**
   * Retrieves all hives associated with a specific location, ensuring the location belongs to the user.
   * @param userId The ID of the authenticated user.
   * @param locationId The ID of the location to retrieve hives for.
   * @returns A promise that resolves to an array of hive objects.
   */
  public static async getHivesByLocationId(locationId: string): Promise<hivesAttributes[]> {
    const hivesFound = await hives.findAll({
      where: {
        location_id: locationId,
      },
    });
    return hivesFound.map((hive) => hive.toJSON());
  }

  /**
   * Retrieves a single hive by its ID and location ID, ensuring the location belongs to the user.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to retrieve.
   * @returns A promise that resolves to the hive object or null if not found.
   */
  public static async getHiveById(locationId: string, hiveId: string): Promise<hivesAttributes | null> {
    const hive = await hives.findOne({
      where: {
        hive_id: hiveId,
        location_id: locationId,
      },
    });
    return hive ? hive.toJSON() : null;
  }

  /**
   * Creates a new hive for a given location.
   * @param locationId The ID of the parent location.
   * @param hiveData The data for the new hive.
   * @returns A promise that resolves to the newly created hive object.
   */
  public static async createHive(locationId: string, hiveData: hivesAttributes): Promise<hivesAttributes> {
    console.log('Service Creating hive...', locationId, hiveData);

    const newHive = await hives.create({
      ...hiveData,
      location_id: locationId,
    });
    return newHive.toJSON();
  }

  /**
   * Updates an existing hive.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to update.
   * @param updateData The data to update.
   * @returns A promise that resolves to the updated hive object or null if not found.
   */
  public static async updateHive(locationId: string, hiveId: string, updateData: Partial<hivesAttributes>): Promise<hivesAttributes | null> {
    // Check if the hive exists and belongs to the user and location
    const hiveToUpdate = await HiveService.getHiveById(locationId, hiveId);

    if (!hiveToUpdate) {
      return null;
    }

    const [numberOfAffectedRows, affectedRows] = await hives.update(updateData, {
      where: { hive_id: hiveId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }

    return affectedRows[0].toJSON();
  }

  /**
   * Deletes a hive by its ID and location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @param hiveId The ID of the hive to delete.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public static async deleteHive(locationId: string, hiveId: string): Promise<boolean> {
    console.log('Service (deleteHive) Deleting hive...', locationId, hiveId);
    // Find the hive first with the ownership checks
    const hiveToDelete = await hives.findOne({
      attributes: ['hive_id'],
      where: {
        hive_id: hiveId,
        location_id: locationId,
      },
      raw: true,
    });

    if (!hiveToDelete) {
      return false;
    }

    console.log('Service (deleteHive) Found hive to delete:', hiveToDelete);

    const deletedRows = await hives.destroy({
      where: {
        hive_id: hiveToDelete.hive_id,
      },
    });

    return deletedRows > 0;
  }

  /**
   * Deletes all hives by their location ID, ensuring ownership.
   * @param locationId The ID of the parent location.
   * @returns A promise that resolves to a boolean indicating success.
   */
  public static async deleteAllHives(locationId: string): Promise<boolean> {
    const deletedRows = await hives.destroy({
      where: {
        location_id: locationId,
      },
    });

    return deletedRows > 0;
  }
}


// filepath: services\locationService.ts
// src/services/locationService.ts

// import { Location } from '../database/models-obsolete/Location.js';
// import { Location as LocationInterface } from '../types/models.js'; // Import the interface
import { locations as locationsModel, locationsAttributes } from '../database/models-ts/locations.js';
//import {LocationCreationAttributes} from '../database/models/Location.js'; // Import the creation attributes type
//import { CreateLocationDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class LocationService {
  /**
   * Creates a new location for a given user.
   * @param userId The ID of the user creating the location.
   * @param locationData The data for the new location.
   * @returns The created location.
   */
  public static async createLocation(userId: string, locationData: locationsAttributes): Promise<locationsAttributes> {
    const newLocation = await locationsModel.create({ ...locationData, user_id: userId });
    return newLocation.toJSON(); // Return plain JSON object
  }

  /**
   * Retrieves all locations for a specific user.
   * @param userId The ID of the user.
   * @returns An array of locations.
   */
  public static async getLocationsByUserId(userId: string): Promise<locationsAttributes[]> {
    const locations = await locationsModel.findAll({ where: { user_id: userId } });
    return locations.map((loc) => loc.toJSON());
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param locationId The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public static async getLocationById(locationId: string, userId: string): Promise<locationsAttributes | null> {
    const location = await locationsModel.findOne({ where: { location_id: locationId, user_id: userId } });
    return location ? location.toJSON() : null;
  }

  /**
   * Updates an existing location.
   * @param locationId The ID of the location to update.
   * @param userId The ID of the user (for authorization).
   * @param updateData The data to update.
   * @returns The updated location or null if not found or not owned.
   */
  public static async updateLocation(locationId: string, userId: string, updateData: Partial<locationsAttributes>): Promise<locationsAttributes | null> {
    const [numberOfAffectedRows, affectedRows] = await locationsModel.update(updateData, {
      where: { location_id: locationId, user_id: userId },
      returning: true, // Return the updated record(s)
    });

    if (numberOfAffectedRows === 0) {
      return null; // Location not found or not owned by user
    }
    return affectedRows[0].toJSON();
  }

  /**
   * Deletes a location.
   * @param locationId The ID of the location to delete.
   * @param userId The ID of the user (for authorization).
   * @returns True if deleted, false if not found or not owned.
   */
  public static async deleteLocation(locationId: string, userId: string): Promise<boolean> {
    const deletedRows = await locationsModel.destroy({
      where: { location_id: locationId, user_id: userId },
    });
    return deletedRows > 0;
  }
}


// filepath: services\majorInspectionService.ts
// src/services/majorInspectionService.ts

//import { MajorInspection } from '../database/models-obsolete/MajorInspection.js'  ;
import { major_inspections } from '../database/models-ts/major_inspections.js'; // Updated to use the new TypeScript model
import { major_inspectionsAttributes } from '../database/models-ts/major_inspections.js'; // Importing the type for major inspection attributes
import { locations } from '../database/models-ts/locations.js';
//import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
//import {MajorInspectionCreationAttributes} from '../database/models/MajorInspection'; // Import the creation attributes type
//import { CreateMajorInspectionDto, UpdateHiveInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class MajorInspectionService {
  public static async createMajorInspection(location_id: string, inspectionData: major_inspectionsAttributes): Promise<major_inspectionsAttributes> {
    console.log('Creating major inspection with data:', location_id, inspectionData);
    // Convert inspectionDate string from DTO to a Date object
    const newInspectionDate = new Date(inspectionData.inspection_date);

    // Create the object to be passed to Sequelize.create()
    const inspectionDataForCreation = {
      ...inspectionData,
      //inspection_date: new Date(inspectionData.inspection_date),
      location_id: location_id, // Ensure the location_id is set correctly
    };

    console.log('Inspection data for creation via sequelize:', inspectionDataForCreation);
    const newMajorInspection = await major_inspections.create({
      ...inspectionDataForCreation,
    });

    return newMajorInspection.toJSON();
  }

  public static async getMajorInspectionsByLocationId(locationId: string): Promise<major_inspectionsAttributes[]> {
    const majorInspections = await major_inspections.findAll({
      where: { location_id: locationId },
      order: [['inspection_date', 'DESC']],
    });
    return majorInspections.map((mi) => mi.toJSON());
  }

  public static async getMajorInspectionById(
    // ZAKAJ MI TO 2x klice z razlicnim vrstnim redom argumentov???????????
    userId: string, // Check ownership by userId
    majorInspectionId: string,
    locationId: string
  ): Promise<major_inspectionsAttributes | null> {
    console.log(`Fetching major inspection by ID...\nmajorInspectionId: ${majorInspectionId}\nlocationId: ${locationId}\nuserId: ${userId}`);

    try {
      const majorInspection = await major_inspections.findOne({
        where: { major_inspection_id: majorInspectionId, location_id: locationId },
      });
    } catch (error) {
      console.error('TEST Error fetching major inspection by ID:', error);
    }

    const majorInspection = await major_inspections.findOne({
      where: { major_inspection_id: majorInspectionId, location_id: locationId },
      include: [
        {
          association: 'majorInspection_location', // Make sure this matches your association name in the MajorInspection model

          where: { location_id: locationId, user_id: userId }, // Ensure the location belongs to the user
          required: true,
        },
      ],
    });
    return majorInspection ? majorInspection.toJSON() : null;
  }

  public static async updateMajorInspection(
    locationId: string,
    majorInspectionId: string,
    updateData: major_inspectionsAttributes
    // Partial<MajorInspectionInterface>
  ): Promise<major_inspectionsAttributes | null> {
    console.log('Updating major inspection service..', majorInspectionId, locationId, updateData);
    const [numberOfAffectedRows, affectedRows] = await major_inspections.update(updateData, {
      where: { location_id: locationId, major_inspection_id: majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteMajorInspection(userId: string, locationId: string, majorInspectionId: string): Promise<boolean> {
    console.log('Deleting major inspection service..', majorInspectionId, locationId, userId);
    // Step 1: Find the major inspection ID that matches all criteria
    const majorInspectionToDelete = await major_inspections.findOne({
      attributes: ['major_inspection_id'], // Only select the ID to minimize data transfer
      where: {
        major_inspection_id: majorInspectionId,
      },
      include: [
        {
          model: locations,
          //as: 'location', // Ensure this matches your association alias
          as: 'majorInspection_location',
          attributes: [],
          where: {
            location_id: locationId,
            user_id: userId, // Ensure the location belongs to the user
          },
          required: true, // This acts as an INNER JOIN, ensuring all conditions must be met
        },
      ],
    });

    if (!majorInspectionToDelete) {
      // No matching major inspection found for the given user, location, and majorInspectionId
      return false;
    }

    // Step 2: Delete the identified major inspection
    const deletedRows = await major_inspections.destroy({
      where: {
        major_inspection_id: majorInspectionToDelete.toJSON().major_inspection_id,
      },
    });

    return deletedRows > 0;
  }
}


// filepath: services\userService.ts
// import { User } from '../database/models-obsolete/User.js';
import { users } from '../database/models-ts/users.js'; // Updated to use the new TypeScript model
import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user creation attributes
//import { User as UserInterface } from '../types/models.js';
//import { UserCreationAttributes } from '../database/models-obsolete/User.js'; // <-- IMPORTANT: Import UserCreationAttributes


export class UserService {
  public static async findUserByEmail(email: string): Promise<usersAttributes | null> {
    const _user = await users.findOne({ where: { email : email } });
    return _user ? _user.toJSON() : null;
  }

  public static async findUserById(id: string): Promise<usersAttributes | null> {
    const _user = await users.findByPk(id);
    return _user ? _user.toJSON() : null;
  }

  public static async createUser(userData: usersAttributes): Promise<usersAttributes> {
    const newUser = await users.create(userData);
    return newUser.toJSON();
  }

  public static async findOrCreateOAuthUser(
    email: string,
    providerId: string,
    provider: 'google' | 'linkedin',
    username?: string
  ): Promise<usersAttributes> {
    let user = await users.findOne({
      where: { email },
    });

    if (user) {
      // Update provider ID if not already set
      if (provider === 'google' && !user.google_id) {
        user.google_id = providerId;
        await user.save();
      } else if (provider === 'linkedin' && !user.linkedin_id) {
        user.linkedin_id = providerId;
        await user.save();
      }
      return user.toJSON();
    } else {
      // Create new user
      const newUser = await users.create({
        email,
        username: username || email.split('@')[0], // Basic username from email if not provided
        google_id: provider === 'google' ? providerId : undefined,
        linkedin_id: provider === 'linkedin' ? providerId : undefined,
      });
      return newUser.toJSON();
    }
  }
}

// filepath: src-summary.txt
// filepath: appExpressInstance.ts

import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';

import config from './config/index.js';
import errorHandler, {CustomError} from './middleware/errorHandler.js'; // Import the error handler

// You'll import your routes here as you create them
 import authRoutes from './routes/authRoutes.js';
 import locationRoutes from './routes/locationRoutes.js';
 import majorInspectionRoutes from './routes/majorInspectionRoutes.js';
import hiveInspectionRoutes from './routes/hiveInspectionRoutes.js';

const app: Application = express();

console.log('BeeHive API configuration is starting...');
// --- Middleware ---
// ... (existing middleware like cors, helmet, morgan, express.json, express.urlencoded) ...
// Enable CORS - allows requests from your frontend domain
// In production, tighten this to specific origins
app.use(cors({
  origin: config.frontendUrl, // Allow requests from your frontend URL
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true, // Allow cookies to be sent
}));

console.log(`CORS enabled for origin: ${config.frontendUrl}`);

// Add security headers (helps prevent common web vulnerabilities)
app.use(helmet());

console.log('Helmet security headers applied');

// Logging HTTP requests to the console
// 'dev' format is concise, change to 'combined' for more details in production
app.use(morgan(config.nodeEnv === 'development' ? 'dev' : 'combined'));

console.log(`Morgan logging enabled in ${config.nodeEnv} mode`);

// Parse JSON request bodies
app.use(express.json());

// Parse URL-encoded request bodies
app.use(express.urlencoded({ extended: true }));

console.log('Express JSON and URL-encoded body parsers enabled');

// --- Routes ---
// Basic health check route
app.get('/api/v1/health', (req: Request, res: Response) => {
  console.log('🚑 Health check endpoint hit');
  res.status(200).json({ status: 'ok', message: 'BeeHive API is running!' });
});

console.log('Health check route added');  

// Mount your API routes here
app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/locations', locationRoutes);
// For nested routes, you might pass sequelize instances or use controllers directly
app.use('/api/v1/locations/:locationId/major-inspections', majorInspectionRoutes);
app.use('/api/v1/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections', hiveInspectionRoutes);

console.log('API routes mounted');  
// --- Error Handling Middleware ---

// Catch 404 Not Found errors
app.use((req: Request, res: Response, next: NextFunction) => {
  const error = new Error(`Not Found - ${req.originalUrl}`) as CustomError; // Cast to CustomError
  error.statusCode = 414; // Set 404 status
  next(error); // Pass the error to the next middleware (our errorHandler)
});
console.log('404 Not Found handler added');

// Centralized error handler
app.use(errorHandler); // This MUST be the last middleware in your chain
console.log('Error handler middleware added');

export default app;



// filepath: config\index.ts
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';


// Get the current file's path
const __filename = fileURLToPath(import.meta.url);

console.log('Current file path:', __filename);
console.log(import.meta.url)

// Get the current directory's path
const __dirname = path.dirname(__filename);


// Load environment variables from .env file
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

// Define the IConfig interface
interface IConfig {
    port: number;
    nodeEnv: string;
    databaseUrl: string;
    jwtSecret: string;
    googleClientId: string;
    googleClientSecret: string;
    linkedinClientId: string;
    linkedinClientSecret: string;
    frontendUrl: string; // For CORS and OAuth redirects
    
  }

// Map environment variables to the IConfig interface
const config: IConfig = {
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',
  databaseUrl: process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/beehive_db',
  jwtSecret: process.env.JWT_SECRET || 'supersecretjwtkeythatshouldbeverylongandrandom',
  googleClientId: process.env.GOOGLE_CLIENT_ID || '',
  googleClientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
  linkedinClientId: process.env.LINKEDIN_CLIENT_ID || '',
  linkedinClientSecret: process.env.LINKEDIN_CLIENT_SECRET || '',
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173', // My React default port

  
};

// Basic validation for critical environment variables
if (!config.jwtSecret || config.jwtSecret === 'supersecretjwtkeythatshouldbeverylongandrandom') {
    console.warn('WARNING: JWT_SECRET is not set or using default. Please set a strong secret in your .env file!');
  }
  if (!config.databaseUrl || config.databaseUrl === 'postgresql://user:password@localhost:5432/beehive_db') {
      console.warn('WARNING: DATABASE_URL is not set or using default. Please configure your PostgreSQL connection in your .env file!');
  }
  if (config.nodeEnv === 'production' && (!config.googleClientId || !config.googleClientSecret || !config.linkedinClientId || !config.linkedinClientSecret)) {
      console.warn('WARNING: OAuth client IDs/secrets are not set for production. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET are configured.');
  }
  
  
  
export default config;

// filepath: controllers\authController.ts
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt.js';
import { CustomError } from '../middleware/errorHandler.js';
import { UserService } from '../services/userService.js'; // New service

export const register = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { username, email, password } = req.body;

    // Check if user already exists
    const existingUser = await UserService.findUserByEmail(email);
    if (existingUser) {
      const error = new Error('User with this email already exists.') as CustomError;
      error.statusCode = 409; // Conflict
      throw error;
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10); // Salt rounds = 10

    // Create user
    const newUser = await UserService.createUser({
      username,
      email,
      password_hash: hashedPassword,
    });

    // Generate token (optional, could just return success message)
    const token = generateToken({ userId: newUser.user_id });

    res.status(201).json({
      success: true,
      message: 'User registered successfully!',
      token,
      user: {
        id: newUser.user_id,
        username: newUser.username,
        email: newUser.email,
      },
    });
  } catch (error) {
    next(error);
  }
};

export const login = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { email, password } = req.body;

    const user = await UserService.findUserByEmail(email);
    if (!user || !user.password_hash) { // Check for user existence and if they have a password (for traditional login)
      const error = new Error('Invalid credentials.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    // Compare password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      const error = new Error('Invalid credentials.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    // Generate token
    const token = generateToken({ userId: user.user_id });

    res.status(200).json({
      success: true,
      message: 'Logged in successfully!',
      token,
      user: {
        id: user.user_id,
        username: user.username,
        email: user.email,
      },
    });
  } catch (error) {
    next(error);
  }
};

export const getMe = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // req.user is set by the `authenticate` middleware
    if (!req.user || !req.user.id) {
      const error = new Error('User not authenticated.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    const user = await UserService.findUserById(req.user.id);
    if (!user) {
      const error = new Error('User not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    // Return user data (excluding password)
    const { password_hash: password, ...userData } = user;
    res.status(200).json({ success: true, user: userData });
  } catch (error) {
    next(error);
  }
};

// --- OAuth Callbacks (simplified for illustration) ---
// In a real app, these would interact with Passport.js for robust OAuth strategies.
// For now, they're just placeholders to demonstrate the concept.

export const googleCallback = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // This part would typically be handled by Passport.js
    // For demo: assume Passport.js has successfully authenticated and added user info to req.user or req.account
    // Example: const { id: googleId, email, displayName } = req.user as any;
    // For now, let's mock it or rely on a successful Passport setup adding it to req.user

    // If Passport.js has successfully authenticated, req.user will contain the user data.
    // If not, this simple controller won't work correctly.
    // Assuming req.user contains the authenticated user from Passport.js or a mock:
    if (!req.user || !req.user.id) {
        const error = new Error('Google authentication failed.') as CustomError;
        error.statusCode = 401;
        throw error;
    }

    // For a real app, you'd use a more robust OAuth flow (e.g., Passport.js)
    // and extract user info from the OAuth provider's response.
    // For this example, let's simulate. In a real Passport.js setup,
    // the 'done' callback in your strategy would populate req.user.
    // We'd then create/find the user in our DB and generate a token.
    // This is a simplified direct token generation after (hypothetical) successful auth.

    // A real Google strategy would call done(null, userObject) if successful.
    // Then req.user would be populated.
    // We're skipping the Passport setup here for brevity.
    const authenticatedUser = await UserService.findUserById(req.user.id); // Assuming req.user.id is populated by passport
    if (!authenticatedUser) {
        const error = new Error('User not found after Google authentication.') as CustomError;
        error.statusCode = 404;
        throw error;
    }

    const token = generateToken({ userId: authenticatedUser.user_id });

    // Redirect to frontend with token (or send token directly, depending on frontend flow)
    // In a real scenario, you'd use a redirect to your frontend with the token
    // e.g., res.redirect(`${config.frontendUrl}/auth/callback?token=${token}`);
    res.status(200).json({ success: true, message: 'Google login successful', token });
  } catch (error) {
    next(error);
  }
};

export const linkedinCallback = async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.user || !req.user.id) {
      const error = new Error('LinkedIn authentication failed.') as CustomError;
      error.statusCode = 401;
      throw error;
    }

    const authenticatedUser = await UserService.findUserById(req.user.id);
    if (!authenticatedUser) {
        const error = new Error('User not found after LinkedIn authentication.') as CustomError;
        error.statusCode = 404;
        throw error;
    }

    const token = generateToken({ userId: authenticatedUser.user_id });
    res.status(200).json({ success: true, message: 'LinkedIn login successful', token });
  } catch (error) {
    next(error);
  }
};

// filepath: controllers\hiveInspectionController.ts
// src/controllers/hiveInspectionController.ts

import {  Response, NextFunction } from 'express';
import { CustomRequest } from '../types/custom-request.js';
import { HiveInspectionService } from '../services/hiveInspectionService.js';
import { MajorInspectionService } from '../services/majorInspectionService.js'; // Needed for ownership check
import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';

//import { ApiError } from '../utils/ApiError';
import { CustomError } from '../middleware/errorHandler.js';
import httpStatus from 'http-status';

export class HiveInspectionController {
  // POST /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async createHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.user!.user_id; // Authenticated user ID

      // 1. Verify ownership of the Major Inspection to the user and location
      const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      // 2. Validate request body against DTO (Joi validation middleware should ideally do this before this point)
      const hiveData: CreateHiveInspectionDto = { ...req.body, majorInspectionId: majorInspectionId }; // Ensure majorInspectionId from param is used

      // 3. Create the Hive Inspection
      const newHiveInspection = await HiveInspectionService.createHiveInspection(majorInspectionId, hiveData);

      res.status(httpStatus.CREATED).send(newHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections
  public static async getHiveInspectionsByMajorInspectionId(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.user!.user_id;

      // Verify ownership of the Major Inspection
      const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);

      res.status(httpStatus.OK).send(hiveInspections);
    } catch (error) {
      next(error);
    }
  }

  // GET /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async getHiveInspectionById(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.user!.user_id;

      // Verify ownership of the Major Inspection
      const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);
      if (!hiveInspection) {
        const _err = new Error('Hive inspection not found under this major inspection.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(hiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // PUT /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async updateHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.user!.user_id;

      // Verify ownership of the Major Inspection
      const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const updateData: UpdateHiveInspectionDto = req.body; // Joi validation should ensure valid partial data

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(hiveInspectionId, majorInspectionId, updateData);

      if (!updatedHiveInspection) {
        const _err = new Error('Hive inspection not found or could not be updated.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.OK).send(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }

  // DELETE /api/locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId
  public static async deleteHiveInspection(req: CustomRequest, res: Response, next: NextFunction): Promise<void> {
    try {
      const { locationId, majorInspectionId, hiveInspectionId } = req.params;
      const userId = req.user!.user_id;

      // Verify ownership of the Major Inspection
      const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);
      if (!majorInspection) {
        const _err = new Error('Major inspection not found or not owned by user in this location.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      const deleted = await HiveInspectionService.deleteHiveInspection(hiveInspectionId, majorInspectionId);

      if (!deleted) {
        const _err = new Error('Hive inspection not found or could not be deleted.') as CustomError;
        _err.statusCode = httpStatus.NOT_FOUND;
        throw _err;
      }

      res.status(httpStatus.NO_CONTENT).send(); // 204 No Content for successful deletion
    } catch (error) {
      next(error);
    }
  }
}


// filepath: controllers\locationController.ts
import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { LocationService } from '../services/locationService.js'; // Import the service
import { Location as LocationInterface } from '../types/models.js'; // Import the interface
// import { Location as LocationInterface } from '../types/models'; // No longer needed for this specific line
import { CreateLocationDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export const createLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id; // Authenticate middleware ensures req.user.id exists
    const locationData: CreateLocationDto  = req.body;

    const newLocation = await LocationService.createLocation(userId, locationData);

    res.status(201).json({
      success: true,
      message: 'Location created successfully',
      data: newLocation,
    });
  } catch (error) {
    next(error);
  }
};

export const getLocations = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;

    const locations = await LocationService.getLocationsByUserId(userId);

    res.status(200).json({
      success: true,
      data: locations,
    });
  } catch (error) {
    next(error);
  }
};

export const getLocationById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    const location = await LocationService.getLocationById(id, userId);

    if (!location) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: location,
    });
  } catch (error) {
    next(error);
  }
};

export const updateLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;
    const updateData: Partial<LocationInterface> = req.body;

    const updatedLocation = await LocationService.updateLocation(id, userId, updateData);

    if (!updatedLocation) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Location updated successfully',
      data: updatedLocation,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteLocation = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    const deleted = await LocationService.deleteLocation(id, userId);

    if (!deleted) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Location deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

export const getMapData = async (req: Request, res: Response, next: NextFunction) => {
  try {
      // This endpoint retrieves data for the map view.
      // It should ideally not require authentication if it's meant to show *all* locations to *any* user.
      // If it's only for logged-in users, keep authenticate middleware.
      // For showing "all registered beehive locations within a country" with owner email/username,
      // it might require a join query to get hive counts and owner info across all users.

      // For simplicity, let's just return a placeholder or mock data for now.
      // A real implementation would involve a more complex query involving Users, Locations, and Major/Hive Inspections
      // to aggregate hive counts per location.
      const mockMapData = [
          {
              id: 'loc1',
              latitude: 46.0569, // Ljubljana, Slovenia
              longitude: 14.5058,
              hiveCount: 12,
              ownerUsername: 'SlovenianBeekeeper'
          },
          {
              id: 'loc2',
              latitude: 46.5547, // Maribor, Slovenia
              longitude: 15.6459,
              hiveCount: 8,
              ownerUsername: 'ApiaryExplorer'
          }
      ];

      res.status(200).json({
          success: true,
          data: mockMapData
      });

  } catch (error) {
      next(error);
  }
};

// filepath: controllers\majorInspectionContoller.ts
// src/controllers/majorInspectionController.ts

import { Request, Response, NextFunction } from 'express';
import { CustomError } from '../middleware/errorHandler.js';
import { MajorInspectionService } from '../services/majorInspectionService.js';
import { LocationService } from '../services/locationService.js'; // To check location ownership
import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';

// Middleware to ensure location belongs to the authenticated user
const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = req.user!.id;
    const { locationId } = req.params;

    const location = await LocationService.getLocationById(locationId, userId);
    if (!location) {
      const error = new Error('Location not found or unauthorized.') as CustomError;
      error.statusCode = 403; // Forbidden
      throw error;
    }
    next(); // Location is owned by the user, proceed
  } catch (error) {
    next(error);
  }
};

export const createMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { locationId } = req.params;
    //const inspectionData: Partial<MajorInspectionInterface> = req.body;
    const inspectionData: CreateMajorInspectionDto = req.body;

    const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);

    res.status(201).json({
      success: true,
      message: 'Major inspection created successfully',
      data: newMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspections = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { locationId } = req.params;

    const majorInspections = await MajorInspectionService.getMajorInspectionsByLocationId(locationId);

    res.status(200).json({
      success: true,
      data: majorInspections,
    });
  } catch (error) {
    next(error);
  }
};

export const getMajorInspectionById = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.user!.id;

    const majorInspection = await MajorInspectionService.getMajorInspectionById(majorInspectionId, locationId, userId);

    if (!majorInspection) {
      const error = new Error('Major inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      data: majorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const updateMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const updateData: UpdateMajorInspectionDto = req.body;

    const updatedMajorInspection = await MajorInspectionService.updateMajorInspection(majorInspectionId, locationId, updateData);

    if (!updatedMajorInspection) {
      const error = new Error('Major inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection updated successfully',
      data: updatedMajorInspection,
    });
  } catch (error) {
    next(error);
  }
};

export const deleteMajorInspection = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;

    const deleted = await MajorInspectionService.deleteMajorInspection(majorInspectionId, locationId);

    if (!deleted) {
      const error = new Error('Major inspection not found.') as CustomError;
      error.statusCode = 404;
      throw error;
    }

    res.status(200).json({
      success: true,
      message: 'Major inspection deleted successfully',
    });
  } catch (error) {
    next(error);
  }
};

export { checkLocationOwnership }; // Export for use in routes


// filepath: controllers\notes.md
REST API Endpoints
We'll categorize the endpoints by resource. All endpoints will be prefixed with /api/v1 for versioning.

Base URL: http://localhost:3000/api/v1 (assuming your backend runs on port 3000)

1. Authentication Endpoints
   These are crucial but we won't go into the full implementation details here as it's a complex topic involving OAuth strategies and JWTs.

POST /auth/register

Purpose: Register a new user with username/password.
Request Body: { username, email, password }
Response: { message: "User registered successfully", user: { id, username, email } } or { error: "..." }
POST /auth/login

Purpose: Authenticate user with username/password.
Request Body: { email, password }
Response: { message: "Logged in successfully", token: "jwt_token", user: { id, username, email } } or { error: "..." }
GET /auth/google (Initiate Google OAuth flow)

GET /auth/google/callback (Google OAuth callback)

GET /auth/linkedin (Initiate LinkedIn OAuth flow)

GET /auth/linkedin/callback (LinkedIn OAuth callback)

GET /auth/me (Protected)

Purpose: Get authenticated user's profile.
Headers: Authorization: Bearer <jwt_token>
Response: { id, username, email, ... } 2. Locations Endpoints
GET /locations (Protected)

Purpose: Retrieve all locations for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<Location>
JSON

[
{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
},
// ... more locations
]
GET /locations/:id (Protected)

Purpose: Retrieve a specific location by ID for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives behind the garage",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
POST /locations (Protected)

Purpose: Create a new location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name, address, latitude, longitude, description }
JSON

{
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees"
}
Response: New Location object (including id, userId, createdAt, updatedAt)
JSON

{
"id": "uuid_new_location",
"userId": "user_uuid",
"name": "New Orchard Location",
"address": "456 Apple Blvd",
"latitude": 34.0522,
"longitude": -118.2437,
"description": "Hives near the apple trees",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T10:00:00Z"
}
PUT /locations/:id (Protected)

Purpose: Update an existing location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { name?, address?, latitude?, longitude?, description? } (partial updates allowed)
JSON

{
"description": "Hives moved to the lower orchard"
}
Response: Updated Location object
JSON

{
"id": "uuid1",
"userId": "user_uuid",
"name": "My Backyard Apiary",
"address": "123 Main St",
"latitude": 40.7128,
"longitude": -74.0060,
"description": "Hives moved to the lower orchard",
"createdAt": "2023-10-26T10:00:00Z",
"updatedAt": "2023-10-26T11:30:00Z"
}
DELETE /locations/:id (Protected)

Purpose: Delete a location for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Location deleted successfully" } or { error: "..." }
GET /locations/map-data (Protected)

Purpose: Retrieve all beehive locations with owner information and hive counts for the map view. (This could be a public endpoint or protected depending on your design for the map view visibility). If public, owner info should be limited (e.g., username, not email).
Headers: Authorization: Bearer <jwt_token> (if protected)
Response: Array<MapLocationData>
JSON

[
{
"id": "uuid1",
"latitude": 40.7128,
"longitude": -74.0060,
"hiveCount": 5,
"ownerUsername": "beekeeper_john"
},
{
"id": "uuid2",
"latitude": 34.0522,
"longitude": -118.2437,
"hiveCount": 8,
"ownerUsername": "apiary_master"
}
// ... more map data
]

3. Major Inspections Endpoints
   Major Inspections are nested under Locations.

GET /locations/:locationId/major-inspections (Protected)

Purpose: Retrieve all major inspections for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<MajorInspection>
JSON

[
{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
},
// ... more major inspections for this location
]
GET /locations/:locationId/major-inspections/:id (Protected)

Purpose: Retrieve a specific major inspection by ID for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "General check-up before summer",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-05-01T10:00:00Z"
}
POST /locations/:locationId/major-inspections (Protected)

Purpose: Create a new major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate, notes }
JSON

{
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells."
}
Response: New MajorInspection object
JSON

{
"id": "major_uuid_new",
"locationId": "uuid1",
"inspectionDate": "2024-06-05",
"notes": "Post-spring inspection, focusing on new queen cells.",
"createdAt": "2024-06-05T10:00:00Z",
"updatedAt": "2024-06-05T10:00:00Z"
}
PUT /locations/:locationId/major-inspections/:id (Protected)

Purpose: Update an existing major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: { inspectionDate?, notes? } (partial updates allowed)
JSON

{
"notes": "Updated notes: Queen confirmed laying well."
}
Response: Updated MajorInspection object
JSON

{
"id": "major_uuid_1",
"locationId": "uuid1",
"inspectionDate": "2024-05-01",
"notes": "Updated notes: Queen confirmed laying well.",
"createdAt": "2024-05-01T10:00:00Z",
"updatedAt": "2024-06-05T11:00:00Z"
}
DELETE /locations/:locationId/major-inspections/:id (Protected)

Purpose: Delete a major inspection for a specific location, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Major inspection deleted successfully" } 4. Hive Inspections Endpoints
Hive Inspections are nested under Major Inspections.

GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Retrieve all hive inspections for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection>
JSON

[
{
"id": "hive_uuid_1",
"majorInspectionId": "major_uuid_1",
"hiveNumber": "Hive A",
"inspectionHour": "10:30",
"colonyHealthStatus": "thriving",
"numberOfChambers": 3,
"amountOfBrood": "5 frames",
"queenStatus": "seen",
"approximateAmountOfHoney": "10 lbs",
"amountOfDroneComb": "1 frame",
"sugarFeedAdded": true,
"sugarFeedQuantity": "1 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 1,
"queenExcluder": true
},
"numberOfVarroaMitesFound": 5,
"varroaTreatment": false,
"treatmentApplied": "None",
"dosageAmount": null,
"raisingNewQueen": false,
"queenCellAge": null,
"queenCellStatus": null,
"otherNotes": "Strong colony, good build-up.",
"createdAt": "2024-05-01T10:30:00Z",
"updatedAt": "2024-05-01T10:30:00Z"
},
// ... more hive inspections for this major inspection
]
GET /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Retrieve a specific hive inspection by ID for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: HiveInspection object
POST /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections (Protected)

Purpose: Create a new hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (All fields for HiveInspection except id, createdAt, updatedAt)
JSON

{
"hiveNumber": "Hive B",
"inspectionHour": "11:00",
"colonyHealthStatus": "weak",
"numberOfChambers": 2,
"amountOfBrood": "2 frames",
"queenStatus": "not seen",
"approximateAmountOfHoney": "5 lbs",
"amountOfDroneComb": "0 frames",
"sugarFeedAdded": true,
"sugarFeedQuantity": "0.5 gallon",
"beehiveConfiguration": {
"broodChambers": 2,
"supers": 0,
"queenExcluder": false
},
"numberOfVarroaMitesFound": 20,
"varroaTreatment": true,
"treatmentApplied": "Formic acid",
"dosageAmount": "60ml",
"raisingNewQueen": true,
"queenCellAge": 3,
"queenCellStatus": "closed",
"otherNotes": "Queen likely superseded, high varroa count."
}
Response: New HiveInspection object
PUT /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Update an existing hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Request Body: (Partial updates allowed for any HiveInspection field)
JSON

{
"colonyHealthStatus": "thriving",
"varroaTreatment": false,
"treatmentApplied": "None"
}
Response: Updated HiveInspection object
DELETE /locations/:locationId/major-inspections/:majorInspectionId/hive-inspections/:id (Protected)

Purpose: Delete a hive inspection for a specific major inspection, for the authenticated user.
Headers: Authorization: Bearer <jwt_token>
Response: { message: "Hive inspection deleted successfully" }
GET /locations/:locationId/hive-inspections/filter/:hiveNumber (Protected)

Purpose: Filter and view the inspection history for a specific beehive across all major inspections at a location.
Headers: Authorization: Bearer <jwt_token>
Response: Array<HiveInspection> (filtered by hiveNumber for the given location)
Key Backend Components and Considerations:
Project Structure (Node.js/Express/TypeScript):

src/
├── app.ts // Express app setup, middleware, routes
├── server.ts // Entry point, starts the server
├── config/ // Environment variables, database config
│ └── index.ts
├── database/ // ORM setup (Sequelize/TypeORM), models, migrations
│ ├── index.ts
│ ├── models/
│ │ ├── User.ts
│ │ ├── Location.ts
│ │ ├── MajorInspection.ts
│ │ └── HiveInspection.ts
│ └── migrations/
├── middleware/ // Custom middleware (auth, validation, error handling)
│ ├── auth.ts // JWT verification, authorization checks
│ ├── validation.ts // Joi/Zod for input validation
│ └── errorHandler.ts // Centralized error handling
├── controllers/ // Business logic for each resource
│ ├── authController.ts
│ ├── locationController.ts
│ ├── majorInspectionController.ts
│ └── hiveInspectionController.ts
├── routes/ // API routes for each resource
│ ├── authRoutes.ts
│ ├── locationRoutes.ts
│ ├── majorInspectionRoutes.ts
│ └── hiveInspectionRoutes.ts
├── services/ // Database interaction logic (optional, for separation of concerns)
│ ├── locationService.ts
│ └── ...
├── types/ // TypeScript interfaces/types
│ ├── express.d.ts // Extend Request for user property
│ ├── models.ts
│ └── auth.ts
└── utils/ // Utility functions (e.g., password hashing)
└── jwt.ts
Authentication and Authorization:

JWT (JSON Web Tokens): After successful login (traditional or OAuth), issue a JWT. The frontend will include this token in the Authorization header (Bearer <token>) for all protected requests.
Middleware: Implement an authMiddleware that verifies the JWT. If valid, it should extract the userId from the token and attach it to the req.user object (you'll need to extend Express's Request interface in TypeScript).
Authorization: In your controllers, ensure that the userId from the authenticated request matches the userId associated with the data being accessed/modified (e.g., a user can only CRUD their own locations). For nested resources, you'll need to verify ownership of the parent resource as well (e.g., checking if the locationId belongs to the userId before allowing CRUD on MajorInspections within that location).
Input Validation:

Use a library like Joi or Zod to define schemas for your request bodies.
Implement a validationMiddleware that applies these schemas to incoming requests and returns a 400 Bad Request error if validation fails.
Error Handling:

Create a centralized errorHandler middleware. This catches errors thrown by your controllers or other middleware and formats them into a consistent JSON error response (e.g., { success: false, message: "Error message", statusCode: 500 }).
Use try-catch blocks in your controllers to handle asynchronous operations and potential errors gracefully.
ORM (Sequelize or TypeORM):

Sequelize: You'll define models, associations (e.g., User.hasMany(Location), Location.hasMany(MajorInspection)), and use its methods for CRUD operations.
TypeORM: Similar concept, using decorators to define entities and repositories for database interactions.
Migrations: Crucial for managing database schema changes over time.
Concurrency:

Node.js is single-threaded but handles I/O operations asynchronously, making it efficient for many concurrent connections.
Database connection pooling (managed by your ORM) will help handle concurrent database requests.
Ensure your queries are optimized and that you're using indexes where appropriate in PostgreSQL.
Environment Configuration (dotenv):

Store sensitive information (database credentials, JWT secret, OAuth client IDs/secrets) in a .env file and load them into your application using dotenv. Never hardcode these values.
Testing:

Use a testing framework like Mocha or Jest with Supertest for API integration tests.
Write unit tests for individual functions (e.g., utility functions, controller logic that doesn't involve direct DB calls).
This detailed API design and component breakdown should provide a solid foundation for building your Node.js/Express/TypeScript backend. Remember to focus on modularity, testability, and security throughout your development process.


// filepath: database\connect.ts

import { Sequelize } from 'sequelize';
import config from '../config/index.js';
import { associateModels } from './models/associations.js'; // To be created
import { User } from './models/User.js'; // To be created
import { Location } from './models/Location.js'; // To be created
import { MajorInspection } from './models/MajorInspection.js'; // To be created
import { HiveInspection } from './models/HiveInspection.js'; // To be created


const DB_DIALECT = process.env.DB_DIALECT as 'postgres'; // Cast to ensure correct type
const DB_HOST = process.env.DB_HOST as string;
const DB_PORT = parseInt(process.env.DB_PORT || '5432', 10);
const DB_USER = process.env.DB_USER as string;
const DB_PASSWORD = process.env.DB_PASSWORD as string;
const DB_NAME = process.env.DB_NAME as string;

// Ensure all required environment variables are present
if (!DB_DIALECT || !DB_HOST || !DB_USER || !DB_NAME) {
  console.error('Missing one or more database environment variables!');
  // Optionally, throw an error to stop the application from starting
  // throw new Error('Database configuration incomplete.');
}

// Construct the database connection string
const databaseUrl = `${DB_DIALECT}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}`;


// Initialize Sequelize with your database connection string
export const sequelize = new Sequelize(databaseUrl, {
  dialect: 'postgres', // Specify PostgreSQL dialect
  logging: config.nodeEnv === 'development' ? console.log : false, // Log SQL queries in dev mode
  dialectOptions: {
    // You might need these options for production deployments like Heroku or Render
    // ssl: {
    //   require: true,
    //   rejectUnauthorized: false, // For self-signed certificates or services like Heroku
    // },
  },
  define: {
    timestamps: true, // Automatically add createdAt and updatedAt fields
    underscored: true, // Use snake_case for column names (e.g., created_at)
  },
});

export const connectDB = async () => {
  try {
    console.log('PostgreSQL connection trying.');
    await sequelize.authenticate();
    console.log('PostgreSQL connection has been established successfully.');

    // Initialize models
    User.initialize(sequelize);
    Location.initialize(sequelize);
    MajorInspection.initialize(sequelize);
    HiveInspection.initialize(sequelize);

    // Set up associations between models
    associateModels();

    // Sync all models with the database.
    // In production, you'd typically use migrations (e.g., `sequelize-cli`)
    // `alter: true` is good for development but can cause data loss in production.
    if (config.nodeEnv === 'development') {
        console.log('Syncing database models (development mode)...');
        //await sequelize.sync({ alter: true }); // Use { force: true } to drop and recreate tables
        await sequelize.sync({ alter: false }); 
        console.log('Database models synchronized.');
    } else {
        // In production, rely on migrations. If you haven't run migrations,
        // you might still want a simple sync without alter.
        // Or remove this line entirely if you strictly use migrations.
        // await sequelize.sync();
        console.log('In production, use database migrations to manage schema changes.');
    }

  } catch (error) {
    console.error('Unable to connect to the database:', error);
    process.exit(1); // Exit process if database connection fails
  }
};



// filepath: database\models\associations.ts
import { User } from './User.js';
import { Location } from './Location.js';
import { MajorInspection } from './MajorInspection.js';
import { HiveInspection } from './HiveInspection.js';

export const associateModels = () => {
  // User has many Locations
  User.hasMany(Location, {
    foreignKey: 'userId',
    as: 'locations', // Alias for easy eager loading
    onDelete: 'CASCADE',
  });
  Location.belongsTo(User, {
    foreignKey: 'userId',
    as: 'user',
  });

  // Location has many MajorInspections
  Location.hasMany(MajorInspection, {
    foreignKey: 'locationId',
    as: 'majorInspections',
    onDelete: 'CASCADE',
  });
  MajorInspection.belongsTo(Location, {
    foreignKey: 'locationId',
    as: 'location',
  });

  // MajorInspection has many HiveInspections
  MajorInspection.hasMany(HiveInspection, {
    foreignKey: 'majorInspectionId',
    as: 'hiveInspections',
    onDelete: 'CASCADE',
  });
  HiveInspection.belongsTo(MajorInspection, {
    foreignKey: 'majorInspectionId',
    as: 'majorInspection',
  });

  console.log('Model associations set up.');
};

// filepath: database\models\HiveInspection.ts
import { DataTypes, Model, Optional, Sequelize } from 'sequelize';
import {
  HiveInspection as HiveInspectionInterface,
  ColonyHealthStatus,
  QueenStatus,
  TreatmentApplied,
  QueenCellStatus,
  BeehiveConfiguration,
} from '../../types/models.js';

export interface HiveInspectionCreationAttributes extends Optional<HiveInspectionInterface, 'id' | 'createdAt' | 'updatedAt'> {}

export class HiveInspection extends Model<HiveInspectionInterface, HiveInspectionCreationAttributes> implements HiveInspectionInterface {
  public user_id!: string;
  public majorInspectionId!: string; // Foreign key
  public hiveNumber!: string;
  public inspectionHour!: string;
  public colonyHealthStatus!: ColonyHealthStatus;
  public numberOfChambers!: number;
  public amountOfBrood!: string;
  public queenStatus!: QueenStatus;
  public approximateAmountOfHoney!: string;
  public amountOfDroneComb!: string;
  public sugarFeedAdded!: boolean;
  public sugarFeedQuantity?: string | null;
  public beehiveConfiguration!: BeehiveConfiguration; // Stored as JSONB
  public numberOfVarroaMitesFound!: number;
  public varroaTreatment!: boolean;
  public treatmentApplied?: TreatmentApplied | null;
  public dosageAmount?: string | null;
  public raisingNewQueen!: boolean;
  public queenCellAge?: number | null;
  public queenCellStatus?: QueenCellStatus | null;
  public otherNotes?: string | null;

  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  public static initialize(sequelize: Sequelize) {
    HiveInspection.init(
      {
        user_id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false,
        },
        majorInspectionId: {
          type: DataTypes.UUID,
          allowNull: false,
          references: {
            model: 'major_inspections', // Refers to the table name 'major_inspections'
            key: 'id',
          },
          onDelete: 'CASCADE', // If a major inspection is deleted, its hive inspections are also deleted
        },
        hiveNumber: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        inspectionHour: {
          type: DataTypes.STRING(5), // e.g., "10:30"
          allowNull: false,
        },
        colonyHealthStatus: {
          type: DataTypes.ENUM(...Object.values(ColonyHealthStatus)),
          allowNull: false,
        },
        numberOfChambers: {
          type: DataTypes.INTEGER,
          allowNull: false,
        },
        amountOfBrood: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        queenStatus: {
          type: DataTypes.ENUM(...Object.values(QueenStatus)),
          allowNull: false,
        },
        approximateAmountOfHoney: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        amountOfDroneComb: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        sugarFeedAdded: {
          type: DataTypes.BOOLEAN,
          allowNull: false,
        },
        sugarFeedQuantity: {
          type: DataTypes.STRING,
          allowNull: true,
        },
        beehiveConfiguration: {
          type: DataTypes.JSONB, // Store as JSONB for structured data
          allowNull: false,
        },
        numberOfVarroaMitesFound: {
          type: DataTypes.INTEGER,
          allowNull: false,
        },
        varroaTreatment: {
          type: DataTypes.BOOLEAN,
          allowNull: false,
        },
        treatmentApplied: {
          type: DataTypes.ENUM(...Object.values(TreatmentApplied)),
          allowNull: true,
        },
        dosageAmount: {
          type: DataTypes.STRING,
          allowNull: true,
        },
        raisingNewQueen: {
          type: DataTypes.BOOLEAN,
          allowNull: false,
        },
        queenCellAge: {
          type: DataTypes.INTEGER,
          allowNull: true,
        },
        queenCellStatus: {
          type: DataTypes.ENUM(...Object.values(QueenCellStatus)),
          allowNull: true,
        },
        otherNotes: {
          type: DataTypes.TEXT,
          allowNull: true,
        },
        // --- ADDED THESE TIMESTAMP FIELDS FOR TYPESCRIPT ---
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        // --- END ADDED FIELDS ---
      },
      {
        tableName: 'hive_inspections',
        sequelize,
        timestamps: true,
        underscored: true,
      }
    );
  }
}

// filepath: database\models\Location.ts

import { DataTypes, Model, Optional, Sequelize } from 'sequelize';
import { Location as LocationInterface } from '../../types/models.js';

export interface LocationCreationAttributes extends Optional<LocationInterface, 'id' | 'createdAt' | 'updatedAt'> {}

export class Location extends Model<LocationInterface, LocationCreationAttributes> implements LocationInterface {
  public user_id!: string;
  public user_id!: string; // Foreign key
  public name!: string;
  public address!: string;
  public latitude!: number;
  public longitude!: number;
  public description?: string | null;

  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  public static initialize(sequelize: Sequelize) {
    Location.init(
      {
        user_id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false,
        },
        user_id: {
          type: DataTypes.UUID,
          allowNull: false,
          references: {
            model: 'users', // Refers to the table name 'users'
            key: 'id',
          },
          onDelete: 'CASCADE', // If a user is deleted, their locations are also deleted
        },
        name: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        address: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        latitude: {
          type: DataTypes.DOUBLE,
          allowNull: false,
          validate: {
            min: -90,
            max: 90,
          },
        },
        longitude: {
          type: DataTypes.DOUBLE,
          allowNull: false,
          validate: {
            min: -180,
            max: 180,
          },
        },
        description: {
          type: DataTypes.TEXT,
          allowNull: true,
        },
        // --- ADDED THESE TIMESTAMP FIELDS FOR TYPESCRIPT ---
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        // --- END ADDED FIELDS ---
      },
      {
        tableName: 'locations',
        sequelize,
        timestamps: true,
        underscored: true,
      }
    );
  }
}

// filepath: database\models\MajorInspection.ts

import { DataTypes, Model, Optional, Sequelize } from 'sequelize';
import { MajorInspection as MajorInspectionInterface } from '../../types/models.js';

export interface MajorInspectionCreationAttributes extends Optional<MajorInspectionInterface, 'id' | 'createdAt' | 'updatedAt'> {}

export class MajorInspection extends Model<MajorInspectionInterface, MajorInspectionCreationAttributes> implements MajorInspectionInterface {
  public user_id!: string;
  public location_id!: string; // Foreign key
  public inspectionDate!: Date;
  public notes?: string | null;

  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  public static initialize(sequelize: Sequelize) {
    MajorInspection.init(
      {
        user_id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false,
        },
        location_id: {
          type: DataTypes.UUID,
          allowNull: false,
          references: {
            model: 'locations', // Refers to the table name 'locations'
            key: 'id',
          },
          onDelete: 'CASCADE', // If a location is deleted, its major inspections are also deleted
        },
        inspectionDate: {
          type: DataTypes.DATEONLY, // Stores only date (YYYY-MM-DD)
          allowNull: false,
        },
        generalNotes: {
          type: DataTypes.TEXT,
          allowNull: true,
        },
        // --- ADDED THESE TIMESTAMP FIELDS FOR TYPESCRIPT ---
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        // --- END ADDED FIELDS ---
      },
      {
        tableName: 'major_inspections',
        sequelize,
        timestamps: true,
        underscored: true,
      }
    );
  }
}

// filepath: database\models\User.ts
// src/database/models/User.ts

import { DataTypes, Model, Optional, Sequelize } from 'sequelize';
import { User as UserInterface } from '../../types/models.js'; // Corrected the path

// Define a type for the attributes that are allowed for creation
export interface UserCreationAttributes extends Optional<UserInterface, 'id' | 'createdAt' | 'updatedAt'> {}

// Extend the Sequelize Model for your User model
export class User extends Model<UserInterface, UserCreationAttributes> implements UserInterface {
  public user_id!: string;
  public googleId?: string | null;
  public linkedinId?: string | null;
  public username?: string | null;
  public email!: string;
  public password_hash?: string | null;

  // Timestamps
  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;

  // Static method to initialize the model
  public static initialize(sequelize: Sequelize) {
    User.init(
      {
        user_id: {
          type: DataTypes.UUID,
          defaultValue: DataTypes.UUIDV4,
          primaryKey: true,
          allowNull: false,
        },
        googleId: {
          type: DataTypes.STRING,
          unique: true,
          allowNull: true,
        },
        linkedinId: {
          type: DataTypes.STRING,
          unique: true,
          allowNull: true,
        },
        username: {
          type: DataTypes.STRING,
          unique: true,
          allowNull: true,
        },
        email: {
          type: DataTypes.STRING,
          unique: true,
          allowNull: false,
          validate: {
            isEmail: true,
          },
        },
        password_hash: {
          type: DataTypes.STRING, // Hashed password
          allowNull: true,
        },
        // --- ADDED THESE TIMESTAMP FIELDS FOR TYPESCRIPT ---
        createdAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        updatedAt: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        // --- END ADDED FIELDS ---
      },
      {
        tableName: 'users',
        sequelize, // Pass the sequelize instance
        timestamps: true, 
        underscored: true,
      }
    );
  }
}

// filepath: database\models-ts\colony_health_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface colony_health_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "colony_health_statuses",
	schema: "public",
	timestamps: false 
})
export class colony_health_statuses extends Model<colony_health_statusesAttributes, colony_health_statusesAttributes> implements colony_health_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('colony_health_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\hives.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface hivesAttributes {
    hive_id?: string;
    location_id: string;
    hive_name: string;
    description?: string;
    is_active?: boolean;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "hives",
	schema: "public",
	timestamps: false 
})
export class hives extends Model<hivesAttributes, hivesAttributes> implements hivesAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	hive_id?: string;

    @Column({
    	type: DataType.UUID 
    })
    	location_id!: string;

    @Column({
    	type: DataType.STRING(255) 
    })
    	hive_name!: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING 
    })
    	description?: string;

    @Column({
    	allowNull: true,
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("true") 
    })
    	is_active?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\hive_inspections.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface hive_inspectionsAttributes {
    hive_inspection_id?: string;
    major_inspection_id: string;
    hive_id: string;
    inspection_time: string;
    colony_health_status_id: number;
    num_chambers: number;
    brood_frames_count?: number;
    brood_percentage?: string;
    queen_status_id: number;
    approx_honey_weight_kg?: string;
    drone_comb_frames_count?: number;
    drone_comb_percentage?: string;
    sugar_feed_added?: boolean;
    sugar_feed_quantity_kg?: string;
    brood_chambers_count: number;
    supers_count: number;
    queen_excluder_present?: boolean;
    num_varroa_mites_found?: number;
    varroa_treatment_id?: number;
    varroa_treatment_dosage?: string;
    raising_new_queen?: boolean;
    queen_cell_age_days?: number;
    queen_cell_status_id?: number;
    other_notes?: string;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "hive_inspections",
	schema: "public",
	timestamps: false 
})
export class hive_inspections extends Model<hive_inspectionsAttributes, hive_inspectionsAttributes> implements hive_inspectionsAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	hive_inspection_id?: string;

    @Column({
    	type: DataType.UUID 
    })
    	major_inspection_id!: string;

    @Column({
    	type: DataType.UUID 
    })
    	hive_id!: string;

    @Column({
    	type: DataType.STRING 
    })
    	inspection_time!: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	colony_health_status_id!: number;

    @Column({
    	type: DataType.INTEGER 
    })
    	num_chambers!: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	brood_frames_count?: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(5,2) 
    })
    	brood_percentage?: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	queen_status_id!: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(8,2) 
    })
    	approx_honey_weight_kg?: string;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	drone_comb_frames_count?: number;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(5,2) 
    })
    	drone_comb_percentage?: string;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	sugar_feed_added?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(8,2) 
    })
    	sugar_feed_quantity_kg?: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	brood_chambers_count!: number;

    @Column({
    	type: DataType.INTEGER 
    })
    	supers_count!: number;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	queen_excluder_present?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	num_varroa_mites_found?: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	varroa_treatment_id?: number;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(255) 
    })
    	varroa_treatment_dosage?: string;

    @Column({
    	type: DataType.BOOLEAN,
    	defaultValue: Sequelize.literal("false") 
    })
    	raising_new_queen?: boolean;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	queen_cell_age_days?: number;

    @Column({
    	allowNull: true,
    	type: DataType.INTEGER 
    })
    	queen_cell_status_id?: number;

    @Column({
    	allowNull: true,
    	type: DataType.STRING 
    })
    	other_notes?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\index.ts
export * from "./hives.js";
export * from "./usersold.js";
export * from "./location_stands_old.js";
export * from "./users.js";
export * from "./locations.js";
export * from "./major_inspections.js";
export * from "./hive_inspections.js";
export * from "./colony_health_statuses.js";
export * from "./queen_statuses.js";
export * from "./varroa_treatments.js";
export * from "./queen_cell_statuses.js";

// filepath: database\models-ts\locations.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface locationsAttributes {
    location_id?: string;
    user_id: string;
    name: string;
    address?: string;
    latitude?: string;
    longitude?: string;
    country?: string;
    notes?: string;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "locations",
	schema: "public",
	timestamps: false 
})
export class locations extends Model<locationsAttributes, locationsAttributes> implements locationsAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	location_id?: string;

    @Column({
    	type: DataType.UUID 
    })
    	user_id!: string;

    @Column({
    	type: DataType.STRING(255) 
    })
    	name!: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(500) 
    })
    	address?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(9,6) 
    })
    	latitude?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DECIMAL(9,6) 
    })
    	longitude?: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(100) 
    })
    	country?: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING 
    })
    	notes?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\location_stands_old.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface location_stands_oldAttributes {
    id?: number;
    address: string;
    hive_count: number;
    user_id: number;
    created_at?: Date;
}

@Table({
	tableName: "location_stands_old",
	schema: "public",
	timestamps: false 
})
export class location_stands_old extends Model<location_stands_oldAttributes, location_stands_oldAttributes> implements location_stands_oldAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('location_stands_id_seq'::regclass)") 
    })
    	id?: number;

    @Column({
    	type: DataType.STRING(200) 
    })
    	address!: string;

    @Column({
    	type: DataType.INTEGER 
    })
    	hive_count!: number;

    @Column({
    	type: DataType.INTEGER 
    })
    	user_id!: number;

    @Column({
    	type: DataType.DATE(6),
    	defaultValue: Sequelize.literal("now()") 
    })
    	created_at?: Date;

}

// filepath: database\models-ts\major_inspections.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface major_inspectionsAttributes {
    major_inspection_id?: string;
    location_id: string;
    inspection_date: string;
    general_notes?: string;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "major_inspections",
	schema: "public",
	timestamps: false 
})
export class major_inspections extends Model<major_inspectionsAttributes, major_inspectionsAttributes> implements major_inspectionsAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	major_inspection_id?: string;

    @Column({
    	type: DataType.UUID 
    })
    	location_id!: string;

    @Column({
    	type: DataType.STRING 
    })
    	inspection_date!: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING 
    })
    	general_notes?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\queen_cell_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_cell_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_cell_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_cell_statuses extends Model<queen_cell_statusesAttributes, queen_cell_statusesAttributes> implements queen_cell_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_cell_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\queen_statuses.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface queen_statusesAttributes {
    status_id?: number;
    status_name: string;
}

@Table({
	tableName: "queen_statuses",
	schema: "public",
	timestamps: false 
})
export class queen_statuses extends Model<queen_statusesAttributes, queen_statusesAttributes> implements queen_statusesAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('queen_statuses_status_id_seq'::regclass)") 
    })
    	status_id?: number;

    @Column({
    	type: DataType.STRING(50) 
    })
    	status_name!: string;

}

// filepath: database\models-ts\users.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface usersAttributes {
    user_id?: string;
    username: string;
    password_hash?: string;
    email: string;
    google_id?: string;
    linkedin_id?: string;
    created_at?: Date;
    updated_at?: Date;
}

@Table({
	tableName: "users",
	schema: "public",
	timestamps: false 
})
export class users extends Model<usersAttributes, usersAttributes> implements usersAttributes {

    @Column({
    	primaryKey: true,
    	type: DataType.UUID,
    	defaultValue: Sequelize.literal("gen_random_uuid()") 
    })
    	user_id?: string;

    @Column({
    	type: DataType.STRING(255) 
    })
    	username!: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(255) 
    })
    	password_hash?: string;

    @Column({
    	type: DataType.STRING(255) 
    })
    	email!: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(255) 
    })
    	google_id?: string;

    @Column({
    	allowNull: true,
    	type: DataType.STRING(255) 
    })
    	linkedin_id?: string;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	created_at?: Date;

    @Column({
    	allowNull: true,
    	type: DataType.DATE,
    	defaultValue: Sequelize.literal("CURRENT_TIMESTAMP") 
    })
    	updated_at?: Date;

}

// filepath: database\models-ts\usersold.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface usersoldAttributes {
    id?: number;
    name: string;
    email: string;
    born_date: string;
    created_at?: Date;
}

@Table({
	tableName: "usersold",
	schema: "public",
	timestamps: false 
})
export class usersold extends Model<usersoldAttributes, usersoldAttributes> implements usersoldAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('users_id_seq'::regclass)") 
    })
    	id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	name!: string;

    @Column({
    	type: DataType.STRING(100) 
    })
    	email!: string;

    @Column({
    	type: DataType.STRING 
    })
    	born_date!: string;

    @Column({
    	type: DataType.DATE(6),
    	defaultValue: Sequelize.literal("now()") 
    })
    	created_at?: Date;

}

// filepath: database\models-ts\varroa_treatments.ts
import {
	Model, Table, Column, DataType, Index, Sequelize, ForeignKey 
} from "sequelize-typescript";

export interface varroa_treatmentsAttributes {
    treatment_id?: number;
    treatment_name: string;
}

@Table({
	tableName: "varroa_treatments",
	schema: "public",
	timestamps: false 
})
export class varroa_treatments extends Model<varroa_treatmentsAttributes, varroa_treatmentsAttributes> implements varroa_treatmentsAttributes {

    @Column({
    	primaryKey: true,
    	autoIncrement: true,
    	type: DataType.INTEGER,
    	defaultValue: Sequelize.literal("nextval('varroa_treatments_treatment_id_seq'::regclass)") 
    })
    	treatment_id?: number;

    @Column({
    	type: DataType.STRING(100) 
    })
    	treatment_name!: string;

}

// filepath: middleware\auth.ts
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwt.js';
import { CustomError } from './errorHandler.js'; // Import the CustomError interface

// Middleware for authenticating requests using JWT
// export const authenticate = (req: Request, res: Response, next: NextFunction) => {
//   try {
//     // 1. Get the token from the Authorization header
//     const authHeader = req.headers.authorization;

//     if (!authHeader || !authHeader.startsWith('Bearer ')) {
//       const error = new Error('No token provided or invalid token format.') as CustomError;
//       error.statusCode = 401; // Unauthorized
//       throw error;
//     }

//     const token = authHeader.split(' ')[1]; // Extract the token part

//     // 2. Verify the token
//     const decoded = verifyToken(token); // This will throw if invalid/expired

//     // 3. Attach the user ID to the request object for later use in controllers
//     // The `express.d.ts` file ensures `req.user` is recognized.
//     req.user = { id: decoded.userId };

//     // 4. Continue to the next middleware or route handler
//     next();
//   } catch (error: any) {
//     // Catch errors from verifyToken or initial checks
//     const err = error as CustomError;
//     err.statusCode = err.statusCode || 401; // Default to 401 Unauthorized
//     next(err); // Pass the error to the error handling middleware
//   }
// };

export const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      const error = new Error('No token provided or invalid token format.') as CustomError;
      error.statusCode = 401; // Unauthorized
      throw error;
    }

    const token = authHeader.split(' ')[1];

    // Ensure 'verifyToken' is imported correctly and handles token verification,
    // returning an object with 'userId' or throwing an error.
    const decoded = verifyToken(token);

    // This line requires your 'express.d.ts' or 'custom-request.d.ts'
    // to extend the Request interface with a 'user' property.
    req.user = { id: decoded.userId };

    next();
  } catch (error: any) {
    const err = error as CustomError;
    err.statusCode = err.statusCode || 401;
    next(err);
  }
};

// Middleware for authorization (e.g., check if user owns data)
// This is a placeholder and will be implemented within controllers or more specific middlewares

// export const authorizeOwner = async (req: Request, res: Response, next: NextFunction) => {
//     // This is an example of where you would perform authorization.
//     // For locations, you'd fetch the location by ID and check if req.user.id matches location.userId.
//     // For nested resources, you might need to check the parent resource owner.

//     // Example for a location:
//     // const locationId = req.params.id || req.params.locationId;
//     // if (!locationId || !req.user || !req.user.id) {
//     //     const error = new Error('Authentication required for authorization.') as CustomError;
//     //     error.statusCode = 401;
//     //     return next(error);
//     // }

//     // try {
//     //     const location = await LocationService.getLocationById(locationId, req.user.id);
//     //     if (!location) {
//     //         const error = new Error('Location not found or you do not have permission to access it.') as CustomError;
//     //         error.statusCode = 403; // Forbidden
//     //         throw error;
//     //     }
//     //     // If successful, continue
//     //     next();
//     // } catch (error) {
//     //     next(error);
//     // }

//     // For now, just pass through (you'll implement specific owner checks in controllers or specialized middlewares)
//     next();
// };

// filepath: middleware\errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import config from '../config/index.js';
//import { ApiError } from '../utils/ApiError';

// Define a custom error interface for better type hinting
export interface CustomError extends Error {
  statusCode?: number;
  data?: any; // Optional additional data for the error
}

const errorHandler = (err: CustomError, req: Request, res: Response, next: NextFunction) => {
  // Determine status code: prioritize error's statusCode, then check Express's res.statusCode, fallback to 500
  const statusCode = err.statusCode || res.statusCode === 200 ? 500 : res.statusCode;

  res.status(statusCode).json({
    success: false,
    message: err.message || 'Something went wrong!',
    // Include stack trace only in development environment for debugging
    stack: config.nodeEnv === 'development' ? err.stack : {},
    data: err.data || null, // Include additional data if present
  });
};

export default errorHandler;

// filepath: middleware\validation.ts
import { Request, Response, NextFunction } from "express";
import Joi from "joi";
import { CustomError } from "./errorHandler.js";
// import {
//   validationResult,
//   body,
//   param,
//   ValidationChain,
// } from "express-validator"; // Import ValidationChain

import {
  ColonyHealthStatus,
  QueenStatus,
  TreatmentApplied,
  QueenCellStatus,
} from "../types/models.js";

// Type definition for a validation schema map
type SchemaMap = {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
};

/**
 * Middleware to validate request data against a Joi schema.
 * @param schemas An object containing Joi schemas for body, params, and/or query.
 */
export const validate = (schemas: SchemaMap) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (schemas.body) {
        const { error } = schemas.body.validate(req.body, {
          abortEarly: false,
        }); // abortEarly: false to get all errors
        if (error) {
          const validationError = new Error(
            error.details.map((d) => d.message).join(", ")
          ) as CustomError;
          validationError.statusCode = 400; // Bad Request
          validationError.data = error.details; // Include details for frontend parsing
          throw validationError;
        }
      }

      if (schemas.params) {
        const { error } = schemas.params.validate(req.params, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(
            error.details.map((d) => d.message).join(", ")
          ) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      if (schemas.query) {
        const { error } = schemas.query.validate(req.query, {
          abortEarly: false,
        });
        if (error) {
          const validationError = new Error(
            error.details.map((d) => d.message).join(", ")
          ) as CustomError;
          validationError.statusCode = 400;
          validationError.data = error.details;
          throw validationError;
        }
      }

      next(); // If validation passes, move to the next middleware/route handler
    } catch (error) {
      next(error); // Pass any validation errors to the error handling middleware
    }
  };
};

// --- Example Joi Schemas (you will create these in your controllers or a separate schema file) ---
export const locationSchema = Joi.object({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ""),
});

export const createHiveInspectionSchema = Joi.object({
  // majorInspectionId: Joi.string().uuid().required(), // This might come from params, not body
  hiveNumber: Joi.string().required(),
  inspectionHour: Joi.string()
    .pattern(/^\d{2}:\d{2}$/)
    .required(),
  colonyHealthStatus: Joi.string()
    .valid(...Object.values(ColonyHealthStatus))
    .required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string()
    .valid(...Object.values(QueenStatus))
    .required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null).optional(),
  beehiveConfiguration: Joi.object({
    type: Joi.string().required(),
    numberOfFrames: Joi.number().integer().min(1).required(),
    materials: Joi.array().items(Joi.string()).optional(),
    isInsulated: Joi.boolean().optional(),
  }).required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string()
    .valid(...Object.values(TreatmentApplied))
    .allow(null)
    .optional(),
  dosageAmount: Joi.string().allow(null).optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string()
    .valid(...Object.values(QueenCellStatus))
    .allow(null)
    .optional(),
  otherNotes: Joi.string().allow(null).optional(),
});

export const updateHiveInspectionSchema = Joi.object({
  // All fields from createHiveInspectionSchema, but optional
  hiveNumber: Joi.string().optional(),
  // ... and so on for all fields, with .optional()
}).min(1); // At least one field must be provided for update


// filepath: routes\authRoutes.ts
// src/routes/authRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import passport from 'passport';
import Joi from 'joi'; // Import Joi
import { validate } from '../middleware/validation.js'; // Import your Joi-based validate
import { RegisterUserDto, LoginUserDto } from '../types/dtos.js'; // Assuming these DTOs exist
import { UserService } from '../services/userService.js';
import { CustomError } from '../middleware/errorHandler.js'; // Use CustomError
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
//import {CustomRequest} from '../types/custom-request.js'; // To extend Request object with user

const authRouter = Router();

// Assuming isAuthenticated from src/middlewares/isAuthenticated.ts
import { isAuthenticated } from '../middleware/auth.js';
const registerSchema = Joi.object<RegisterUserDto>({
  username: Joi.string().trim().required().messages({
    'string.empty': 'Username is required',
    'any.required': 'Username is required'
  }),
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required'
  }),
  password: Joi.string().min(6).required().messages({
    'string.empty': 'Password is required',
    'string.min': 'Password must be at least 6 characters long',
    'any.required': 'Password is required'
  }),
});

const loginSchema = Joi.object<LoginUserDto>({
  email: Joi.string().email().required().messages({
    'string.empty': 'Email is required',
    'string.email': 'Email must be a valid email address',
    'any.required': 'Email is required'
  }),
  password: Joi.string().required().messages({
    'string.empty': 'Password is required',
    'any.required': 'Password is required'
  }),
});

// --- Local Authentication ---

authRouter.post(
  '/register',
  validate({ body: registerSchema }), // <--- This is how you call it
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { username, email, password }: RegisterUserDto = req.body;

      const existingUser = await UserService.findUserByEmail(email);
      if (existingUser) {
        const error: CustomError = new Error('User with this email already exists');
        error.statusCode = 409; // Conflict
        throw error;
      }

      const hashedPassword = await bcrypt.hash(password, 10);
      const newUser = await UserService.createUser({ username, email, password_hash: hashedPassword });

      const token = jwt.sign({ id: newUser.user_id, email: newUser.email }, process.env.JWT_SECRET!, { expiresIn: '1h' });

      res.status(201).json({ message: 'User registered successfully', user: newUser, token });
    } catch (error) {
      next(error);
    }
  }
);

authRouter.post(
  '/login',
  validate({ body: loginSchema }), // <--- This is how you call it
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body;

      const user = await UserService.findUserByEmail(email);
      if (!user || !user.password_hash) {
        const error: CustomError = new Error('Invalid credentials');
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      const isMatch = await bcrypt.compare(password, user.password_hash);
      if (!isMatch) {
        const error: CustomError = new Error('Invalid credentials');
        error.statusCode = 401; // Unauthorized
        throw error;
      }

      const token = jwt.sign({ id: user.user_id, email: user.email }, process.env.JWT_SECRET!, { expiresIn: '1d' });

      res.status(200).json({ message: 'Logged in successfully', user: user, token });
    } catch (error) {
      next(error);
    }
  }
);

// ... (other auth routes like /logout, /me, Google/LinkedIn OAuth)

export default authRouter;

// filepath: routes\hiveInspectionRoutes.ts
// src/routes/hiveInspectionRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { HiveInspectionService } from '../services/hiveInspectionService.js';
import { MajorInspectionService } from '../services/majorInspectionService.js'; // Needed for ownership checks
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { CreateHiveInspectionDto, UpdateHiveInspectionDto } from '../types/dtos.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

// Assuming these enums are defined in your models/types
import {
  ColonyHealthStatus,
  QueenStatus,
  TreatmentApplied,
  QueenCellStatus,
} from '../types/models.js';

const hiveInspectionRouter = Router();

// --- Joi Schemas for HiveInspection ---
const beehiveConfigurationSchema = Joi.object({
  type: Joi.string().required(),
  numberOfFrames: Joi.number().integer().min(1).required(),
  materials: Joi.array().items(Joi.string()).optional(),
  isInsulated: Joi.boolean().optional(),
});

const createHiveInspectionSchema = Joi.object<CreateHiveInspectionDto>({
  // majorInspectionId will come from params, and is required for the service call,
  // but Joi might pick it up from the merged body. Make it optional in the body schema itself.
  hiveNumber: Joi.string().trim().required(),
  inspectionHour: Joi.string().pattern(/^([01]\d|2[0-3]):([0-5]\d)$/).required().messages({
    'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)'
  }),
  colonyHealthStatus: Joi.string().valid(...Object.values(ColonyHealthStatus)).required(),
  numberOfChambers: Joi.number().integer().min(1).required(),
  amountOfBrood: Joi.string().required(),
  queenStatus: Joi.string().valid(...Object.values(QueenStatus)).required(),
  approximateAmountOfHoney: Joi.string().required(),
  amountOfDroneComb: Joi.string().required(),
  sugarFeedAdded: Joi.boolean().required(),
  sugarFeedQuantity: Joi.string().allow(null, '').optional(),
  beehiveConfiguration: beehiveConfigurationSchema.required(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).required(),
  varroaTreatment: Joi.boolean().required(),
  treatmentApplied: Joi.string().valid(...Object.values(TreatmentApplied)).allow(null).optional(),
  dosageAmount: Joi.string().allow(null, '').optional(),
  raisingNewQueen: Joi.boolean().required(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string().valid(...Object.values(QueenCellStatus)).allow(null).optional(),
  otherNotes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

// All fields optional for update
const updateHiveInspectionSchema = Joi.object<UpdateHiveInspectionDto>({
  hiveNumber: Joi.string().trim().optional(),
  inspectionHour: Joi.string().pattern(/^([01]\d|2[0-3]):([0-5]\d)$/).optional().messages({
    'string.pattern.base': 'Inspection hour must be in HH:MM format (e.g., 14:30)'
  }),
  colonyHealthStatus: Joi.string().valid(...Object.values(ColonyHealthStatus)).optional(),
  numberOfChambers: Joi.number().integer().min(1).optional(),
  amountOfBrood: Joi.string().optional(),
  queenStatus: Joi.string().valid(...Object.values(QueenStatus)).optional(),
  approximateAmountOfHoney: Joi.string().optional(),
  amountOfDroneComb: Joi.string().optional(),
  sugarFeedAdded: Joi.boolean().optional(),
  sugarFeedQuantity: Joi.string().allow(null, '').optional(),
  beehiveConfiguration: beehiveConfigurationSchema.optional(),
  numberOfVarroaMitesFound: Joi.number().integer().min(0).optional(),
  varroaTreatment: Joi.boolean().optional(),
  treatmentApplied: Joi.string().valid(...Object.values(TreatmentApplied)).allow(null).optional(),
  dosageAmount: Joi.string().allow(null, '').optional(),
  raisingNewQueen: Joi.boolean().optional(),
  queenCellAge: Joi.number().integer().min(0).allow(null).optional(),
  queenCellStatus: Joi.string().valid(...Object.values(QueenCellStatus)).allow(null).optional(),
  otherNotes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const hiveInspectionParamsSchema = Joi.object({
  majorInspectionId: Joi.string().guid({ version: ['uuidv4'] }).required(),
  hiveInspectionId: Joi.string().guid({ version: ['uuidv4'] }).required(),
});

// Middleware to check if the :majorInspectionId in the URL param belongs to the authenticated user
// This assumes MajorInspectionService has a method to verify ownership without requiring locationId in URL
const checkMajorInspectionOwnershipForHive = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { majorInspectionId, locationId } = req.params;
    const userId = req.user!.id;

    // IMPORTANT: You need to implement this method in your MajorInspectionService.
    // It should fetch the major inspection and ensure its associated location's userId matches the current user.
    //const majorInspectionOwned = await MajorInspectionService.getMajorInspectionByIdAndVerifyUser(
    const majorInspectionOwned = await MajorInspectionService.getMajorInspectionById(
      majorInspectionId,
      locationId,
      userId
    );

    if (!majorInspectionOwned) {
      const error: CustomError = new Error('Major Inspection not found or not owned by user');
      error.statusCode = 404;
      throw error;
    }
    next();
  } catch (error) {
    next(error);
  }
};


// POST /api/major-inspections/:majorInspectionId/hive-inspections - Create a hive inspection
hiveInspectionRouter.post(
  '/major-inspections/:majorInspectionId/hive-inspections',
  isAuthenticated,
  validate({
    params: Joi.object({ majorInspectionId: Joi.string().guid({ version: ['uuidv4'] }).required() }),
    body: createHiveInspectionSchema
  }),
  checkMajorInspectionOwnershipForHive, // Verify parent MajorInspection ownership
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { majorInspectionId } = req.params;
      // Merge majorInspectionId from URL into the DTO for service call
      const hiveData: CreateHiveInspectionDto = { ...req.body, majorInspectionId };

      const newHiveInspection = await HiveInspectionService.createHiveInspection(majorInspectionId, hiveData);
      res.status(201).json(newHiveInspection);
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections - Get all hive inspections
hiveInspectionRouter.get(
  '/major-inspections/:majorInspectionId/hive-inspections',
  isAuthenticated,
  validate({ params: Joi.object({ majorInspectionId: Joi.string().guid({ version: ['uuidv4'] }).required() }) }),
  checkMajorInspectionOwnershipForHive,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { majorInspectionId } = req.params;
      const hiveInspections = await HiveInspectionService.getHiveInspectionsByMajorInspectionId(majorInspectionId);
      res.status(200).json(hiveInspections);
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Get a specific hive inspection
hiveInspectionRouter.get(
  '/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId',
  isAuthenticated,
  validate({ params: hiveInspectionParamsSchema }),
  checkMajorInspectionOwnershipForHive,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { majorInspectionId, hiveInspectionId } = req.params;
      const hiveInspection = await HiveInspectionService.getHiveInspectionById(hiveInspectionId, majorInspectionId);

      if (!hiveInspection) {
        const error: CustomError = new Error('Hive Inspection not found or not part of specified major inspection');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json(hiveInspection);
    } catch (error) {
      next(error);
    }
  }
);

// PUT /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Update a specific hive inspection
hiveInspectionRouter.put(
  '/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId',
  isAuthenticated,
  validate({ params: hiveInspectionParamsSchema, body: updateHiveInspectionSchema }),
  checkMajorInspectionOwnershipForHive,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { majorInspectionId, hiveInspectionId } = req.params;
      const updateData: UpdateHiveInspectionDto = req.body;

      const updatedHiveInspection = await HiveInspectionService.updateHiveInspection(
        hiveInspectionId,
        majorInspectionId,
        updateData
      );

      if (!updatedHiveInspection) {
        const error: CustomError = new Error('Hive Inspection not found or not part of specified major inspection');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json(updatedHiveInspection);
    } catch (error) {
      next(error);
    }
  }
);

// DELETE /api/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId - Delete a specific hive inspection
hiveInspectionRouter.delete(
  '/major-inspections/:majorInspectionId/hive-inspections/:hiveInspectionId',
  isAuthenticated,
  validate({ params: hiveInspectionParamsSchema }),
  checkMajorInspectionOwnershipForHive,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { majorInspectionId, hiveInspectionId } = req.params;
      const success = await HiveInspectionService.deleteHiveInspection(
        hiveInspectionId,
        majorInspectionId
      );

      if (!success) {
        const error: CustomError = new Error('Hive Inspection not found or not part of specified major inspection');
        error.statusCode = 404;
        throw error;
      }
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
);

export default hiveInspectionRouter;

// filepath: routes\locationRoutes.ts
// src/routes/locationRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { CreateLocationDto, UpdateLocationDto } from '../types/dtos.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';

const locationRouter = Router();

// --- Joi Schemas for Location ---
const createLocationSchema = Joi.object<CreateLocationDto>({
  name: Joi.string().trim().min(3).max(100).required(),
  address: Joi.string().trim().min(5).max(255).required(),
  latitude: Joi.number().min(-90).max(90).required(),
  longitude: Joi.number().min(-180).max(180).required(),
  description: Joi.string().trim().max(500).allow(null, ''),
});

const updateLocationSchema = Joi.object<UpdateLocationDto>({
  name: Joi.string().trim().min(3).max(100).optional(),
  address: Joi.string().trim().min(5).max(255).optional(),
  latitude: Joi.number().min(-90).max(90).optional(),
  longitude: Joi.number().min(-180).max(180).optional(),
  description: Joi.string().trim().max(500).allow(null, '').optional(),
});

const locationIdParamSchema = Joi.object({
  locationId: Joi.string().guid({ version: ['uuidv4'] }).required(), // Validate as UUID
});

// POST /api/locations - Create a new location
locationRouter.post(
  '/',
  isAuthenticated,
  validate({ body: createLocationSchema }), // <--- Body validation
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const locationData: CreateLocationDto = req.body;
      const newLocation = await LocationService.createLocation(userId, locationData);
      res.status(201).json(newLocation);
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/locations/:locationId - Get a specific location by ID
locationRouter.get(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { locationId } = req.params;
      const userId = req.user!.id;
      const location = await LocationService.getLocationById(locationId, userId);

      if (!location) {
        const error: CustomError = new Error('Location not found or not owned by user');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json(location);
    } catch (error) {
      next(error);
    }
  }
);

// PUT /api/locations/:locationId - Update a specific location by ID
locationRouter.put(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema, body: updateLocationSchema }), // <--- Both params and body validation
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { locationId } = req.params;
      const userId = req.user!.id;
      const updateData: UpdateLocationDto = req.body;

      const updatedLocation = await LocationService.updateLocation(locationId, userId, updateData);

      if (!updatedLocation) {
        const error: CustomError = new Error('Location not found or not owned by user');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json(updatedLocation);
    } catch (error) {
      next(error);
    }
  }
);

// DELETE /api/locations/:locationId - Delete a specific location by ID
locationRouter.delete(
  '/:locationId',
  isAuthenticated,
  validate({ params: locationIdParamSchema }), // <--- Params validation
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { locationId } = req.params;
      const userId = req.user!.id;

      const success = await LocationService.deleteLocation(locationId, userId);

      if (!success) {
        const error: CustomError = new Error('Location not found or not owned by user');
        error.statusCode = 404;
        throw error;
      }
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
);

export default locationRouter;

// filepath: routes\majorInspectionRoutes.ts
// src/routes/majorInspectionRoutes.ts

import { Router, Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { MajorInspectionService } from '../services/majorInspectionService.js';
//import { LocationService } from '../services/locationService.js';
import { isAuthenticated } from '../middleware/auth.js';
import { validate } from '../middleware/validation.js';
import { CreateMajorInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js';
import { CustomError } from '../middleware/errorHandler.js';
//import {CustomRequest} from '../types/custom-request.js';
import {
  createMajorInspection,
  checkLocationOwnership,
  getMajorInspections,
  getMajorInspectionById,
  updateMajorInspection,
  deleteMajorInspection,
} from '../controllers/majorInspectionContoller.js';
import { get } from 'http';

const majorInspectionRouter = Router();

// --- Joi Schemas for MajorInspection ---
const createMajorInspectionSchema = Joi.object<CreateMajorInspectionDto>({
  // locationId will come from params, so it's not strictly 'required' in the body schema,
  // but if you also allow it in body, you can make it optional here and rely on merge in handler.
  // For clarity, we'll explicitly get it from params in the handler.
  inspectionDate: Joi.date().iso().required(),
  generalNotes: Joi.string().trim().max(1000).allow(null, ''),
});

const updateMajorInspectionSchema = Joi.object<UpdateMajorInspectionDto>({
  inspectionDate: Joi.date().iso().optional(),
  generalNotes: Joi.string().trim().max(1000).allow(null, '').optional(),
});

const majorInspectionParamsSchema = Joi.object({
  locationId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
  majorInspectionId: Joi.string()
    .guid({ version: ['uuidv4'] })
    .required(),
});

// Middleware to check if the :locationId in the URL param belongs to the authenticated user
// const checkLocationOwnership = async (req: Request, res: Response, next: NextFunction) => {
//   try {
//     const { locationId } = req.params;
//     const userId = req.user!.id;

//     const location = await LocationService.getLocationById(locationId, userId);
//     if (!location) {
//       const error: CustomError = new Error('Location not found or not owned by user');
//       error.statusCode = 404;
//       throw error;
//     }
//     next();
//   } catch (error) {
//     next(error);
//   }
// };

// POST /api/locations/:locationId/major-inspections - Create a major inspection
majorInspectionRouter.post(
  '/locations/:locationId/major-inspections',
  isAuthenticated,
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
    body: createMajorInspectionSchema,
  }),
  checkLocationOwnership, // Ensure the location belongs to the user
  createMajorInspection
  // async (req: Request, res: Response, next: NextFunction) => {
  //   try {
  //     const { locationId } = req.params;

  //     // Merge locationId from params into the DTO if it's not already in the body
  //     const inspectionData: CreateMajorInspectionDto = { ...req.body, locationId };

  //     const newMajorInspection = await MajorInspectionService.createMajorInspection(locationId, inspectionData);
  //     res.status(201).json(newMajorInspection);
  //   } catch (error) {
  //     next(error);
  //   }
  // }
);

// GET /api/locations/:locationId/major-inspections - Get all major inspections for a specific location
majorInspectionRouter.get(
  '/locations/:locationId/major-inspections',
  isAuthenticated,
  validate({
    params: Joi.object({
      locationId: Joi.string()
        .guid({ version: ['uuidv4'] })
        .required(),
    }),
  }),
  checkLocationOwnership,
  getMajorInspections
  // async (req: Request, res: Response, next: NextFunction) => {
  //   try {
  //     const { locationId } = req.params;
  //     // const userId = req.user!.id;
  //     const majorInspections =
  //       await MajorInspectionService.getMajorInspectionsByLocationId(
  //         locationId
  //       );
  //     res.status(200).json(majorInspections);
  //   } catch (error) {
  //     next(error);
  //   }
  // }
);

// GET /api/locations/:locationId/major-inspections/:majorInspectionId - Get a specific major inspection
majorInspectionRouter.get(
  '/locations/:locationId/major-inspections/:majorInspectionId',
  isAuthenticated,
  validate({ params: majorInspectionParamsSchema }),
  checkLocationOwnership,
  getMajorInspectionById
  // async (req: Request, res: Response, next: NextFunction) => {
  //   try {
  //     const { locationId, majorInspectionId } = req.params;
  //     const userId = req.user!.id;

  //     const majorInspection =
  //       await MajorInspectionService.getMajorInspectionById(
  //         majorInspectionId,
  //         locationId,
  //         userId
  //       );

  //     if (!majorInspection) {
  //       const error: CustomError = new Error(
  //         "Major Inspection not found or not owned by user via this location"
  //       );
  //       error.statusCode = 404;
  //       throw error;
  //     }
  //     res.status(200).json(majorInspection);
  //   } catch (error) {
  //     next(error);
  //   }
  // }
);

// PUT /api/locations/:locationId/major-inspections/:majorInspectionId - Update a specific major inspection
majorInspectionRouter.put(
  '/locations/:locationId/major-inspections/:majorInspectionId',
  isAuthenticated,
  validate({
    params: majorInspectionParamsSchema,
    body: updateMajorInspectionSchema,
  }),
  checkLocationOwnership,
  updateMajorInspection
);

// DELETE /api/locations/:locationId/major-inspections/:majorInspectionId - Delete a specific major inspection
majorInspectionRouter.delete(
  '/locations/:locationId/major-inspections/:majorInspectionId',
  isAuthenticated,
  validate({ params: majorInspectionParamsSchema }),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { locationId, majorInspectionId } = req.params;
      const userId = req.user!.id;

      const success = await MajorInspectionService.deleteMajorInspection(majorInspectionId, locationId);

      if (!success) {
        const error: CustomError = new Error('Major Inspection not found or not owned by user via this location');
        error.statusCode = 404;
        throw error;
      }
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
);

export default majorInspectionRouter;


// filepath: server.ts
// src/server.ts

import app from './appExpressInstance.js';
import config from './config/index.js';
import { connectDB } from './database/connect.js'; // You'll create this function later


const startServer = async () => {
  try {
    // 1. Connect to the database
     console.log('Attempting to connect to the database...');
     await connectDB();
     console.log('Database connected successfully.');

    // 2. Start the Express server
    console.log('Starting BeeHive API server... with app.listen');
    app.listen(config.port, () => {
      console.log(`⚡️[server]: Server is running on port ${config.port}`);
      console.log(`Environment: ${config.nodeEnv}`);
      console.log(`Frontend URL for CORS: ${config.frontendUrl}\n🙈-------------------------------------------\n\n`);
    });
  } catch (error) {
    console.error('❌ [server]: Failed to start server:', error);
    process.exit(1); // Exit the process with an error code
  }
};

console.log("startServer();")
startServer();

// filepath: services\hiveInspectionService.ts
// src/services/hiveInspectionService.ts

import { HiveInspection } from '../database/models/HiveInspection.js';
import { HiveInspection as HiveInspectionInterface } from '../types/models.js';
import { HiveInspectionCreationAttributes } from '../database/models/HiveInspection.js'; // Import the creation attributes type

export class HiveInspectionService {
  public static async createHiveInspection(
    majorInspectionId: string,
    hiveInspectionData: HiveInspectionCreationAttributes
  ): Promise<HiveInspectionInterface> {
    const newHiveInspection = await HiveInspection.create({ ...hiveInspectionData, majorInspectionId });
    return newHiveInspection.toJSON();
  }

  public static async getHiveInspectionsByMajorInspectionId(
    majorInspectionId: string
  ): Promise<HiveInspectionInterface[]> {
    const hiveInspections = await HiveInspection.findAll({ where: { majorInspectionId }, order: [['createdAt', 'ASC']] });
    return hiveInspections.map(hi => hi.toJSON());
  }

  public static async getHiveInspectionById(
    id: string,
    majorInspectionId: string
  ): Promise<HiveInspectionInterface | null> {
    const hiveInspection = await HiveInspection.findOne({ where: { user_id: id, majorInspectionId } });
    return hiveInspection ? hiveInspection.toJSON() : null;
  }

  public static async updateHiveInspection(
    id: string,
    majorInspectionId: string,
    updateData: Partial<HiveInspectionInterface>
  ): Promise<HiveInspectionInterface | null> {
    const [numberOfAffectedRows, affectedRows] = await HiveInspection.update(updateData, {
      where: { user_id: id, majorInspectionId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteHiveInspection(
    id: string,
    majorInspectionId: string
  ): Promise<boolean> {
    const deletedRows = await HiveInspection.destroy({
      where: { user_id: id, majorInspectionId },
    });
    return deletedRows > 0;
  }

  public static async getHiveInspectionsByHiveNumber(
    locationId: string, // Need locationId to ensure authorization chain
    hiveNumber: string
  ): Promise<HiveInspectionInterface[]> {
    // This requires a join or two queries to ensure the major inspection belongs to the correct location
    // For simplicity, we'll fetch all hive inspections and filter, or you might need a more complex Sequelize query with `include`
    const hiveInspections = await HiveInspection.findAll({
      include: [{
        association: 'majorInspection', // 'majorInspection' is the 'as' alias in your association
        where: { locationId: locationId },
        required: true // Ensures only major inspections linked to this location are considered
      }],
      where: { hiveNumber },
      order: [['createdAt', 'ASC']]
    });
    return hiveInspections.map(hi => hi.toJSON());
  }
}

// filepath: services\locationService.ts
// src/services/locationService.ts

import { Location } from '../database/models/Location.js';
import { Location as LocationInterface } from '../types/models.js'; // Import the interface
//import {LocationCreationAttributes} from '../database/models/Location.js'; // Import the creation attributes type
import { CreateLocationDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO

export class LocationService {
  /**
   * Creates a new location for a given user.
   * @param userId The ID of the user creating the location.
   * @param locationData The data for the new location.
   * @returns The created location.
   */
  public static async createLocation(
    userId: string, 
    locationData: CreateLocationDto ): Promise<LocationInterface> {
    const newLocation = await Location.create({ ...locationData, user_id: userId });
    return newLocation.toJSON(); // Return plain JSON object
  }

  /**
   * Retrieves all locations for a specific user.
   * @param userId The ID of the user.
   * @returns An array of locations.
   */
  public static async getLocationsByUserId(userId: string): Promise<LocationInterface[]> {
    const locations = await Location.findAll({ where: { user_id: userId } });
    return locations.map(loc => loc.toJSON());
  }

  /**
   * Retrieves a single location by its ID, ensuring it belongs to the given user.
   * @param id The ID of the location.
   * @param userId The ID of the user.
   * @returns The location or null if not found or not owned by user.
   */
  public static async getLocationById(id: string, userId: string): Promise<LocationInterface | null> {
    const location = await Location.findOne({ where: { user_id: id, user_id: userId } });
    return location ? location.toJSON() : null;
  }

  /**
   * Updates an existing location.
   * @param id The ID of the location to update.
   * @param userId The ID of the user (for authorization).
   * @param updateData The data to update.
   * @returns The updated location or null if not found or not owned.
   */
  public static async updateLocation(id: string, userId: string, updateData: Partial<LocationInterface>): Promise<LocationInterface | null> {
    const [numberOfAffectedRows, affectedRows] = await Location.update(updateData, {
      where: { user_id: id, user_id: userId },
      returning: true, // Return the updated record(s)
    });

    if (numberOfAffectedRows === 0) {
      return null; // Location not found or not owned by user
    }
    return affectedRows[0].toJSON();
  }

  /**
   * Deletes a location.
   * @param id The ID of the location to delete.
   * @param userId The ID of the user (for authorization).
   * @returns True if deleted, false if not found or not owned.
   */
  public static async deleteLocation(id: string, userId: string): Promise<boolean> {
    const deletedRows = await Location.destroy({
      where: { user_id: id, user_id: userId },
    });
    return deletedRows > 0;
  }
}

// filepath: services\majorInspectionService.ts
// src/services/majorInspectionService.ts

import { MajorInspection } from '../database/models/MajorInspection.js'  ;
import { MajorInspection as MajorInspectionInterface } from '../types/models.js';
//import {MajorInspectionCreationAttributes} from '../database/models/MajorInspection'; // Import the creation attributes type
import { CreateMajorInspectionDto, UpdateHiveInspectionDto, UpdateMajorInspectionDto } from '../types/dtos.js'; // <-- IMPORT THE NEW DTO


export class MajorInspectionService {
  public static async createMajorInspection(
    userId: string,
    inspectionData: CreateMajorInspectionDto
  ): Promise<MajorInspectionInterface> {

    // Convert inspectionDate string from DTO to a Date object
    const newInspectionDate = new Date(inspectionData.inspectionDate);

    // Create the object to be passed to Sequelize.create()
    const inspectionDataForCreation = {
      ...inspectionData,
      inspectionDate: newInspectionDate, // Use the converted Date object
      userId: userId, // Assuming userId is passed from the controller and is the correct foreign key
                      // If your MajorInspection model links to Location, then it should be locationId here
                      // and `locationId` needs to be part of the `CreateMajorInspectionDto`.
                      // BASED ON YOUR LATEST MAJORINSPECTIONDTO, `locationId` is in the DTO,
                      // SO THE FIRST ARGUMENT TO THIS SERVICE FUNCTION SHOULD BE `locationId: string`.
                      // Let's correct this based on the common flow for major inspections:
                      // A major inspection belongs to a specific location, and that location belongs to a user.
                      // So the `createMajorInspection` service function will likely take `userId` AND `locationId`
                      // if you need to verify ownership of the location before creating the inspection.

    };
    const newMajorInspection = await MajorInspection.create({
      // // Use the converted date
      // inspectionDate: newInspectionDate,
      // // Pass other data from the DTO
      // generalNotes: inspectionData.generalNotes,
      // locationId: inspectionData.locationId, // locationId comes from the DTO
      // userId: userId, // userId comes from the first argument (req.user!.id)
      ...inspectionDataForCreation
    });

     return newMajorInspection.toJSON();
  }

  public static async getMajorInspectionsByLocationId(
    locationId: string
  ): Promise<MajorInspectionInterface[]> {
    const majorInspections = await MajorInspection.findAll({ where: { location_id: locationId }, order: [['inspectionDate', 'DESC']] });
    return majorInspections.map(mi => mi.toJSON());
  }

  public static async getMajorInspectionById(
    id: string,
    locationId: string,
    userId: string // Check ownership by userId
  ): Promise<MajorInspectionInterface | null> {
    const majorInspection = await MajorInspection.findOne({
      where: { user_id: id, location_id: locationId },
      include: [
        {
          association: 'location', // Make sure this matches your association name in the MajorInspection model
          where: { userId },
          required: true,
        },
      ],
    });
    return majorInspection ? majorInspection.toJSON() : null;
  }

  public static async updateMajorInspection(
    id: string,
    locationId: string,
    updateData: UpdateMajorInspectionDto
     // Partial<MajorInspectionInterface>
  ): Promise<MajorInspectionInterface | null> {

    // create new date variable and the create new object with that variable and then this object will be passed to the update method
    let newDate = updateData.inspectionDate ? new Date(updateData.inspectionDate) : new Date();
    let newUpdateDataForUpdate  = { ...updateData, 
      inspectionDate: newDate // Use the converted Date object
     };


    const [numberOfAffectedRows, affectedRows] = await MajorInspection.update(newUpdateDataForUpdate, {
      where: { user_id: id, location_id: locationId },
      returning: true,
    });

    if (numberOfAffectedRows === 0) {
      return null;
    }
    return affectedRows[0].toJSON();
  }

  public static async deleteMajorInspection(
    id: string,
    locationId: string
  ): Promise<boolean> {
    const deletedRows = await MajorInspection.destroy({
      where: { user_id: id, location_id: locationId },
    });
    return deletedRows > 0;
  }
}

// filepath: services\userService.ts
import { User } from '../database/models/User.js';
import { User as UserInterface } from '../types/models.js';
import { UserCreationAttributes } from '../database/models/User.js'; // <-- IMPORTANT: Import UserCreationAttributes


export class UserService {
  public static async findUserByEmail(email: string): Promise<UserInterface | null> {
    const user = await User.findOne({ where: { email } });
    return user ? user.toJSON() : null;
  }

  public static async findUserById(id: string): Promise<UserInterface | null> {
    const user = await User.findByPk(id);
    return user ? user.toJSON() : null;
  }

  public static async createUser(userData: UserCreationAttributes): Promise<UserInterface> {
    const newUser = await User.create(userData);
    return newUser.toJSON();
  }

  public static async findOrCreateOAuthUser(
    email: string,
    providerId: string,
    provider: 'google' | 'linkedin',
    username?: string
  ): Promise<UserInterface> {
    let user = await User.findOne({
      where: { email },
    });

    if (user) {
      // Update provider ID if not already set
      if (provider === 'google' && !user.googleId) {
        user.googleId = providerId;
        await user.save();
      } else if (provider === 'linkedin' && !user.linkedinId) {
        user.linkedinId = providerId;
        await user.save();
      }
      return user.toJSON();
    } else {
      // Create new user
      const newUser = await User.create({
        email,
        username: username || email.split('@')[0], // Basic username from email if not provided
        googleId: provider === 'google' ? providerId : null,
        linkedinId: provider === 'linkedin' ? providerId : null,
      });
      return newUser.toJSON();
    }
  }
}

// filepath: sumarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach(file => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach(file => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();

// filepath: types\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
import { User as UserInterface } from './models.js'; // Assuming your User interface is here

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<UserInterface, 'password'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  user?: AuthenticatedUser; // The authenticated user's details
}

// filepath: types\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from "./models.js";

// DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)
export interface RegisterUserDto {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}

// DTO for user update (all fields optional)
export interface UpdateUserDto {
  username?: string;
  email?: string;
  password?: string;
}

// DTO for user login
export interface LoginUserDto {
  email: string;
  password: string;
}

// DTO for creating a Location
export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}

// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)
export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}
// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto { // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.

// filepath: types\express.d.ts
// src/types/express.d.ts
// This file extends the Express Request interface to include a user property.

// eslint-disable-next-line no-unused-vars
declare namespace Express {
    interface Request {
      user?: {
        id: string; // The user ID from the JWT payload
        // Add other properties if you include them in JwtPayload and need them on req.user
        // email?: string;
        // username?: string;
      };
    }
  }

// filepath: types\models.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    createdAt: Date;
    updatedAt: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '1h', // Token expires in 1 hour
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};



// filepath: summarize-src.ts
// Save this as summarize-src.ts in your project root and run with: npx ts-node summarize-src.ts

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SRC_DIR = __dirname;
const OUTPUT_FILE = path.join(__dirname, 'src-summary2.txt');

function walkDir(dir: string, fileList: string[] = []) {
  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      walkDir(fullPath, fileList);
    } else {
      fileList.push(fullPath);
    }
  });
  return fileList;
}

function summarize() {
  const files = walkDir(SRC_DIR);
  let summary = '';
  files.forEach((file) => {
    summary += `// filepath: ${path.relative(__dirname, file)}\n`;
    summary += fs.readFileSync(file, 'utf-8') + '\n\n';
  });
  fs.writeFileSync(OUTPUT_FILE, summary, 'utf-8');
  console.log(`Summary written to ${OUTPUT_FILE}`);
}

summarize();


// filepath: types\custom-request.ts
// src/types/custom-request.ts
import { Request } from 'express';
//import { User as UserInterface } from './models.js'; // Assuming your User interface is here
import { usersAttributes } from '../database/models-ts/users.js'; // Importing the type for user attributes

// Extend the Express Request type to include the 'user' property
interface AuthenticatedUser extends Omit<usersAttributes, 'password_hash'> {} // Optionally omit password for security

export interface CustomRequest extends Request {
  // user?: AuthenticatedUser; // The authenticated user's details
}


// filepath: types\dtos.ts
import { BeehiveConfiguration, ColonyHealthStatus, QueenCellStatus, QueenStatus, TreatmentApplied } from "./models.js";

// DTO for user registration (excluding fields like ID, timestamps, OAuth IDs)
export interface RegisterUserDto {
  username: string;
  email: string;
  password: string; // Password is required for direct registration
}

// DTO for user update (all fields optional)
export interface UpdateUserDto {
  username?: string;
  email?: string;
  password?: string;
}

// DTO for user login
export interface LoginUserDto {
  email: string;
  password: string;
}

// DTO for creating a Location
export interface CreateLocationDto {
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description?: string | null; // Optional
}

// You can add more DTOs here as your API grows
// DTO for updating a Location (all fields optional)
export interface UpdateLocationDto {
  name?: string;
  address?: string;
  latitude?: number;
  longitude?: number;
  description?: string | null;
}
// export interface RegisterUserDto { /* ... */ }

export interface CreateMajorInspectionDto { // <-- ADD THIS NEW INTERFACE
  locationId: string;
  inspectionDate: string; // Or Date if you prefer handling Date objects directly in body, but string is common for 'YYYY-MM-DD'
  generalNotes?: string | null;
}

// DTO for updating a Major Inspection
export interface UpdateMajorInspectionDto {
  locationId?: string; // Can be updated if needed, but usually fixed
  inspectionDate?: string;
  generalNotes?: string | null;
}

// DTO for creating a Hive Inspection
export interface CreateHiveInspectionDto {
  majorInspectionId: string; // The major inspection this hive inspection belongs to (comes from body/param)
  hiveNumber: string;
  inspectionHour: string; // E.g., "10:30"
  colonyHealthStatus: ColonyHealthStatus;
  numberOfChambers: number;
  amountOfBrood: string;
  queenStatus: QueenStatus;
  approximateAmountOfHoney: string;
  amountOfDroneComb: string;
  sugarFeedAdded: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration: BeehiveConfiguration; // Should be sent as a JSON object
  numberOfVarroaMitesFound: number;
  varroaTreatment: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}

// DTO for updating a Hive Inspection (all fields optional)
export interface UpdateHiveInspectionDto {
  hiveNumber?: string;
  inspectionHour?: string;
  colonyHealthStatus?: ColonyHealthStatus;
  numberOfChambers?: number;
  amountOfBrood?: string;
  queenStatus?: QueenStatus;
  approximateAmountOfHoney?: string;
  amountOfDroneComb?: string;
  sugarFeedAdded?: boolean;
  sugarFeedQuantity?: string | null;
  beehiveConfiguration?: BeehiveConfiguration;
  numberOfVarroaMitesFound?: number;
  varroaTreatment?: boolean;
  treatmentApplied?: TreatmentApplied | null;
  dosageAmount?: string | null;
  raisingNewQueen?: boolean;
  queenCellAge?: number | null;
  queenCellStatus?: QueenCellStatus | null;
  otherNotes?: string | null;
}
// etc.

// filepath: types\express.d.ts
import { usersAttributes } from '../database/models-ts/users.js';

declare global {
  namespace Express {
    // Define the shape of the authenticated user object that will be attached to req.user.
    // This interface merges your usersAttributes with the Express.User expectation of an 'id' property.
    interface DedicatedUser {
      id: string; // The required 'id' property, which will be populated by usersAttributes.user_id
    }

    // Extend the Request interface to correctly type the 'user' property.
    interface Request {
      currentUser?: DedicatedUser; // Use the newly defined 'User' interface for req.user
    }
  }
}


// filepath: types\models.ts
// src/types/models.ts

// Basic types for common fields
export interface BaseModel {
    //user_id: string; // Assuming UUIDs for IDs
    created_at: Date;
    updated_at: Date;
  }
  
  // User Model
  export interface User extends BaseModel {
    user_id : string; // UUID for user_id    
    googleId?: string | null;
    linkedinId?: string | null;
    username?: string | null;
    email: string;
    password_hash?: string | null; // Hashed password
  }
  
  // Location Model
  export interface Location extends BaseModel {
    user_id: string; // Foreign key to User
    name: string;
    address: string;
    latitude: number;
    longitude: number;
    description?: string | null;
  }
  
  // MajorInspection Model
  export interface MajorInspection extends BaseModel {
    location_id: string;
    inspectionDate: Date; // Date only, but TS Date type is fine
    generalNotes?: string | null;
  }
  
  // HiveInspection Model
  // Using Enums for predefined statuses
  export enum ColonyHealthStatus {
    Thriving = 'thriving',
    Weak = 'weak',
    Failing = 'failing',
  }
  
  export enum QueenStatus {
    Seen = 'seen',
    NotSeen = 'not_seen',
    LayingWell = 'laying_well',
    QueenCellsPresent = 'queen_cells_present',
  }
  
  export enum TreatmentApplied {
    FormicAcid = 'Formic acid',
    OxalicAcid = 'Oxalic acid',
    None = 'None',
  }
  
  export enum QueenCellStatus {
    Open = 'open',
    Closed = 'closed',
  }
  
  export interface BeehiveConfiguration {
    broodChambers: number;
    supers: number;
    queenExcluder: boolean;
  }
  
  export interface HiveInspection extends BaseModel {
    majorInspectionId: string;
    hiveNumber: string; // Identifier for the specific hive (e.g., "Hive A", "Hive 1")
    inspectionHour: string; // e.g., "10:30"
    colonyHealthStatus: ColonyHealthStatus;
    numberOfChambers: number;
    amountOfBrood: string; // e.g., "5 frames", "60%"
    queenStatus: QueenStatus;
    approximateAmountOfHoney: string; // e.g., "10 lbs", "3 frames"
    amountOfDroneComb: string; // e.g., "1 frame", "10%"
    sugarFeedAdded: boolean;
    sugarFeedQuantity?: string | null; // e.g., "1 gallon"
    beehiveConfiguration: BeehiveConfiguration;
    numberOfVarroaMitesFound: number;
    varroaTreatment: boolean;
    treatmentApplied?: TreatmentApplied | null;
    dosageAmount?: string | null;
    raisingNewQueen: boolean;
    queenCellAge?: number | null; // in days
    queenCellStatus?: QueenCellStatus | null;
    otherNotes?: string | null;
  }

// filepath: utils\jwt.ts
// src/utils/jwt.ts

import jwt from 'jsonwebtoken';
import config from '../config/index.js'; // Import your application configuration

interface JwtPayload {
  userId: string;
  // Add any other user-specific data you want to include in the token payload
  // e.g., email: string; username: string; roles: string[];
}

/**
 * Generates a JWT token for a given user ID.
 * @param userId The ID of the user.
 * @returns A signed JWT token string.
 */
export const generateToken = (payload: JwtPayload): string => {
  return jwt.sign(payload, config.jwtSecret, {
    expiresIn: '192h', // Token expires in 8 days
  });
};

/**
 * Verifies a JWT token.
 * @param token The JWT token string.
 * @returns The decoded payload if valid, otherwise throws an error.
 */
export const verifyToken = (token: string): JwtPayload => {
  try {
    // jwt.verify returns the payload if verification is successful.
    // We cast it to our JwtPayload interface.
    return jwt.verify(token, config.jwtSecret) as JwtPayload;
  } catch (error) {
    // If verification fails (e.g., token expired, invalid signature), an error is thrown.
    // Re-throw to be caught by calling middleware/controller.
    throw new Error('Invalid or expired token.');
  }
};


